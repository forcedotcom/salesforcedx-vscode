{
  "!name": "Aura",
  "!define": {
    "!proto": {
      "__defineGetter__": {
        "!type": "fn(key: ?, fn: ?)",
        "!span": "4550[107:45]-4568[107:63]"
      },
      "__defineSetter__": {
        "!type": "fn(key: ?, fn: ?)",
        "!span": "4826[114:45]-4844[114:63]"
      },
      "__lookupGetter__": {
        "!type": "fn(key: ?) -> fn()",
        "!span": "5102[121:45]-5120[121:63]"
      },
      "__lookupSetter__": {
        "!type": "fn(key: ?) -> fn(value: ?)",
        "!span": "5518[130:45]-5536[130:63]"
      }
    },
    "AttributeSet.prototype.set.!1": "[AttributeSet.prototype.set.!1]",
    "AttributeSet.!0": {
      "body": "[?]",
      "!span": "59412[1931:19]-59414[1931:21]"
    },
    "Aura.Utils.Mutex.prototype._setX.!1": {
      "!type": "fn()",
      "!span": "3145[83:20]-3822[102:5]"
    },
    "Aura.Utils.Mutex.prototype._setY.!1": {
      "!type": "fn()",
      "!span": "3315[89:24]-3814[101:9]"
    },
    "Aura.Utils.NumberFormat.prototype.translateDigits.!ret": {
      "<i>": {
        "!type": "string",
        "!span": "7623[237:22]-7624[237:23]"
      }
    },
    "Aura.Utils.Override.!1": {},
    "Aura.Utils.Override.!1.!3": {
      "background": {
        "!type": "bool",
        "!span": "60811[1783:62]-60821[1783:72]"
      }
    },
    "Aura.Utils.Util.prototype.globalEval.!1": {
      "Component": {
        "currentComponentId": {
          "!type": "number",
          "!span": "6406[180:10]-6424[180:28]"
        },
        "prototype": {
          "addHandler": {},
          "toJSON": {},
          "getHandledEvents": {},
          "index": {},
          "findInstancesOf": {},
          "addValueHandler": {},
          "get": {},
          "getFacets": {},
          "createComponentStack": {},
          "getActionCaller": {},
          "getEventDispatcher": {},
          "provide": {},
          "nextGlobalId": "Component.prototype.nextGlobalId",
          "setupGlobalId": "Component.prototype.setupGlobalId",
          "getName": "Component.prototype.getName",
          "getDef": "Component.prototype.getDef",
          "deIndex": "Component.prototype.deIndex",
          "find": "Component.prototype.find",
          "getSuperest": "Component.prototype.getSuperest",
          "findInstanceOf": "Component.prototype.findInstanceOf",
          "isInstanceOf": "Component.prototype.isInstanceOf",
          "implementsDirectly": "Component.prototype.implementsDirectly",
          "removeValueHandler": "Component.prototype.removeValueHandler",
          "addDocumentLevelHandler": "Component.prototype.addDocumentLevelHandler",
          "removeDocumentLevelHandler": "Component.prototype.removeDocumentLevelHandler",
          "finishDestroy": "Component.prototype.finishDestroy",
          "destroy": "Component.prototype.destroy",
          "isRenderedAndValid": "Component.prototype.isRenderedAndValid",
          "superRender": "Component.prototype.superRender",
          "superAfterRender": "Component.prototype.superAfterRender",
          "superRerender": "Component.prototype.superRerender",
          "superUnrender": "Component.prototype.superUnrender",
          "isRendered": "Component.prototype.isRendered",
          "setUnrendering": "Component.prototype.setUnrendering",
          "isUnrendering": "Component.prototype.isUnrendering",
          "setRendered": "Component.prototype.setRendered",
          "getRenderer": "Component.prototype.getRenderer",
          "getRenderable": "Component.prototype.getRenderable",
          "getGlobalId": "Component.prototype.getGlobalId",
          "getLocalId": "Component.prototype.getLocalId",
          "getRendering": "Component.prototype.getRendering",
          "getSuper": "Component.prototype.getSuper",
          "associateElement": "Component.prototype.associateElement",
          "disassociateElements": "Component.prototype.disassociateElements",
          "getElements": "Component.prototype.getElements",
          "getElement": "Component.prototype.getElement",
          "getReference": "Component.prototype.getReference",
          "clearReference": "Component.prototype.clearReference",
          "getShadowAttribute": "Component.prototype.getShadowAttribute",
          "set": "Component.prototype.set",
          "setShadowAttribute": "Component.prototype.setShadowAttribute",
          "markDirty": "Component.prototype.markDirty",
          "markClean": "Component.prototype.markClean",
          "fireChangeEvent": "Component.prototype.fireChangeEvent",
          "autoDestroy": "Component.prototype.autoDestroy",
          "getConcreteComponent": "Component.prototype.getConcreteComponent",
          "isConcrete": "Component.prototype.isConcrete",
          "getAttributeValueProvider": "Component.prototype.getAttributeValueProvider",
          "setAttributeValueProvider": "Component.prototype.setAttributeValueProvider",
          "getComponentValueProvider": "Component.prototype.getComponentValueProvider",
          "getOwner": "Component.prototype.getOwner",
          "addValueProvider": "Component.prototype.addValueProvider",
          "removeValueProvider": "Component.prototype.removeValueProvider",
          "getModel": "Component.prototype.getModel",
          "getEvent": "Component.prototype.getEvent",
          "getEventByDescriptor": "Component.prototype.getEventByDescriptor",
          "fire": "Component.prototype.fire",
          "isDirty": "Component.prototype.isDirty",
          "isValid": "Component.prototype.isValid",
          "toString": "Component.prototype.toString",
          "hasEventHandler": "Component.prototype.hasEventHandler",
          "isFlavorable": "Component.prototype.isFlavorable",
          "getFlavor": "Component.prototype.getFlavor",
          "render": "Component.prototype.render",
          "afterRender": "Component.prototype.afterRender",
          "rerender": "Component.prototype.rerender",
          "unrender": "Component.prototype.unrender",
          "getVersion": "Component.prototype.getVersion",
          "getVersionInternal": "Component.prototype.getVersionInternal",
          "getValueProvider": "Component.prototype.getValueProvider",
          "setupValueProviders": "Component.prototype.setupValueProviders",
          "createActionValueProvider": {},
          "createStyleValueProvider": {},
          "setupComponentDef": "Component.prototype.setupComponentDef",
          "setupSuper": "Component.prototype.setupSuper",
          "setSuperComponent": "Component.prototype.setSuperComponent",
          "setupAttributes": "Component.prototype.setupAttributes",
          "validatePartialConfig": "Component.prototype.validatePartialConfig",
          "getMethodHandler": "Component.prototype.getMethodHandler",
          "setupComponentEvents": "Component.prototype.setupComponentEvents",
          "getHandler": "Component.prototype.getHandler",
          "setupApplicationEventHandlers": "Component.prototype.setupApplicationEventHandlers",
          "setupValueEventHandlers": "Component.prototype.setupValueEventHandlers",
          "setupMethods": "Component.prototype.setupMethods",
          "setupModel": "Component.prototype.setupModel",
          "setupFlavors": "Component.prototype.setupFlavors",
          "doIndex": "Component.prototype.doIndex",
          "doDeIndex": "Component.prototype.doDeIndex",
          "replaceComponentClass": "Component.prototype.replaceComponentClass",
          "injectComponent": "Component.prototype.injectComponent",
          "setProvided": "Component.prototype.setProvided",
          "associateRenderedBy": "Component.prototype.associateRenderedBy",
          "_$getSelfGlobalId$": "Component.prototype._$getSelfGlobalId$",
          "_$getRawValue$": "Component.prototype._$getRawValue$"
        }
      },
      "!span": "6769[166:123]-6807[168:5]"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.addHandler.!2": {
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "request": "+XMLHttpRequest"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.toJSON.!ret": {
      "globalId": {
        "!type": "string",
        "!span": "44781[1501:8]-44791[1501:18]"
      },
      "isValid": {
        "!type": "bool",
        "!span": "44816[1502:8]-44825[1502:17]"
      },
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "className": {
        "!type": "string",
        "!span": "21228[659:24]-21239[659:35]"
      },
      "request": "+XMLHttpRequest"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.getHandledEvents.!ret": {
      "<i>": {
        "!type": "bool",
        "!span": "45351[1518:20]-45369[1518:38]"
      }
    },
    "Aura.Utils.Util.prototype.globalEval.!ret": {
      "prototype": {
        "!proto": "Component.prototype",
        "!span": "6939[173:25]-6948[173:34]",
        "!doc": "Extends from Component (and restore constructor).",
        "constructor": "Aura.Utils.Util.prototype.globalEval.!ret"
      },
      "!type": "fn()",
      "!span": "6415[157:31]-6475[159:5]",
      "!doc": "#if {\"modes\" : [\"PRODUCTION\", \"PRODUCTIONDEBUG\"]}",
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      }
    },
    "Aura.Utils.Util.prototype.compareValues.!ret": {
      "match": {
        "!type": "bool",
        "!span": "14538[459:8]-14545[459:15]"
      },
      "reasons": {
        "!type": "[?]",
        "!span": "14560[460:8]-14569[460:17]"
      },
      "!span": "14528[458:15]-14578[461:5]"
    },
    "Aura.Utils.Util.prototype.compareValues.!ret.reasons.<i>": {
      "index": {
        "!type": "number",
        "!span": "16009[497:36]-16014[497:41]"
      },
      "reason": {
        "!type": "string",
        "!span": "16018[497:45]-16024[497:51]"
      },
      "!span": "16008[497:35]-16051[497:78]"
    },
    "Aura.Utils.Util.prototype.addClass.!0": {
      "className": {
        "!type": "string",
        "!span": "21228[659:24]-21239[659:35]"
      }
    },
    "Aura.Utils.Util.prototype.removeClass.!0": {
      "className": {
        "!type": "string",
        "!span": "21228[659:24]-21239[659:35]"
      }
    },
    "Aura.Utils.Util.prototype.removeElement.!0": {
      "aura_deleted": {
        "!type": "bool",
        "!span": "28510[880:24]-28524[880:38]"
      }
    },
    "Aura.Utils.Util.prototype.formToMap.!ret": {
      "!span": "41156[1242:14]-41158[1242:16]"
    },
    "Aura.Utils.Util.prototype.addValueToMap.!0": {},
    "Aura.Utils.Util.prototype.addMapValueToMap.!0": {
      "<i>": {
        "!span": "45049[1362:17]-45052[1362:20]"
      }
    },
    "Aura.Utils.Util.prototype.squash.!0": {
      "cancelBubble": {
        "!type": "bool",
        "!span": "69925[2070:10]-69937[2070:22]"
      },
      "returnValue": {
        "!type": "bool",
        "!span": "70068[2076:14]-70079[2076:25]"
      }
    },
    "Aura.Utils.Util.prototype.stripTags.!1": "[Aura.Utils.Util.prototype.stripTags.!1]",
    "Aura.Utils.Util.prototype.toArray.!ret": "[?]",
    "Aura.Utils.Util.prototype.setText.!0": {},
    "Aura.Utils.Util.bind.!0": {
      "!type": "fn()",
      "!span": "55089[1654:15]-55318[1658:9]"
    },
    "Aura.Utils.Util.forEach.!0": "[Aura.Utils.Util.forEach.!0]",
    "Aura.Utils.Util.forEach.!1": {
      "!type": "fn(array: [Aura.Utils.Util.forEach.!0])",
      "!span": "57227[1719:25]-57343[1723:5]"
    },
    "Aura.Utils.Util.map.!0": "[?]",
    "Aura.Utils.Util.map.!ret": "[?]",
    "Aura.Utils.Util.reduce.!0": "[?]",
    "Aura.Utils.Util.reduce.!1": {
      "!type": "fn(current: ?, property: ?) -> !0",
      "!span": "56275[1688:35]-56355[1690:5]"
    },
    "Aura.Utils.Util.every.!0": "[?]",
    "Aura.Utils.Util.some.!0": "[?]",
    "Aura.Utils.Util.filter.!1": {
      "!type": "fn(resource: +Aura.Services.AuraClientService$AuraXHR) -> bool",
      "!span": "27570[851:20]-27694[853:21]"
    },
    "Aura.Utils.Util.filter.!ret": "[?]",
    "Aura.Context.AuraContext.prototype.addGlobalValueProvider.!1": {
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "request": "+XMLHttpRequest"
    },
    "Aura.Value.PropertyReferenceValue.prototype.addChangeHandler.!2": {
      "key": {
        "!type": "string",
        "!span": "3199[91:15]-3202[91:18]"
      }
    },
    "Aura.Model.ValueDef.!0": {
      "name": {
        "!type": "string",
        "!span": "1153[44:8]-1157[44:12]"
      },
      "value": {
        "!type": "number",
        "!span": "1180[45:8]-1185[45:13]"
      }
    },
    "Aura.Component.Component.prototype.toJSON.!ret": {
      "globalId": {
        "!type": "string",
        "!span": "44781[1501:8]-44791[1501:18]"
      },
      "isValid": {
        "!type": "bool",
        "!span": "44816[1502:8]-44825[1502:17]"
      },
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "className": {
        "!type": "string",
        "!span": "21228[659:24]-21239[659:35]"
      },
      "request": "+XMLHttpRequest"
    },
    "Aura.Component.Component.prototype.getHandledEvents.!ret": {
      "<i>": {
        "!type": "bool",
        "!span": "45351[1518:20]-45369[1518:38]"
      }
    },
    "Aura.Component.ComponentDefStorage.prototype.clear.!0": {
      "evicted": {
        "!type": "string",
        "!span": "18014[433:23]-18023[433:32]"
      },
      "actionsError": {
        "!type": "bool",
        "!span": "18779[449:39]-18793[449:53]"
      },
      "componentDefStorageError": {
        "!type": "bool",
        "!span": "19272[461:35]-19298[461:61]"
      }
    },
    "Aura.Event.Event.prototype.getParams.!ret": {
      "expression": "string",
      "index": "string",
      "responseUpdated": "bool",
      "value": "+Component",
      "oldValue": "PropertyReferenceValue.lastResult",
      "action": "+Action",
      "<i>": "?",
      "arguments": {
        "<i>": "Aura.Event.Event.params.arguments.<i>"
      }
    },
    "Aura.Event.Event.prototype.statsIndex.<i>": {
      "event": {
        "!type": "+Aura.Event.Event",
        "!span": "9025[262:52]-9032[262:59]"
      },
      "startTime": {
        "!type": "number",
        "!span": "9040[262:67]-9051[262:78]"
      },
      "endTime": {
        "!type": "number",
        "!span": "9064[262:91]-9073[262:100]"
      },
      "!span": "9024[262:51]-9098[262:125]"
    },
    "Aura.Event.Event.!0": {
      "!span": "2888[76:21]-2890[76:23]",
      "eventDispatcher": {
        "<i>": {
          "<i>": {
            "<i>": "AuraEventService.eventDispatcher.<i>.<i>.<i>"
          }
        }
      }
    },
    "Aura.Controller.Action.prototype.popCreationPath.!ret": {
      "relPath": {
        "!type": "string",
        "!span": "7256[239:22]-7263[239:29]"
      },
      "absPath": {
        "!type": "string",
        "!span": "7276[239:42]-7283[239:49]"
      },
      "idx": {
        "!type": "number",
        "!span": "7293[239:59]-7296[239:62]"
      },
      "startIdx": {
        "!type": "number",
        "!span": "7309[239:75]-7317[239:83]"
      }
    },
    "Aura.Controller.Action.prototype.getStored.!ret": {
      "state": {
        "!type": "string",
        "!span": "25543[811:12]-25550[811:19]"
      },
      "storage": {
        "created": {
          "!type": "number",
          "!span": "25606[813:16]-25615[813:25]"
        }
      }
    },
    "Aura.Controller.Action.prototype.getStorageErrorHandler.!ret": {
      "ignoreExisting": {
        "!type": "bool",
        "!span": "36643[1222:8]-36659[1222:24]"
      },
      "errorHandler": "Action.storableConfig"
    },
    "Aura.Controller.Action.prototype.prepareToSend.!ret": {
      "id": {
        "!type": "string",
        "!span": "34527[1153:8]-34531[1153:12]"
      },
      "descriptor": {
        "!type": "string",
        "!span": "34556[1154:8]-34568[1154:20]"
      },
      "callingDescriptor": {
        "!type": "string",
        "!span": "34626[1155:8]-34645[1155:27]"
      },
      "params": "Action.params",
      "version": "Component.valueProviders.<i>"
    },
    "Aura.Controller.Action.prototype.copyToRefresh.!ret": {
      "abortable": {
        "!type": "bool",
        "!span": "36797[1227:18]-36806[1227:27]"
      },
      "callbacks": {
        "SUCCESS": {
          "fn": "XMLHttpRequest.onreadystatechange",
          "s": "+Action"
        },
        "ERROR": {
          "fn": "XMLHttpRequest.onreadystatechange",
          "s": "+Action"
        },
        "INCOMPLETE": {
          "fn": "XMLHttpRequest.onreadystatechange",
          "s": "+Action"
        },
        "<i>": {
          "fn": "XMLHttpRequest.onreadystatechange",
          "s": "+Action"
        }
      }
    },
    "Aura.Services.actionsToComplete.<i>": {
      "!span": "53405[1538:42]-53444[1538:81]"
    },
    "Aura.Services.AuraClientService.prototype.decode.!ret": {
      "status": {
        "!type": "string",
        "!span": "9317[288:12]-9325[288:20]",
        "!doc": "#end"
      },
      "message": {
        "!type": "string",
        "!span": "10073[314:12]-10082[314:21]",
        "!doc": "#end\n#if {\"modes\" : [\"PRODUCTION\", \"PRODUCTIONDEBUG\"]}"
      },
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "className": {
        "!type": "string",
        "!span": "21228[659:24]-21239[659:35]"
      },
      "request": "+XMLHttpRequest"
    },
    "Aura.Services.AuraClientService.prototype.init.!0": {
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "request": "+XMLHttpRequest"
    },
    "Aura.Services.AuraClientService.prototype.send.!3": {
      "background": {
        "!type": "bool",
        "!span": "60811[1783:62]-60821[1783:72]"
      }
    },
    "Aura.Services.AuraClientService.prototype.createXHR.!ret": {
      "withCredentials": {
        "!type": "bool",
        "!span": "66691[1988:24]-66708[1988:41]"
      },
      "onreadystatechange": "AuraClientService.prototype.createXHR.!ret.onreadystatechange"
    },
    "Aura.Services.AuraClientService.prototype.buildParams.!0": {
      "message": {
        "!type": "string",
        "!span": "65680[1959:12]-65689[1959:21]"
      },
      "aura": {
        "context": {
          "!type": "string",
          "!span": "65761[1960:12]-65775[1960:26]"
        },
        "access": {
          "!type": "string",
          "!span": "65883[1963:19]-65896[1963:32]"
        },
        "token": {
          "!type": "string",
          "!span": "65955[1965:19]-65967[1965:31]"
        }
      }
    },
    "Aura.Services.AuraClientService.prototype.createIntegrationErrorConfig.!ret": {
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "request": "+XMLHttpRequest"
    },
    "Aura.Services.AuraComponentService.prototype.newComponentArray.!0": {
      "attributes": {
        "values": {
          "exclusive": {
            "!type": "bool",
            "!span": "14034[388:20]-14045[388:31]"
          },
          "attributes": "AuraComponentService.prototype.newComponentArray.!0.attributes.values"
        }
      },
      "componentDef": "AuraComponentService.prototype.newComponentArray.!0"
    },
    "Aura.Services.AuraComponentService.prototype.requestComponent.!1": {
      "skipCreationPath": {
        "!type": "bool",
        "!span": "6916[192:8]-6934[192:26]"
      },
      "attributes": {
        "values": "?"
      },
      "localId": "?",
      "flavor": "?"
    },
    "Aura.Services.AuraComponentService.prototype.clearDefsFromStorage.!0": {
      "evicted": {
        "!type": "string",
        "!span": "18014[433:23]-18023[433:32]"
      },
      "actionsError": {
        "!type": "bool",
        "!span": "18779[449:39]-18793[449:53]"
      },
      "componentDefStorageError": {
        "!type": "bool",
        "!span": "19272[461:35]-19298[461:61]"
      }
    },
    "Aura.Services.AuraComponentService.prototype.getUpstreamDependencies.!2": {
      "<i>": {
        "!type": "bool",
        "!span": "59507[1579:13]-59514[1579:20]"
      }
    },
    "Aura.Services.AuraComponentService.prototype.getUpstreamDependencies.!ret": {
      "<i>": {
        "!type": "bool",
        "!span": "59507[1579:13]-59514[1579:20]"
      }
    },
    "Aura.Services.AuraEventService.prototype.addHandler.!0": {
      "globalId": {
        "!type": "string",
        "!span": "75297[2308:26]-75307[2308:36]"
      },
      "event": {
        "!type": "string",
        "!span": "75434[2310:26]-75441[2310:33]"
      },
      "handler": "AuraEventService.eventDispatcher.<i>.<i>.<i>"
    },
    "Aura.Services.AuraEventService.prototype.removeHandler.!0": {
      "globalId": {
        "!type": "string",
        "!span": "23654[737:34]-23664[737:44]"
      }
    },
    "Aura.Services.AuraHistoryService.prototype.get.!ret": {
      "token": {
        "!type": "string",
        "!span": "12222[347:16]-12229[347:23]"
      },
      "querystring": {
        "!type": "string",
        "!span": "12242[347:36]-12255[347:49]"
      }
    },
    "Aura.Services.AuraHistoryService.prototype.parseQueryString.!ret": {
      "<i>": {
        "!type": "string",
        "!span": "12790[366:16]-12794[366:20]"
      },
      "token": {
        "!type": "string",
        "!span": "12101[343:20]-12108[343:27]"
      },
      "querystring": {
        "!type": "string",
        "!span": "12139[344:20]-12152[344:33]"
      }
    },
    "Aura.Services.AuraRenderingService.prototype.getUpdatedFacetInfo.!ret": {
      "components": {
        "<i>": {
          "action": {
            "!type": "string",
            "!span": "12934[362:49]-12940[362:55]"
          },
          "oldIndex": {
            "!type": "number",
            "!span": "12989[362:104]-12997[362:112]"
          },
          "newIndex": {
            "!type": "number",
            "!span": "13002[362:117]-13010[362:125]"
          }
        }
      },
      "useFragment": {
        "!type": "bool",
        "!span": "11348[326:8]-11359[326:19]"
      },
      "fullUnrender": {
        "!type": "bool",
        "!span": "11375[327:8]-11387[327:20]"
      },
      "facetInfo": {
        "<i>": "AuraRenderingService.prototype.getUpdatedFacetInfo.!1"
      }
    },
    "Aura.Services.LockerService.!ret": {
      "util": {
        "verifyAccess": {},
        "getKeyForNamespace": "AuraInstance.lockerService.util.getKeyForNamespace",
        "isKeyed": "AuraInstance.lockerService.util.isKeyed",
        "hasAccess": "AuraInstance.lockerService.util.hasAccess",
        "applyKey": "AuraInstance.lockerService.util.applyKey"
      },
      "createForDef": {},
      "trust": {},
      "getEnv": {},
      "isEnabled": "AuraInstance.lockerService.isEnabled",
      "getEnvForSecureObject": {},
      "create": "AuraInstance.lockerService.create",
      "destroy": "AuraInstance.lockerService.destroy",
      "destroyAll": "AuraInstance.lockerService.destroyAll",
      "wrapComponent": "AuraInstance.lockerService.wrapComponent",
      "wrapComponentEvent": "AuraInstance.lockerService.wrapComponentEvent",
      "unwrap": "AuraInstance.lockerService.unwrap",
      "markOpaque": "AuraInstance.lockerService.markOpaque",
      "isOpaque": "AuraInstance.lockerService.isOpaque",
      "showLockedNodes": "AuraInstance.lockerService.showLockedNodes"
    },
    "Aura.Services.LockerService.!ret.util.verifyAccess.!2": {
      "verifyNotOpaque": {
        "!type": "bool",
        "!span": "10042[339:6]-10057[339:21]"
      }
    },
    "Aura.Services.MetricsService.prototype.instrument.!0": {
      "<i>": {
        "!type": "fn()",
        "!span": "2890[77:13]-2896[77:19]"
      }
    },
    "Aura.Services.MetricsService.prototype.instrument.!6": {
      "!type": "fn(original: ?)",
      "!span": "5488[160:16]-5728[164:17]"
    },
    "Aura.Services.MetricsService.prototype.unInstrument.!0": {},
    "Aura.Services.MetricsService.prototype.initializePlugin.!1": {
      "NAME": {
        "!type": "string",
        "!span": "983[29:23]-987[29:27]"
      },
      "AURA_URL": {
        "!type": "string",
        "!span": "1101[31:23]-1109[31:31]"
      },
      "prototype": {
        "postProcess": {},
        "receiveOverride": "TransportMetricsPlugin.prototype.receiveOverride",
        "initialize": "TransportMetricsPlugin.prototype.initialize",
        "enable": "TransportMetricsPlugin.prototype.enable",
        "disable": "TransportMetricsPlugin.prototype.disable",
        "sendOverride": "TransportMetricsPlugin.prototype.sendOverride",
        "bind": "TransportMetricsPlugin.prototype.bind",
        "unbind": "TransportMetricsPlugin.prototype.unbind"
      }
    },
    "Aura.Services.MetricsService.prototype.initializePlugin.!1.prototype.postProcess.!ret": {
      "<i>": {
        "duration": {
          "!type": "number",
          "!span": "4564[123:17]-4574[123:27]"
        },
        "phase": {
          "!type": "string",
          "!span": "4659[124:17]-4666[124:24]"
        }
      }
    },
    "Aura.Services.MetricsService.prototype.getCurrentPageTransaction.!ret": {
      "id": {
        "!type": "string",
        "!span": "19133[578:12]-19137[578:16]"
      },
      "offsets": {
        "<i>": {
          "!type": "number",
          "!span": "19405[586:16]-19406[586:17]"
        }
      },
      "ts": {
        "!type": "number",
        "!span": "19201[580:12]-19205[580:16]"
      },
      "config": "?"
    },
    "Aura.Services.MetricsService.prototype.getCurrentMarks.!ret": {
      "!span": "15971[471:25]-15973[471:27]"
    },
    "Aura.Services.MetricsService.prototype.defaultPostProcessing.!ret": "[Aura.Services.MetricsService.prototype.defaultPostProcessing.!ret.<i>]",
    "Aura.Services.MetricsService.prototype.defaultPostProcessing.!ret.<i>": {
      "duration": {
        "!type": "number",
        "!span": "17266[512:17]-17276[512:27]"
      }
    },
    "Aura.Services.MetricsService.prototype.getTransactions.!ret": "[?|Aura.Services.MetricsService.transactions.<i>]",
    "Aura.Services.MetricsService.prototype.mark.!ret": {
      "ns": {
        "!type": "string",
        "!span": "21764[658:8]-21768[658:12]"
      },
      "name": {
        "!type": "string",
        "!span": "21788[659:8]-21794[659:14]"
      },
      "phase": {
        "!type": "string",
        "!span": "21814[660:8]-21821[660:15]"
      },
      "!span": "21754[657:11]-21928[663:5]"
    },
    "Aura.Services.MetricsService.prototype.registerPlugin.!0": {
      "name": {
        "!type": "string",
        "!span": "5040[139:4]-5046[139:10]"
      },
      "!span": "5034[138:33]-5119[141:1]",
      "plugin": "TransportMetricsPlugin"
    },
    "Aura.Services.AuraStorageService.prototype.CryptoAdapter.!0": {
      "name": {
        "!type": "string",
        "!span": "6706[163:8]-6712[163:14]"
      },
      "maxSize": {
        "!type": "number",
        "!span": "6728[164:8]-6737[164:17]"
      },
      "debugLoggingEnabled": {
        "!type": "bool",
        "!span": "6756[165:8]-6777[165:29]"
      },
      "expiration": {
        "!type": "number",
        "!span": "6808[166:8]-6820[166:20]"
      }
    },
    "Aura.Storage.CryptoAdapter.!0": {
      "name": {
        "!type": "string",
        "!span": "6706[163:8]-6712[163:14]"
      },
      "maxSize": {
        "!type": "number",
        "!span": "6728[164:8]-6737[164:17]"
      },
      "debugLoggingEnabled": {
        "!type": "bool",
        "!span": "6756[165:8]-6777[165:29]"
      },
      "expiration": {
        "!type": "number",
        "!span": "6808[166:8]-6820[166:20]"
      }
    },
    "Aura.Storage.AuraStorage.!0": {
      "name": {
        "!type": "string",
        "!span": "4312[89:8]-4318[89:14]"
      },
      "maxSize": {
        "!type": "number",
        "!span": "4362[91:8]-4371[91:17]"
      },
      "defaultExpiration": {
        "!type": "number",
        "!span": "4390[92:8]-4409[92:27]"
      },
      "defaultAutoRefreshInterval": {
        "!type": "number",
        "!span": "4438[93:8]-4466[93:36]"
      },
      "debugLoggingEnabled": {
        "!type": "bool",
        "!span": "4504[94:8]-4525[94:29]"
      },
      "clearStorageOnInit": {
        "!type": "bool",
        "!span": "4556[95:8]-4576[95:28]"
      },
      "version": {
        "!type": "string",
        "!span": "4606[96:8]-4615[96:17]"
      },
      "isolationKey": {
        "!type": "string",
        "!span": "4634[97:8]-4648[97:22]"
      }
    },
    "Aura.Locker.SecureObject.createFilteredMethod.!ret": {
      "enumerable": {
        "!type": "bool",
        "!span": "8264[284:2]-8274[284:12]"
      },
      "value": "SecureComponent.!ret.superRender"
    },
    "Aura.Locker.SecureObject.createFilteredProperty.!3": {
      "filterOpaque": {
        "!type": "bool",
        "!span": "2377[81:3]-2389[81:15]"
      },
      "ignoreNonexisting": {
        "!type": "bool",
        "!span": "10003[125:6251]-10020[125:6268]"
      }
    },
    "Aura.Locker.SecureObject.createFilteredProperty.!ret": {
      "enumerable": {
        "!type": "bool",
        "!span": "9214[317:2]-9224[317:12]"
      },
      "get": "SecureObject.createFilteredProperty.!ret.get",
      "set": "SecureObject.createFilteredProperty.!ret.set"
    },
    "Aura.Locker.SecureObject.addIfSupported.!4": {
      "filterOpaque": {
        "!type": "bool",
        "!span": "2556[87:3]-2568[87:15]"
      },
      "ignoreNonexisting": {
        "!type": "bool",
        "!span": "10003[125:6251]-10020[125:6268]"
      }
    },
    "AuraInstance.prototype.getContext.!ret": "+Aura.Context.AuraContext",
    "AuraInstance.prototype.log.!1": {},
    "AuraInstance.prototype.getValueProvider.!ret": {
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "request": "+XMLHttpRequest"
    },
    "AuraInstance.prototype.getDefinitions.!0": "[?]",
    "AuraClientService.prototype.decode.!ret": {
      "status": {
        "!type": "string",
        "!span": "9317[288:12]-9325[288:20]",
        "!doc": "#end"
      },
      "message": {
        "!type": "string",
        "!span": "10073[314:12]-10082[314:21]",
        "!doc": "#end\n#if {\"modes\" : [\"PRODUCTION\", \"PRODUCTIONDEBUG\"]}"
      },
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "className": {
        "!type": "string",
        "!span": "21228[659:24]-21239[659:35]"
      },
      "!span": "9135[281:14]-9137[281:16]",
      "request": "+XMLHttpRequest"
    },
    "AuraClientService.prototype.init.!0": {
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "request": "+XMLHttpRequest"
    },
    "AuraClientService.prototype.getStoredResult.!1": {
      "!span": "1263[28:32]-1265[28:34]"
    },
    "AuraClientService.prototype.shouldSendOutForegroundActions.!0": "[AuraInstance.context.contextGlobals]",
    "AuraClientService.prototype.sendAsSingle.!0": "[?]",
    "AuraClientService.prototype.send.!3": {
      "background": {
        "!type": "bool",
        "!span": "60811[1783:62]-60821[1783:72]"
      }
    },
    "AuraClientService.prototype.xhrSetTimeout.!0": {
      "!type": "fn()",
      "!span": "68156[2035:37]-68263[2039:9]"
    },
    "AuraClientService.prototype.createXHR.!ret": {
      "withCredentials": {
        "!type": "bool",
        "!span": "66691[1988:24]-66708[1988:41]"
      },
      "onreadystatechange": {
        "!type": "fn()",
        "!span": "67438[2012:20]-67458[2012:40]"
      }
    },
    "AuraClientService.prototype.buildParams.!0": {
      "message": {
        "!type": "string",
        "!span": "65680[1959:12]-65689[1959:21]"
      },
      "aura": {
        "context": {
          "!type": "string",
          "!span": "65761[1960:12]-65775[1960:26]"
        },
        "access": {
          "!type": "string",
          "!span": "65883[1963:19]-65896[1963:32]"
        },
        "token": {
          "!type": "string",
          "!span": "65955[1965:19]-65967[1965:31]"
        }
      },
      "!span": "65666[1958:21]-65830[1961:9]"
    },
    "AuraClientService.prototype.createIntegrationErrorConfig.!ret": {
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "!doc": "create same messaging as injectComponent",
      "request": "+XMLHttpRequest"
    },
    "AuraComponentContext.prototype.Frame.!0": {
      "_marker": "+Node"
    },
    "AuraComponentService.prototype.getDescriptorFromConfig.!0": {
      "!span": "56936[1873:38]-56990[1873:92]"
    },
    "AuraComponentService.prototype.newComponentArray.!0": {
      "attributes": {
        "values": {
          "exclusive": {
            "!type": "bool",
            "!span": "14034[388:20]-14045[388:31]"
          },
          "!span": "13867[385:26]-14100[389:17]",
          "attributes": "AuraComponentService.prototype.newComponentArray.!0.attributes.values"
        },
        "!span": "13825[384:12]-13837[384:24]",
        "valueProvider": "?"
      },
      "!span": "13662[378:17]-14184[392:9]",
      "componentDef": "AuraComponentService.prototype.newComponentArray.!0"
    },
    "AuraComponentService.prototype.newComponentArray.!ret": "[AuraComponentService.prototype.newComponentArray.!ret|+Aura.Utils.Util.prototype.globalEval.!ret]",
    "AuraComponentService.prototype.createInternalConfig.!ret": {
      "attributes": {
        "!span": "7749[217:8]-7761[217:20]",
        "values": "AuraComponentService.prototype.createInternalConfig.!ret.attributes"
      },
      "!span": "7576[213:11]-7889[221:5]"
    },
    "AuraComponentService.prototype.createComponentFromConfig.!ret": "+Aura.Utils.Util.prototype.globalEval.!ret",
    "AuraComponentService.prototype.createComponents.!0": "[?]",
    "AuraComponentService.prototype.createComponentInstance.!0": {},
    "AuraComponentService.prototype.requestComponent.!1": {
      "attributes": {
        "!span": "6734[189:8]-6746[189:20]",
        "values": "?"
      },
      "skipCreationPath": {
        "!type": "bool",
        "!span": "6916[192:8]-6934[192:26]"
      },
      "!span": "6664[187:17]-6946[193:5]",
      "localId": "?",
      "flavor": "?"
    },
    "AuraComponentService.prototype.getComponentConfigs.!ret": {
      "configuration": {
        "attributes": {
          "!span": "29818[761:22]-29830[761:34]"
        },
        "!span": "30954[794:8]-30969[794:23]",
        "componentDef": "AuraComponentService.prototype.getComponentConfigs.!ret.configuration"
      },
      "!span": "30944[793:11]-31054[797:5]",
      "descriptor": "AuraComponentService.prototype.getComponentConfigs.!ret.configuration"
    },
    "AuraComponentService.prototype.getUnusedDefinitions.!ret": "[?]",
    "AuraComponentService.prototype.addLibraryInclude.!1": "[?]",
    "AuraComponentService.prototype.getLibraryInclude.!ret": "[?]",
    "AuraComponentService.prototype.destroy.!0": "[AuraComponentService.prototype.destroy.!0]",
    "AuraComponentService.prototype.getRegisteredComponentDescriptors.!ret": "[+ComponentDef]",
    "AuraComponentService.prototype.clearDefsFromStorage.!0": {
      "evicted": {
        "!type": "string",
        "!span": "18014[433:23]-18023[433:32]"
      },
      "actionsError": {
        "!type": "bool",
        "!span": "18779[449:39]-18793[449:53]"
      },
      "componentDefStorageError": {
        "!type": "bool",
        "!span": "19272[461:35]-19298[461:61]"
      }
    },
    "AuraComponentService.prototype.findDependencies.!2": "[?]",
    "AuraComponentService.prototype.findDependencies.!ret": "[?]",
    "AuraComponentService.prototype.sortDependencyGraph.!ret": "[?]",
    "AuraComponentService.prototype.getUpstreamDependencies.!2": {
      "<i>": {
        "!type": "bool",
        "!span": "59507[1579:13]-59514[1579:20]"
      },
      "!span": "59171[1569:27]-59173[1569:29]"
    },
    "AuraComponentService.prototype.getUpstreamDependencies.!ret": {
      "<i>": {
        "!type": "bool",
        "!span": "59507[1579:13]-59514[1579:20]"
      },
      "!span": "59171[1569:27]-59173[1569:29]"
    },
    "AuraComponentService.prototype.splitComponentsAndActions.!2": "[?]",
    "AuraComponentService.prototype.splitComponentsAndActions.!3": "[bool]",
    "AuraComponentService.prototype.splitComponentsAndActions.!4": "[bool]",
    "AuraComponentService.prototype.evictDefsFromStorage.!0": "[?]",
    "AuraDevToolService.!ret": {
      "accessbilityAide": {
        "getDictFromTags": {},
        "findNextHeader": {},
        "nodeListToObjectArray": {},
        "findTopLevelErrors": "AuraInstance.devToolService.accessbilityAide.findTopLevelErrors",
        "inputDefaultErrorAide": "AuraInstance.devToolService.accessbilityAide.inputDefaultErrorAide",
        "findMatchingId": "AuraInstance.devToolService.accessbilityAide.findMatchingId",
        "doesContain": "AuraInstance.devToolService.accessbilityAide.doesContain",
        "doesNotContain": "AuraInstance.devToolService.accessbilityAide.doesNotContain",
        "checkParentMatchesTag": "AuraInstance.devToolService.accessbilityAide.checkParentMatchesTag",
        "findAllImgTags": "AuraInstance.devToolService.accessbilityAide.findAllImgTags",
        "getPropertyFromDescendantTag": "AuraInstance.devToolService.accessbilityAide.getPropertyFromDescendantTag",
        "matchLabelToInput": "AuraInstance.devToolService.accessbilityAide.matchLabelToInput",
        "inputLabelAide": "AuraInstance.devToolService.accessbilityAide.inputLabelAide",
        "checkForAttrib": "AuraInstance.devToolService.accessbilityAide.checkForAttrib",
        "attribStringVal": "AuraInstance.devToolService.accessbilityAide.attribStringVal",
        "getStackTrace": "AuraInstance.devToolService.accessbilityAide.getStackTrace",
        "formatOutput": "AuraInstance.devToolService.accessbilityAide.formatOutput",
        "checkHeadHasCorrectTitle": "AuraInstance.devToolService.accessbilityAide.checkHeadHasCorrectTitle",
        "anchrDoesNotHaveImgWithAlt": "AuraInstance.devToolService.accessbilityAide.anchrDoesNotHaveImgWithAlt",
        "checkAnchorHasInnerText": "AuraInstance.devToolService.accessbilityAide.checkAnchorHasInnerText",
        "radioButtonAide": "AuraInstance.devToolService.accessbilityAide.radioButtonAide",
        "buttonLabelAide": "AuraInstance.devToolService.accessbilityAide.buttonLabelAide",
        "checkTables": "AuraInstance.devToolService.accessbilityAide.checkTables"
      },
      "verifyAccessibility": {
        "checkImagesHaveAlts": {
          "tag": {
            "!type": "string",
            "!span": "47165[1082:14]-47170[1082:19]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkImagesHaveAlts.func"
        },
        "checkInputsHaveLabel": {
          "tag": {
            "!type": "string",
            "!span": "47810[1096:16]-47815[1096:21]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkInputsHaveLabel.func"
        },
        "checkButtonHaveLabel": {
          "tag": {
            "!type": "string",
            "!span": "49410[1121:16]-49415[1121:21]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkButtonHaveLabel.func"
        },
        "checkAnchorHasText": {
          "tag": {
            "!type": "string",
            "!span": "50176[1136:13]-50181[1136:18]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkAnchorHasText.func"
        },
        "checkIframeHasTitle": {
          "tag": {
            "!type": "string",
            "!span": "50936[1150:15]-50941[1150:20]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkIframeHasTitle.func"
        },
        "checkCorrectHeaderOrder": {
          "tag": {
            "!type": "string",
            "!span": "52701[1183:13]-52706[1183:18]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkCorrectHeaderOrder.func"
        },
        "checkTableCellsHaveScope": {
          "tag": {
            "!type": "string",
            "!span": "53621[1201:16]-53626[1201:21]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkTableCellsHaveScope.func"
        },
        "checkFieldsetsAreCorrect": {
          "tag": {
            "!type": "string",
            "!span": "54467[1215:16]-54472[1215:21]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkFieldsetsAreCorrect.func"
        },
        "checkRadioGrouping": {
          "tag": {
            "!type": "string",
            "!span": "55882[1246:16]-55887[1246:21]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkRadioGrouping.func"
        },
        "checkNestedHeader": {
          "tag": {
            "!type": "string",
            "!span": "56667[1261:16]-56672[1261:21]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkNestedHeader.func"
        },
        "checkTopLevelPanels": {
          "tag": {
            "!type": "string",
            "!span": "58334[1287:16]-58339[1287:21]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkTopLevelPanels.func"
        },
        "checkInputdefaultErrorLinkage": {
          "tag": {
            "!type": "string",
            "!span": "60339[1316:16]-60344[1316:21]"
          },
          "func": "AuraInstance.devToolService.verifyAccessibility.checkInputdefaultErrorLinkage.func"
        }
      },
      "helpText": {
        "<i>": {
          "title": {
            "!type": "string",
            "!span": "64865[1409:12]-64870[1409:17]"
          },
          "code": {
            "!type": "string",
            "!span": "64930[1410:12]-64934[1410:16]"
          },
          "description": {
            "!type": "string",
            "!span": "65061[1411:12]-65072[1411:23]"
          }
        }
      },
      "defaultFields": {
        "!type": "string",
        "!span": "68753[1535:6]-68766[1535:19]"
      },
      "views": {
        "component": {},
        "componentDef": {},
        "controllerDef": {},
        "modelDef": {},
        "functionCallValue": {},
        "PropertyReferenceValue": {},
        "passthroughValue": "AuraInstance.devToolService.views.passthroughValue",
        "value": "AuraInstance.devToolService.views.value",
        "rerenderings": "AuraInstance.devToolService.views.rerenderings",
        "renderings": "AuraInstance.devToolService.views.renderings",
        "event": "AuraInstance.devToolService.views.event"
      },
      "applyGroupBy": {},
      "filterFields": {},
      "filters": {
        "noop": "AuraInstance.devToolService.defaultFilter"
      },
      "defaultView": "AuraInstance.devToolService.defaultView",
      "defaultFilter": "AuraInstance.devToolService.defaultFilter",
      "select": "AuraInstance.devToolService.select",
      "processField": "AuraInstance.devToolService.processField",
      "initCap": "AuraInstance.devToolService.initCap",
      "applyFilter": {},
      "newStatement": "AuraInstance.getQueryStatement",
      "output": "AuraInstance.devToolService.output",
      "checkAccessibility": "AuraInstance.devToolService.checkAccessibility",
      "help": "AuraInstance.devToolService.help"
    },
    "AuraDevToolService.!ret.accessbilityAide.getDictFromTags.!ret": {
      "<i>": {
        "!type": "bool",
        "!span": "19904[503:28]-19909[503:33]"
      }
    },
    "AuraDevToolService.!ret.accessbilityAide.findNextHeader.!2": {
      "h6": {
        "!type": "string",
        "!span": "57936[1276:93]-57940[1276:97]"
      }
    },
    "AuraEventService.prototype.getNewEvent.!2": {
      "!span": "7482[227:34]-7484[227:36]"
    },
    "AuraEventService.prototype.addHandler.!0": {
      "globalId": {
        "!type": "string",
        "!span": "75297[2308:26]-75307[2308:36]"
      },
      "event": {
        "!type": "string",
        "!span": "75434[2310:26]-75441[2310:33]"
      },
      "!span": "75267[2307:32]-75269[2307:34]",
      "handler": "AuraEventService.eventDispatcher.<i>.<i>.<i>"
    },
    "AuraEventService.prototype.removeHandler.!0": {
      "globalId": {
        "!type": "string",
        "!span": "23654[737:34]-23664[737:44]"
      },
      "!span": "23616[736:40]-23618[736:42]"
    },
    "AuraEventService.prototype.getRegisteredEvents.!ret": "[+EventDef]",
    "AuraExpressionService.prototype.createPassthroughValue.!ret": "+PassthroughValue",
    "AuraHistoryService.prototype.get.!ret": {
      "token": {
        "!type": "string",
        "!span": "12222[347:16]-12229[347:23]"
      },
      "querystring": {
        "!type": "string",
        "!span": "12242[347:36]-12255[347:49]"
      },
      "!span": "12221[347:15]-12261[347:55]",
      "!doc": "Its possible that more querystring parameters where specified in the hash\nthen are defined on the event. In this case do specify them as parameters\nof the event."
    },
    "AuraHistoryService.prototype.parseQueryString.!ret": {
      "<i>": {
        "!type": "string",
        "!span": "12790[366:16]-12794[366:20]"
      },
      "token": {
        "!type": "string",
        "!span": "12101[343:20]-12108[343:27]"
      },
      "querystring": {
        "!type": "string",
        "!span": "12139[344:20]-12152[344:33]"
      },
      "!span": "12560[358:14]-12562[358:16]"
    },
    "AuraLocalizationService.prototype.UTCToWallTime.!2": {
      "!type": "fn(date: +Date)",
      "!span": "19461[590:36]-19574[592:5]"
    },
    "AuraLocalizationService.prototype.getTimeZoneInfo.!1": {
      "!type": "fn()",
      "!span": "34830[1032:43]-34923[1034:13]"
    },
    "AuraRenderingService.prototype.render.!ret": "[+Node]",
    "AuraRenderingService.prototype.rerender.!ret": "[?]",
    "AuraRenderingService.prototype.storeFacetInfo.!0": {
      "_facetInfo": {
        "!type": "[AuraRenderingService.prototype.storeFacetInfo.!0._facetInfo|?]",
        "!span": "10545[302:14]-10555[302:24]"
      },
      "_marker": "+Node"
    },
    "AuraRenderingService.prototype.getUpdatedFacetInfo.!1": {
      "!type": "[?]",
      "!doc": "#end"
    },
    "AuraRenderingService.prototype.getUpdatedFacetInfo.!ret": {
      "components": {
        "!type": "[?]",
        "!span": "11303[324:8]-11313[324:18]"
      },
      "facetInfo": {
        "!type": "[[?]]",
        "!span": "11326[325:8]-11335[325:17]"
      },
      "useFragment": {
        "!type": "bool",
        "!span": "11348[326:8]-11359[326:19]"
      },
      "fullUnrender": {
        "!type": "bool",
        "!span": "11375[327:8]-11387[327:20]"
      },
      "!span": "11293[323:21]-11399[328:5]"
    },
    "AuraRenderingService.prototype.getUpdatedFacetInfo.!ret.components.<i>": {
      "action": {
        "!type": "string",
        "!span": "12934[362:49]-12940[362:55]"
      },
      "oldIndex": {
        "!type": "number",
        "!span": "12989[362:104]-12997[362:112]"
      },
      "newIndex": {
        "!type": "number",
        "!span": "13002[362:117]-13010[362:125]"
      },
      "!span": "12933[362:48]-13015[362:130]"
    },
    "AuraRenderingService.prototype.renderFacet.!ret": {
      "<i>": "+Node"
    },
    "AuraRenderingService.prototype.rerenderFacet.!ret": "[?]",
    "AuraRenderingService.prototype.statsIndex.afterRender.<i>": {
      "startTime": {
        "!type": "number",
        "!span": "7621[216:8]-7632[216:19]"
      },
      "endTime": {
        "!type": "number",
        "!span": "7654[217:8]-7663[217:17]"
      },
      "!span": "7577[214:40]-7694[218:5]"
    },
    "AuraRenderingService.prototype.statsIndex.render.<i>": {
      "component": {
        "!span": "3136[84:8]-3147[84:19]"
      },
      "startTime": {
        "!type": "number",
        "!span": "3170[85:8]-3181[85:19]"
      },
      "endTime": {
        "!type": "number",
        "!span": "3203[86:8]-3212[86:17]"
      },
      "!span": "3126[83:35]-3243[87:5]"
    },
    "AuraRenderingService.prototype.statsIndex.rerender.<i>": {
      "startTime": {
        "!type": "number",
        "!span": "5769[160:8]-5780[160:19]"
      },
      "endTime": {
        "!type": "number",
        "!span": "5802[161:8]-5811[161:17]"
      },
      "!span": "5725[158:37]-5842[162:5]"
    },
    "AuraRenderingService.prototype.statsIndex.rerenderDirty.<i>": {
      "components": {
        "<i>": {
          "why": {
            "<i>": {
              "!type": "bool",
              "!span": "20185[544:17]-20195[544:27]"
            }
          },
          "!span": "23495[634:50]-23497[634:52]"
        },
        "!span": "21392[593:12]-21404[593:24]"
      },
      "renderingTime": {
        "!type": "number",
        "!span": "24501[662:24]-24516[662:39]"
      },
      "!span": "21341[591:26]-21419[594:9]"
    },
    "AuraRenderingService.prototype.statsIndex.unrender.<i>": {
      "startTime": {
        "!type": "number",
        "!span": "9691[279:8]-9702[279:19]"
      },
      "endTime": {
        "!type": "number",
        "!span": "9724[280:8]-9733[280:17]"
      },
      "!span": "9647[277:37]-9764[281:5]"
    },
    "AuraRenderingService.prototype.getArray.!ret": "[?]",
    "AuraRenderingService.prototype.evalStrings.!0": "[?]",
    "AuraRenderingService.prototype.evalStrings.!ret": {
      "!type": "[?]",
      "!doc": "If someone passed a config in, construct it."
    },
    "AuraStyleService.prototype.applyAllTokens.!0": "[string]",
    "Component.prototype.findInstancesOf.!1": "[+Component]",
    "Component.prototype.addHandler.!1": {
      "get": {
        "!type": "fn(functionName: ?) -> Component.prototype.addHandler.!1.get.!ret",
        "!span": "86257[2606:12]-86260[2606:15]"
      },
      "!span": "86243[2605:37]-86604[2616:9]"
    },
    "Component.prototype.addHandler.!1.get.!ret": {
      "run": {
        "!type": "fn(event: ?)",
        "!span": "86333[2608:20]-86336[2608:23]"
      },
      "runDeprecated": {
        "!type": "fn(event: ?)",
        "!span": "86453[2611:20]-86466[2611:33]"
      },
      "!span": "86311[2607:23]-86579[2614:17]"
    },
    "Component.prototype.addValueHandler.!0": {
      "!span": "75892[2322:32]-75894[2322:34]",
      "action": "PropertyReferenceValue.lastResult",
      "value": "PropertyReferenceValue.lastResult",
      "method": {
        "valueProvider": "+AuraInstance"
      }
    },
    "Component.prototype.getElements.!ret": {
      "!type": "[?]",
      "!doc": "TODO: iterate over components attributes and recursively unrender facets"
    },
    "Component.prototype.toJSON.!ret": {
      "globalId": {
        "!type": "string",
        "!span": "44781[1501:8]-44791[1501:18]"
      },
      "isValid": {
        "!type": "bool",
        "!span": "44816[1502:8]-44825[1502:17]"
      },
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "className": {
        "!type": "string",
        "!span": "21228[659:24]-21239[659:35]"
      },
      "!span": "44771[1500:8]-44847[1503:5]",
      "request": "+XMLHttpRequest"
    },
    "Component.prototype.getHandledEvents.!ret": {
      "<i>": {
        "!type": "bool",
        "!span": "45351[1518:20]-45369[1518:38]"
      },
      "!span": "45062[1512:14]-45064[1512:16]"
    },
    "Component.prototype.getFacets.!ret": "[Component.valueProviders.<i>]",
    "Component.prototype.createComponentStack.!0": "[Component.prototype.createComponentStack.!0.<i>]",
    "Component.prototype.createComponentStack.!0.<i>": {
      "!span": "63678[2014:56]-63717[2014:95]",
      "descriptor": "PropertyReferenceValue.lastResult"
    },
    "Component.prototype.createComponentStack.!1": {
      "!span": "4139[113:27]-4155[113:43]",
      "!doc": "join attributes from partial config and config, preferring partial when overlapping",
      "facetValueProvider": "+Component"
    },
    "Component.prototype.createComponentStack.!ret": {
      "<i>": {
        "!type": "[[Component.prototype.createComponentStack.!ret.<i>.<i>]]",
        "!span": "56637[1860:19]-56646[1860:28]"
      },
      "!span": "54603[1813:21]-54605[1813:23]"
    },
    "Component.prototype.createComponentStack.!ret.<i>.<i>": "[Component.prototype.createComponentStack.!ret.<i>.<i>]",
    "Component.prototype.getMethodHandler.!0": "+Aura.Method.MethodDef",
    "Component.prototype.provide.!ret": {
      "!span": "80395[2445:25]-80449[2447:9]",
      "componentDef": "?"
    },
    "ComponentClassRegistry.prototype.buildComponentClass.!0": {},
    "ComponentClassRegistry.prototype.buildConstructor.!ret": {
      "prototype": {
        "!proto": "Component.prototype",
        "!span": "6939[173:25]-6948[173:34]",
        "constructor": "ComponentClassRegistry.prototype.buildConstructor.!ret"
      },
      "!type": "fn()",
      "!span": "6415[157:31]-6475[159:5]"
    },
    "ComponentDef.prototype.getDynamicallyFlavorable.!ret": "[+ComponentDef]",
    "ComponentDefStorage.prototype.storeDefs.!0": "[?]",
    "ComponentDefStorage.prototype.storeDefs.!1": "[?]",
    "ComponentDefStorage.prototype.removeDefs.!0": "[string]",
    "ComponentDefStorage.prototype.clear.!0": {
      "evicted": {
        "!type": "string",
        "!span": "18014[433:23]-18023[433:32]"
      },
      "actionsError": {
        "!type": "bool",
        "!span": "18779[449:39]-18793[449:53]"
      },
      "componentDefStorageError": {
        "!type": "bool",
        "!span": "19272[461:35]-19298[461:61]"
      }
    },
    "InvalidComponent.prototype.raiseInvalidComponentError.!1": "[?]",
    "Action.prototype.popCreationPath.!ret": {
      "relPath": {
        "!type": "string",
        "!span": "7256[239:22]-7263[239:29]"
      },
      "absPath": {
        "!type": "string",
        "!span": "7276[239:42]-7283[239:49]"
      },
      "idx": {
        "!type": "number",
        "!span": "7293[239:59]-7296[239:62]"
      },
      "startIdx": {
        "!type": "number",
        "!span": "7309[239:75]-7317[239:83]"
      }
    },
    "Action.prototype.getStored.!ret": {
      "state": {
        "!type": "string",
        "!span": "25543[811:12]-25550[811:19]"
      },
      "storage": {
        "created": {
          "!type": "number",
          "!span": "25606[813:16]-25615[813:25]"
        },
        "!span": "25576[812:12]-25585[812:21]"
      },
      "!span": "25429[808:15]-25662[815:9]"
    },
    "Action.prototype.getStorageErrorHandler.!ret": {
      "ignoreExisting": {
        "!type": "bool",
        "!span": "36643[1222:8]-36659[1222:24]"
      },
      "errorHandler": "Action.storableConfig"
    },
    "Action.prototype.prepareToSend.!ret": {
      "id": {
        "!type": "string",
        "!span": "34527[1153:8]-34531[1153:12]"
      },
      "descriptor": {
        "!type": "string",
        "!span": "34556[1154:8]-34568[1154:20]"
      },
      "callingDescriptor": {
        "!type": "string",
        "!span": "34626[1155:8]-34645[1155:27]"
      },
      "!span": "34517[1152:11]-34852[1158:5]",
      "params": "Action.params",
      "version": "Component.valueProviders.<i>"
    },
    "Action.prototype.copyToRefresh.!ret": {
      "abortable": {
        "!type": "bool",
        "!span": "36797[1227:18]-36806[1227:27]"
      },
      "!doc": "FIXME: need to expose for plugins",
      "callbacks": {
        "SUCCESS": {
          "fn": "XMLHttpRequest.onreadystatechange",
          "s": "+Action"
        },
        "ERROR": {
          "fn": "XMLHttpRequest.onreadystatechange",
          "s": "+Action"
        },
        "INCOMPLETE": {
          "fn": "XMLHttpRequest.onreadystatechange",
          "s": "+Action"
        },
        "<i>": {
          "fn": "XMLHttpRequest.onreadystatechange",
          "s": "+Action"
        }
      }
    },
    "Action.prototype.getRefreshAction.!ret": {
      "callbacks": "Action.callbacks"
    },
    "AuraLocalizationContext.!0": "+AuraLocalizationContext",
    "LibraryIncludeRegistry.prototype.cloneDependencyQueue.!ret": "[?]",
    "LockerService.!ret": {
      "util": {
        "verifyAccess": {},
        "getKeyForNamespace": "AuraInstance.lockerService.util.getKeyForNamespace",
        "isKeyed": "AuraInstance.lockerService.util.isKeyed",
        "hasAccess": "AuraInstance.lockerService.util.hasAccess",
        "applyKey": "AuraInstance.lockerService.util.applyKey"
      },
      "createForDef": {},
      "getEnvForSecureObject": {},
      "isEnabled": "AuraInstance.lockerService.isEnabled",
      "getEnv": "AuraInstance.lockerService.getEnv",
      "create": "AuraInstance.lockerService.create",
      "destroy": "AuraInstance.lockerService.destroy",
      "destroyAll": "AuraInstance.lockerService.destroyAll",
      "wrapComponent": "AuraInstance.lockerService.wrapComponent",
      "wrapComponentEvent": "AuraInstance.lockerService.wrapComponentEvent",
      "unwrap": "AuraInstance.lockerService.unwrap",
      "trust": "AuraInstance.lockerService.trust",
      "markOpaque": "AuraInstance.lockerService.markOpaque",
      "isOpaque": "AuraInstance.lockerService.isOpaque",
      "showLockedNodes": "AuraInstance.lockerService.showLockedNodes"
    },
    "LockerService.!ret.util.verifyAccess.!2": {
      "verifyNotOpaque": {
        "!type": "bool",
        "!span": "10042[339:6]-10057[339:21]"
      }
    },
    "SecureAura.!1": {
      "!span": "8128[308:45]-8163[310:6]",
      "!doc": "Get the locker key for this namespace"
    },
    "SecureComponent.!ret": {
      "superRender": {
        "!type": "fn()",
        "!span": "2227[64:31]-4492[92:5]"
      },
      "!doc": "special methods that require some extra work",
      "superAfterRender": "SecureComponent.!ret.superRender",
      "superRerender": "SecureComponent.!ret.superRender",
      "superUnrender": "SecureComponent.!ret.superRender",
      "isValid": "SecureComponent.!ret.superRender",
      "isInstanceOf": "SecureComponent.!ret.superRender",
      "addHandler": "SecureComponent.!ret.superRender",
      "addValueHandler": "SecureComponent.!ret.superRender",
      "addValueProvider": "SecureComponent.!ret.superRender",
      "destroy": "SecureComponent.!ret.superRender",
      "isRendered": "SecureComponent.!ret.superRender",
      "getGlobalId": "SecureComponent.!ret.superRender",
      "getLocalId": "SecureComponent.!ret.superRender",
      "getSuper": "SecureComponent.!ret.superRender",
      "getReference": "SecureComponent.!ret.superRender",
      "getVersion": "SecureComponent.!ret.superRender",
      "clearReference": "SecureComponent.!ret.superRender",
      "autoDestroy": "SecureComponent.!ret.superRender",
      "isConcrete": "SecureComponent.!ret.superRender",
      "getConcreteComponent": "SecureComponent.!ret.superRender",
      "find": "SecureComponent.!ret.superRender",
      "set": "SecureComponent.!ret.superRender",
      "getElement": "SecureComponent.!ret.superRender",
      "getElements": "SecureComponent.!ret.superRender"
    },
    "SecureDocument.!ret": {
      "addEventListener": {
        "!type": "fn(event: ?, callback: ?, useCapture: ?)",
        "!span": "9079[311:29]-9614[324:2]"
      },
      "removeEventListener": {
        "!type": "fn(type: ?, listener: ?, options: ?)",
        "!span": "9079[311:29]-9614[324:2]"
      },
      "createEvent": "SecureComponent.!ret.superRender",
      "getElementById": "SecureComponent.!ret.superRender",
      "getElementsByClassName": "SecureComponent.!ret.superRender",
      "getElementsByName": "SecureComponent.!ret.superRender",
      "getElementsByTagName": "SecureComponent.!ret.superRender",
      "getElementsByTagNameNS": "SecureComponent.!ret.superRender",
      "querySelectorAll": "SecureComponent.!ret.superRender"
    },
    "SecureDOMEvent.filterTouchesDescriptor.!ret": {
      "get": {
        "!type": "fn() -> goog.exportSymbol.!1",
        "!span": "2912[77:8]-2915[77:11]"
      },
      "!span": "2902[76:11]-3976[99:5]"
    },
    "SecureDOMEvent.!ret": {
      "item": {
        "!type": "fn(index: ?) -> goog.exportSymbol.!1",
        "!span": "3878[127:37]-3884[127:43]"
      }
    },
    "SecureElement.createAddEventListenerDescriptor.!0": {
      "abort": "SecureComponent.!ret.superRender",
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "open": "SecureComponent.!ret.superRender",
      "send": "SecureComponent.!ret.superRender",
      "getAllResponseHeaders": "SecureComponent.!ret.superRender",
      "getResponseHeader": "SecureComponent.!ret.superRender",
      "setRequestHeader": "SecureComponent.!ret.superRender"
    },
    "SecureElement.createAddEventListenerDescriptor.!ret": {
      "!span": "9702[328:8]-10369[354:2]",
      "value": "SecureDocument.!ret.addEventListener"
    },
    "SecureElement.createAddEventListener.!ret": {
      "!type": "fn(event: ?, callback: ?, useCapture: ?)",
      "!span": "10446[358:8]-10753[370:2]"
    },
    "SecureElement.!ret": {
      "cloneNode": {
        "!type": "fn(deep: bool) -> SecureIFrameElement.!ret",
        "!span": "3322[122:477]-4600[122:1755]"
      },
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "removeEventListener": "SecureDocument.!ret.removeEventListener",
      "item": "SecureDOMEvent.!ret.item"
    },
    "SecureIFrameElement.!ret": {
      "contentWindow": {
        "!span": "1379[43:31]-1771[53:5]",
        "postMessage": "SecureComponent.!ret.superRender"
      },
      "blur": "SecureComponent.!ret.superRender",
      "focus": "SecureComponent.!ret.superRender",
      "cloneNode": "SecureElement.!ret.cloneNode",
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "removeEventListener": "SecureDocument.!ret.removeEventListener",
      "item": "SecureDOMEvent.!ret.item"
    },
    "SecureObject.filterEverything.!2": {
      "beforeCallback": {
        "!type": "fn(method: ?, url: ?)",
        "!span": "2078[68:10]-2092[68:24]"
      },
      "!span": "2065[67:59]-2578[78:7]"
    },
    "SecureObject.unfilterEverything.!1": "[?]",
    "SecureObject.createFilteredMethod.!ret": {
      "enumerable": {
        "!type": "bool",
        "!span": "8264[284:2]-8274[284:12]"
      },
      "!span": "8260[283:8]-8790[301:2]",
      "value": "SecureComponent.!ret.superRender"
    },
    "SecureObject.createFilteredProperty.!3": {
      "filterOpaque": {
        "!type": "bool",
        "!span": "2377[81:3]-2389[81:15]"
      },
      "ignoreNonexisting": {
        "!type": "bool",
        "!span": "10003[125:6251]-10020[125:6268]"
      },
      "!span": "2372[80:52]-2400[82:3]"
    },
    "SecureObject.createFilteredProperty.!ret": {
      "enumerable": {
        "!type": "bool",
        "!span": "9214[317:2]-9224[317:12]"
      },
      "get": {
        "!type": "fn() -> fn(e: ?)|goog.exportSymbol.!1",
        "!span": "9248[320:12]-9251[320:15]"
      },
      "set": {
        "!type": "fn(value: ?)",
        "!span": "9582[332:13]-9585[332:16]"
      },
      "!span": "9210[316:18]-9233[318:2]"
    },
    "SecureObject.addIfSupported.!4": {
      "filterOpaque": {
        "!type": "bool",
        "!span": "2556[87:3]-2568[87:15]"
      },
      "ignoreNonexisting": {
        "!type": "bool",
        "!span": "10003[125:6251]-10020[125:6268]"
      },
      "!span": "2551[86:50]-2579[88:3]"
    },
    "SecureWindow.!2": {
      "!type": "[string]",
      "!doc": "This whilelist represents reflective ECMAScript APIs or reflective DOM APIs\nwhich, by definition, do not provide authority or access to globals."
    },
    "SecureWindow.!ret": {
      "!span": "5476[201:4]-5485[201:13]",
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "removeEventListener": "SecureDocument.!ret.removeEventListener"
    },
    "SecureXMLHttpRequest.!ret": {
      "!type": "fn() -> SecureElement.createAddEventListenerDescriptor.!0",
      "!span": "1013[34:8]-3037[94:2]"
    },
    "Logger.prototype.stringVersion.!2": "[?]",
    "AttributeDefSet.prototype.getNames.!ret": "[?]",
    "ComponentServiceMetricsPlugin.prototype.postProcess.!ret": "[ComponentServiceMetricsPlugin.prototype.postProcess.!ret.<i>]",
    "ComponentServiceMetricsPlugin.prototype.postProcess.!ret.<i>": {
      "duration": {
        "!type": "number",
        "!span": "3296[88:21]-3306[88:31]"
      }
    },
    "DomHandlersPlugin.prototype.dispatchActionHook.!1": {
      "appCache": {
        "!type": "number",
        "!span": "27238[844:16]-27248[844:26]"
      },
      "redirectTime": {
        "!type": "number",
        "!span": "27312[845:16]-27326[845:30]"
      }
    },
    "QueuedActionsMetricsPlugin.prototype.postProcess.!ret": "[QueuedActionsMetricsPlugin.prototype.postProcess.!ret.<i>]",
    "QueuedActionsMetricsPlugin.prototype.postProcess.!ret.<i>": {
      "enqueueWait": {
        "!type": "number",
        "!span": "5270[152:21]-5283[152:34]"
      },
      "duration": {
        "!type": "number",
        "!span": "5491[156:21]-5501[156:31]"
      }
    },
    "TransportMetricsPlugin.prototype.postProcess.!ret": "[TransportMetricsPlugin.prototype.postProcess.!ret.<i>]",
    "TransportMetricsPlugin.prototype.postProcess.!ret.<i>": {
      "duration": {
        "!type": "number",
        "!span": "4564[123:17]-4574[123:27]"
      },
      "phase": {
        "!type": "string",
        "!span": "4659[124:17]-4666[124:24]"
      }
    },
    "ModelDef.prototype.newInstance.!ret": "+Model",
    "Json.prototype.resolveRefsObject.!0": {
      "<i>": {
        "!span": "5243[146:27]-5251[146:35]",
        "<i>": "Json.prototype.resolveRefsObject.!0.<i>"
      }
    },
    "Json.prototype.resolveRefsArray.!0": "[Json.prototype._resolveRefs.!1.<i>]",
    "Json.prototype._resolveRefs.!1": {
      "<i>": {
        "!span": "6283[164:34]-6288[164:39]",
        "<i>": "Json.prototype.resolveRefsObject.!0.<i>"
      },
      "!span": "3969[115:27]-3971[115:29]"
    },
    "Json.prototype._resolveRefs.!4": "[Json.prototype._resolveRefs.!1.<i>]",
    "ContextValueProvider.prototype.getValues.!ret": {
      "!span": "955[31:17]-957[31:19]"
    },
    "ContextValueProvider.prototype.serializeForServer.!ret": {
      "!span": "1435[51:23]-1437[51:25]"
    },
    "GlobalValueProviders.prototype.loadFromStorage.!0": {
      "!type": "fn()",
      "!span": "2466[57:25]-2578[62:5]"
    },
    "LabelQueue.prototype.getComponents.!ret": "[+Component]",
    "LabelQueue.prototype.getReturnValues.!ret": "[string]",
    "LabelQueue.prototype.getCallbacks.!ret": "[+Function]",
    "CryptoAdapter.prototype.enqueue.!0": {
      "!type": "fn(resolve: +Function, reject: +Function)",
      "!span": "18631[544:24]-18728[546:5]"
    },
    "CryptoAdapter.!0": {
      "name": {
        "!type": "string",
        "!span": "6706[163:8]-6712[163:14]"
      },
      "maxSize": {
        "!type": "number",
        "!span": "6728[164:8]-6737[164:17]"
      },
      "debugLoggingEnabled": {
        "!type": "bool",
        "!span": "6756[165:8]-6777[165:29]"
      },
      "expiration": {
        "!type": "number",
        "!span": "6808[166:8]-6820[166:20]"
      },
      "!span": "6696[162:24]-6838[167:5]"
    },
    "IndexedDBAdapter.prototype.enqueue.!0": {
      "!type": "fn(resolve: +Function, reject: +Function)",
      "!span": "7008[205:18]-7113[207:5]"
    },
    "MemoryAdapter.prototype.removeItemInternal.!ret": "+MemoryAdapter.Entry",
    "AuraStorage.!0": {
      "name": {
        "!type": "string",
        "!span": "4312[89:8]-4318[89:14]"
      },
      "maxSize": {
        "!type": "number",
        "!span": "4362[91:8]-4371[91:17]"
      },
      "defaultExpiration": {
        "!type": "number",
        "!span": "4390[92:8]-4409[92:27]"
      },
      "defaultAutoRefreshInterval": {
        "!type": "number",
        "!span": "4438[93:8]-4466[93:36]"
      },
      "debugLoggingEnabled": {
        "!type": "bool",
        "!span": "4504[94:8]-4525[94:29]"
      },
      "clearStorageOnInit": {
        "!type": "bool",
        "!span": "4556[95:8]-4576[95:28]"
      },
      "version": {
        "!type": "string",
        "!span": "4606[96:8]-4615[96:17]"
      },
      "isolationKey": {
        "!type": "string",
        "!span": "4634[97:8]-4648[97:22]"
      },
      "!span": "4302[88:17]-4673[98:5]"
    },
    "TypeDef.!0": "+TypeDef",
    "goog.exportProperty.!0": {},
    "goog.exportSymbol.!1": {
      "!span": "3071[75:24]-3073[75:26]"
    },
    "goog.exportSymbol.!2": {
      "<i>": "goog.exportSymbol.!1"
    },
    "PerfShim.getMeasures.!ret": "[?]",
    "FunctionCallValue.prototype.addChangeHandler.!2": "+FunctionCallValue",
    "FunctionCallValue.prototype.getChangeHandler.!ret": {
      "!type": "fn(event: ?)",
      "!span": "2811[95:11]-3159[102:5]"
    },
    "PropertyReferenceValue.prototype.addChangeHandler.!2": {
      "key": {
        "!type": "string",
        "!span": "3199[91:15]-3202[91:18]"
      },
      "!type": "fn(event: ?)",
      "!span": "2678[80:19]-3135[88:13]"
    },
    "Aura.Services.MetricsService.bootstrap.requests.<i>": {
      "redirectTime": {
        "!type": "number",
        "!span": "27973[858:28]-27987[858:42]"
      },
      "dnsTime": {
        "!type": "number",
        "!span": "28065[859:28]-28074[859:37]"
      },
      "!span": "27754[854:31]-28296[862:25]"
    },
    "AuraInstance.lockerService.createForDef.!ret": {
      "!span": "5470[200:12]-5586[203:4]",
      "$envRec": "SecureWindow.!ret"
    },
    "AuraInstance.lockerService.util.verifyAccess.!2": {
      "verifyNotOpaque": {
        "!type": "bool",
        "!span": "10042[339:6]-10057[339:21]"
      },
      "!span": "10034[338:54]-10071[340:6]"
    },
    "AuraInstance.devToolService.views.componentDef.!ret": "[?]",
    "AuraInstance.devToolService.views.controllerDef.!ret": "[+ControllerDef]",
    "AuraInstance.devToolService.views.modelDef.!ret": "[+ModelDef]",
    "AuraInstance.devToolService.views.functionCallValue.!ret": "[valueFactory.valueIndex]",
    "AuraInstance.devToolService.views.passthroughValue.!ret": "[?]",
    "AuraInstance.devToolService.views.PropertyReferenceValue.!ret": "[valueFactory.valueIndex]",
    "AuraInstance.devToolService.views.value.!ret": "[?]",
    "AuraInstance.devToolService.views.renderings.!ret": "[?]",
    "AuraInstance.devToolService.applyGroupBy.!1": "[AuraInstance.devToolService.applyGroupBy.!1.<i>]",
    "AuraInstance.devToolService.applyGroupBy.!1.<i>": {
      "!span": "7274[222:33]-7276[222:35]",
      "<i>": "Component.<i>"
    },
    "AuraInstance.devToolService.applyGroupBy.!2": "[+Component]",
    "AuraInstance.devToolService.applyGroupBy.!ret": {
      "_priv": {
        "!span": "1508[62:13]-1513[62:18]",
        "to": "AuraInstance.devToolService.applyGroupBy.!ret",
        "statement": "AuraInstance.getQueryStatement.!ret"
      },
      "rowCount": "number",
      "groupCount": "number",
      "groups": {
        "<i>": {
          "!type": "[AuraInstance.devToolService.applyGroupBy.!1.<i>]",
          "!span": "5947[187:24]-5950[187:27]"
        },
        "!span": "5657[179:22]-5659[179:24]"
      },
      "rows": "AuraInstance.devToolService.applyGroupBy.!1",
      "added": "AuraInstance.devToolService.applyGroupBy.!ret",
      "existing": "AuraInstance.devToolService.applyGroupBy.!ret",
      "removed": "AuraInstance.devToolService.applyGroupBy.!ret"
    },
    "AuraInstance.devToolService.filterFields.!2": "[+Component]",
    "AuraInstance.devToolService.applyFilter.!ret": {
      "rows": {
        "!type": "[?]",
        "!span": "9811[297:20]-9815[297:24]"
      },
      "rawRows": {
        "!type": "[?]",
        "!span": "9823[297:32]-9830[297:39]"
      },
      "!span": "9810[297:19]-9840[297:49]"
    },
    "AuraInstance.devToolService.accessbilityAide.nodeListToObjectArray.!0": {
      "!type": "[AuraInstance.devToolService.accessbilityAide.nodeListToObjectArray.!0.<i>]",
      "!doc": "Get all panels"
    },
    "AuraInstance.devToolService.accessbilityAide.nodeListToObjectArray.!0.<i>": {
      "!span": "10784[324:27]-10911[327:18]"
    },
    "AuraInstance.devToolService.accessbilityAide.findTopLevelErrors.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.inputDefaultErrorAide.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.getDictFromTags.!ret": {
      "<i>": {
        "!type": "bool",
        "!span": "19904[503:28]-19909[503:33]"
      },
      "!span": "19580[495:27]-19582[495:29]"
    },
    "AuraInstance.devToolService.accessbilityAide.matchLabelToInput.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.inputLabelAide.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.checkForAttrib.!0": "[?]",
    "AuraInstance.devToolService.accessbilityAide.checkForAttrib.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.formatOutput.!1": "[?]",
    "AuraInstance.devToolService.accessbilityAide.checkHeadHasCorrectTitle.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.checkAnchorHasInnerText.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.radioButtonAide.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.buttonLabelAide.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.checkTables.!ret": "[?]",
    "AuraInstance.devToolService.accessbilityAide.findNextHeader.!2": {
      "h6": {
        "!type": "string",
        "!span": "57936[1276:93]-57940[1276:97]"
      },
      "!span": "57935[1276:92]-57944[1276:101]"
    },
    "AuraInstance.devToolService.accessbilityAide.findNextHeader.!ret": "[?]",
    "AuraInstance.devToolService.checkAccessibility.!1": "[string]",
    "AuraInstance.devToolService.helpText.<i>": {
      "title": {
        "!type": "string",
        "!span": "64865[1409:12]-64870[1409:17]"
      },
      "code": {
        "!type": "string",
        "!span": "64930[1410:12]-64934[1410:16]"
      },
      "description": {
        "!type": "string",
        "!span": "65061[1411:12]-65072[1411:23]"
      },
      "!span": "64851[1408:8]-65236[1412:9]"
    },
    "AuraInstance.getQueryStatement.!ret": {
      "criteria": {
        "derivedFields": {
          "!span": "68030[1505:30]-68045[1505:45]",
          "!doc": "derived field"
        },
        "fields": {
          "!type": "string",
          "!span": "68346[1515:26]-68354[1515:34]"
        },
        "!span": "1198[45:13]-1206[45:21]"
      }
    },
    "Action.pathStack.<i>": {
      "relPath": {
        "!type": "string",
        "!span": "7256[239:22]-7263[239:29]"
      },
      "absPath": {
        "!type": "string",
        "!span": "7276[239:42]-7283[239:49]"
      },
      "idx": {
        "!type": "number",
        "!span": "7293[239:59]-7296[239:62]"
      },
      "startIdx": {
        "!type": "number",
        "!span": "7309[239:75]-7317[239:83]"
      },
      "!span": "7254[239:20]-7330[239:96]"
    },
    "AuraClientService.initDefsObservers.<i>": {
      "!type": "fn()",
      "!span": "3368[103:38]-5759[167:5]"
    },
    "AuraClientService.availableXHRs.<i>": "+Aura.Services.AuraClientService$AuraXHR",
    "AuraClientService.enqueueAction.!3": {
      "background": {
        "!type": "bool",
        "!span": "60811[1783:62]-60821[1783:72]"
      },
      "!span": "60809[1783:60]-60829[1783:80]"
    },
    "ModelDef.members.<i>": "+ValueDef",
    "ComponentDef.appHandlerDefs.<i>": {
      "!span": "4210[106:40]-4390[109:21]",
      "eventDef": "?"
    },
    "ComponentDef.cmpHandlerDefs.<i>": {
      "!span": "3792[97:40]-4032[101:21]",
      "eventDef": "?"
    },
    "FlavorsDef.flavors.<i>": "+FlavorDefaultDef",
    "Logger.subscribers.<i>": {
      "level": {
        "!type": "string",
        "!span": "8606[293:12]-8611[293:17]"
      },
      "!span": "8592[292:30]-8654[295:9]",
      "fn": "+Function"
    },
    "AuraEventService.eventDispatcher.<i>": {
      "<i>": {
        "!type": "[fn(event: +Aura.Event.Event)]",
        "!span": "8654[226:17]-8672[226:35]"
      },
      "!span": "8454[220:19]-8456[220:21]"
    },
    "AuraEventService.eventDispatcher.<i>.<i>.<i>": {
      "!type": "fn(event: +Aura.Event.Event)",
      "!span": "74574[2287:11]-74938[2298:5]"
    },
    "Aura.Utils.Override.replace.!0": {
      "!type": "fn()",
      "!span": "3135[83:20]-3342[88:13]"
    },
    "Aura.Utils.Override.chain.<i>": {
      "priority": {
        "!type": "number",
        "!span": "2985[78:8]-2993[78:16]"
      },
      "!span": "2916[74:14]-2918[74:16]",
      "fn": "+Function"
    },
    "ComponentDefStorage.queue.<i>": {
      "execute": {
        "!type": "fn(resolve: ?, reject: ?)",
        "!span": "15508[373:30]-15517[373:39]"
      },
      "!span": "15506[373:28]-15563[373:85]"
    },
    "AttributeSet.prototype.merge.!0": {
      "body": "AttributeSet.!0.body"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.index.!1": {
      "0": "Component.localIndex.<i>",
      "1": "Component.localIndex.<i>"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.findInstancesOf.!1": {
      "<i>": "+Component"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.addValueHandler.!0": {
      "action": "PropertyReferenceValue.lastResult",
      "value": "PropertyReferenceValue.lastResult",
      "method": {
        "valueProvider": "+AuraInstance"
      }
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.get.!ret": {
      "<i>": "cancelAnimationFrame"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.getFacets.!ret": {
      "<i>": "Component.valueProviders.<i>"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.createComponentStack.!0": {
      "<i>": {
        "descriptor": "PropertyReferenceValue.lastResult"
      }
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.createComponentStack.!1": {
      "facetValueProvider": "+Component"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.createComponentStack.!ret": {
      "<i>": {
        "<i>": {
          "<i>": "Component.prototype.createComponentStack.!ret.<i>.<i>"
        }
      }
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.getActionCaller.!ret": {
      "valueProvider": "+AuraInstance"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.getEventDispatcher.!ret": {
      "<i>": {
        "<i>": "Component.eventDispatcher.<i>.<i>"
      },
      "get": "Component.eventDispatcher.get"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.provide.!ret": {
      "componentDef": "?"
    },
    "Aura.Utils.Util.prototype.merge.!0": {
      "<i>": "Aura.Utils.Util.forEach.!0"
    },
    "Aura.Utils.Util.prototype.filter.!0": {
      "<i>": "+Aura.Services.AuraClientService$AuraXHR"
    },
    "Aura.Context.AuraContext.prototype.getAccessVersion.!ret": {
      "<i>": "cancelAnimationFrame"
    },
    "Aura.Value.ValueFactory.getIndex.!ret": {
      "<i>": "valueFactory.valueIndex"
    },
    "Aura.Component.Component.prototype.index.!1": {
      "0": "Component.localIndex.<i>",
      "1": "Component.localIndex.<i>"
    },
    "Aura.Component.Component.prototype.findInstancesOf.!1": {
      "<i>": "+Component"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.addHandler.!1": {
      "get": {}
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.addHandler.!1.get.!ret": {
      "run": "Component.prototype.addHandler.!1.get.!ret.run",
      "runDeprecated": "Component.prototype.addHandler.!1.get.!ret.runDeprecated"
    },
    "Aura.Component.Component.prototype.addValueHandler.!0": {
      "action": "PropertyReferenceValue.lastResult",
      "value": "PropertyReferenceValue.lastResult",
      "method": {
        "valueProvider": "+AuraInstance"
      }
    },
    "Aura.Component.Component.prototype.getFacets.!ret": {
      "<i>": "Component.valueProviders.<i>"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.createActionValueProvider.!ret": {
      "actions": {
        "<i>": "+ActionDef"
      },
      "get": "Component.valueProviders.c.get"
    },
    "Aura.Utils.Util.prototype.globalEval.!1.Component.prototype.createStyleValueProvider.!ret": {
      "get": "Component.valueProviders.style.get"
    },
    "Aura.Component.Component.prototype.createComponentStack.!0": {
      "<i>": {
        "descriptor": "PropertyReferenceValue.lastResult"
      }
    },
    "Aura.Component.Component.prototype.createComponentStack.!1": {
      "facetValueProvider": "+Component"
    },
    "Aura.Component.Component.prototype.createComponentStack.!ret": {
      "<i>": {
        "<i>": {
          "<i>": "Component.prototype.createComponentStack.!ret.<i>.<i>"
        }
      }
    },
    "Aura.Component.Component.prototype.getActionCaller.!ret": {
      "valueProvider": "+AuraInstance"
    },
    "Aura.Component.Component.prototype.getEventDispatcher.!ret": {
      "<i>": {
        "<i>": "Component.eventDispatcher.<i>.<i>"
      },
      "get": "Component.eventDispatcher.get"
    },
    "Aura.Component.Component.prototype.provide.!ret": {
      "componentDef": "?"
    },
    "Aura.Component.ComponentClassRegistry.prototype.buildConstructor.!ret": {
      "prototype": {
        "constructor": "ComponentClassRegistry.prototype.buildConstructor.!ret"
      }
    },
    "Aura.Component.ComponentDef.prototype.getAllStyleDefs.!ret": {
      "<i>": "+StyleDef"
    },
    "Aura.Component.ComponentDef.prototype.getAllFlavoredStyleDefs.!ret": {
      "<i>": "+StyleDef"
    },
    "Aura.Component.ComponentDef.prototype.getDynamicallyFlavorable.!ret": {
      "<i>": "+ComponentDef"
    },
    "Aura.Component.ComponentDefStorage.prototype.restoreAll.!0": {
      "contextGlobals": "AuraInstance.context.contextGlobals",
      "currentAction": "+Action",
      "globalValueProviders": "AuraInstance.context.globalValueProviders"
    },
    "Aura.Provider.LabelQueue.prototype.getComponents.!ret": {
      "<i>": "+Component"
    },
    "Aura.Component.Component.prototype.createActionValueProvider.!ret": {
      "actions": {
        "<i>": "+ActionDef"
      },
      "get": "Component.valueProviders.c.get"
    },
    "Aura.Controller.Action.prototype.getRefreshAction.!ret": {
      "callbacks": "Action.callbacks"
    },
    "Aura.Services.AuraClientService.prototype.shouldSendOutForegroundActions.!0": {
      "<i>": "PropertyReferenceValue.lastResult"
    },
    "Aura.Services.AuraClientService.prototype.sendAsSingle.!0": {
      "<i>": "AuraInstance.context.contextGlobals"
    },
    "Aura.Services.AuraClientService.prototype.getAndClearDupes.!0": {
      "dupes": "AuraClientService.actionStoreMap.<i>.dupes"
    },
    "Aura.Services.AuraComponentContext.prototype.Frame.!0": {
      "_marker": "+Node"
    },
    "Aura.Services.AuraComponentService.prototype.createInternalConfig.!ret": {
      "attributes": {
        "values": "AuraComponentService.prototype.createInternalConfig.!ret.attributes"
      }
    },
    "Aura.Services.AuraComponentService.prototype.getComponentConfigs.!ret": {
      "configuration": {
        "componentDef": "AuraComponentService.prototype.getComponentConfigs.!ret.configuration",
        "attributes": "AuraComponentService.prototype.getComponentConfigs.!ret.configuration.attributes"
      },
      "descriptor": "AuraComponentService.prototype.getComponentConfigs.!ret.configuration"
    },
    "Aura.Services.AuraComponentService.prototype.getUnusedDefinitions.!ret": {
      "<i>": "?"
    },
    "Aura.Services.AuraComponentService.prototype.destroy.!0": {
      "<i>": "AuraComponentService.prototype.destroy.!0"
    },
    "Aura.Services.AuraComponentService.prototype.getRegisteredComponentDescriptors.!ret": {
      "<i>": "+ComponentDef"
    },
    "Aura.Services.AuraEventService.prototype.getRegisteredEvents.!ret": {
      "<i>": "+EventDef"
    },
    "Aura.Services.AuraRenderingService.prototype.storeFacetInfo.!0": {
      "_marker": "+Node",
      "_facetInfo": "AuraRenderingService.prototype.storeFacetInfo.!0._facetInfo"
    },
    "Aura.Services.AuraRenderingService.prototype.renderFacet.!ret": {
      "<i>": "+Node"
    },
    "Aura.Services.LockerService.!ret.createForDef.!ret": {
      "$envRec": {
        "addEventListener": "SecureDocument.!ret.addEventListener",
        "removeEventListener": "SecureDocument.!ret.removeEventListener"
      }
    },
    "Aura.Services.LockerService.!ret.trust.!0": {
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "open": "SecureComponent.!ret.superRender",
      "send": "SecureComponent.!ret.superRender",
      "getAllResponseHeaders": "SecureComponent.!ret.superRender",
      "getResponseHeader": "SecureComponent.!ret.superRender",
      "setRequestHeader": "SecureComponent.!ret.superRender",
      "abort": "SecureComponent.!ret.superRender"
    },
    "Aura.Locker.SecureObject.addIfSupported.!1": {
      "abort": "SecureComponent.!ret.superRender",
      "open": "SecureComponent.!ret.superRender",
      "send": "SecureComponent.!ret.superRender",
      "getAllResponseHeaders": "SecureComponent.!ret.superRender",
      "getResponseHeader": "SecureComponent.!ret.superRender",
      "setRequestHeader": "SecureComponent.!ret.superRender",
      "addEventListener": "SecureDocument.!ret.addEventListener"
    },
    "Aura.Services.LockerService.!ret.getEnv.!ret": {
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "removeEventListener": "SecureDocument.!ret.removeEventListener"
    },
    "Aura.Locker.SecureObject.addMethodIfSupported.!0": {
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "removeEventListener": "SecureDocument.!ret.removeEventListener"
    },
    "Aura.Utils.Util.filter.!0": {
      "<i>": "+Aura.Services.AuraClientService$AuraXHR"
    },
    "AuraClientService.prototype.getAndClearDupes.!0": {
      "dupes": "AuraClientService.actionStoreMap.<i>.dupes"
    },
    "AuraComponentService.prototype.restoreDefsFromStorage.!0": {
      "contextGlobals": "AuraInstance.context.contextGlobals",
      "currentAction": "+Action",
      "globalValueProviders": "AuraInstance.context.globalValueProviders"
    },
    "AuraDevToolService.!ret.views.component.!ret": {
      "<i>": "+Component"
    },
    "AuraDevToolService.!ret.views.componentDef.!ret": {
      "<i>": "?"
    },
    "AuraDevToolService.!ret.views.controllerDef.!ret": {
      "<i>": "+ControllerDef"
    },
    "AuraDevToolService.!ret.views.modelDef.!ret": {
      "<i>": "+ModelDef"
    },
    "AuraDevToolService.!ret.views.functionCallValue.!ret": {
      "<i>": "valueFactory.valueIndex"
    },
    "AuraDevToolService.!ret.views.PropertyReferenceValue.!ret": {
      "<i>": "valueFactory.valueIndex"
    },
    "AuraDevToolService.!ret.applyGroupBy.!1": {
      "<i>": {
        "<i>": "Component.<i>"
      }
    },
    "AuraDevToolService.!ret.applyGroupBy.!2": {
      "<i>": "+Component"
    },
    "AuraDevToolService.!ret.filterFields.!2": {
      "<i>": "+Component"
    },
    "Component.prototype.index.!1": {
      "0": "Component.localIndex.<i>",
      "1": "Component.localIndex.<i>"
    },
    "Aura.Component.Component.prototype.addHandler.!1": {
      "get": {}
    },
    "Aura.Component.Component.prototype.addHandler.!1.get.!ret": {
      "run": "Component.prototype.addHandler.!1.get.!ret.run",
      "runDeprecated": "Component.prototype.addHandler.!1.get.!ret.runDeprecated"
    },
    "Component.prototype.get.!ret": {
      "<i>": "cancelAnimationFrame"
    },
    "Component.prototype.createActionValueProvider.!ret": {
      "actions": {
        "<i>": "+ActionDef"
      },
      "get": "Component.valueProviders.c.get"
    },
    "Aura.Component.Component.prototype.createStyleValueProvider.!ret": {
      "get": "Component.valueProviders.style.get"
    },
    "Component.prototype.getActionCaller.!ret": {
      "valueProvider": "+AuraInstance"
    },
    "Component.prototype.getEventDispatcher.!ret": {
      "<i>": {
        "<i>": "Component.eventDispatcher.<i>.<i>"
      },
      "get": "Component.eventDispatcher.get"
    },
    "ComponentDef.prototype.getAllStyleDefs.!ret": {
      "<i>": "+StyleDef"
    },
    "ComponentDef.prototype.getAllFlavoredStyleDefs.!ret": {
      "<i>": "+StyleDef"
    },
    "LockerService.!ret.createForDef.!ret": {
      "$envRec": "SecureWindow.!ret"
    },
    "Aura.Services.LockerService.!ret.getEnvForSecureObject.!0": {
      "item": "SecureDOMEvent.!ret.item"
    },
    "SecureAction.!ret": {
      "<i>": "cancelAnimationFrame"
    },
    "LockerService.!ret.getEnvForSecureObject.!0": {
      "item": "SecureDOMEvent.!ret.item"
    },
    "SecureDOMEvent.filterTouchesDescriptor.!0": {
      "item": "SecureDOMEvent.!ret.item"
    },
    "SecureElement.addSecureProperties.!0": {
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "removeEventListener": "SecureDocument.!ret.removeEventListener",
      "item": "SecureDOMEvent.!ret.item",
      "cloneNode": "SecureElement.!ret.cloneNode"
    },
    "SecureElement.addSecureGlobalEventHandlers.!0": {
      "addEventListener": "SecureDocument.!ret.addEventListener",
      "removeEventListener": "SecureDocument.!ret.removeEventListener"
    },
    "Aura.Locker.SecureObject.filterEverything.!2": {
      "beforeCallback": "SecureObject.filterEverything.!2.beforeCallback"
    },
    "Aura.Locker.SecureObject.unfilterEverything.!2": {
      "get": "rawToSecureObjectCaches.<i>.get",
      "set": "rawToSecureObjectCaches.<i>.set"
    },
    "SecureObject.unfilterEverything.!2": {
      "get": "rawToSecureObjectCaches.<i>.get",
      "set": "rawToSecureObjectCaches.<i>.set"
    },
    "newWeakMap.!ret": {
      "get": "rawToSecureObjectCaches.<i>.get",
      "set": "rawToSecureObjectCaches.<i>.set"
    },
    "Component.prototype.createStyleValueProvider.!ret": {
      "get": "Component.valueProviders.style.get"
    },
    "AuraInstance.devToolService.views.component.!ret": {
      "<i>": "+Component"
    },
    "AuraDevToolService.!ret.applyFilter.!ret": {
      "rows": "AuraInstance.devToolService.applyFilter.!ret.rows",
      "rawRows": "AuraInstance.devToolService.applyFilter.!ret.rawRows"
    },
    "AuraDevToolService.!ret.accessbilityAide.nodeListToObjectArray.!0": {
      "<i>": "AuraInstance.devToolService.accessbilityAide.nodeListToObjectArray.!0.<i>"
    }
  },
  "AttributeDef": {
    "prototype": {
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "2393[55:23]-2406[55:36]",
        "!doc": "Gets the descriptor. Returns a DefDescriptor object that contains the metadata for the attribute.\n@returns {DefDescriptor} The qualified name for a DefDescriptor object has the format <code>prefix://namespace:name</code>.\n@export"
      },
      "isRequired": {
        "!type": "fn() -> bool",
        "!span": "2618[65:23]-2628[65:33]",
        "!doc": "Checks whether the attribute definition is required.\nReturns true by default.\n@returns {Boolean} True by default.\n@export"
      },
      "getTypeDef": {
        "!type": "fn() -> !this.typeDef",
        "!span": "2805[75:23]-2815[75:33]",
        "!doc": "Gets the type definition. Returns a TypeDef object.\n\n@returns {TypeDef}\n@private"
      },
      "getDefault": {
        "!type": "fn() -> ?",
        "!span": "2949[84:23]-2959[84:33]",
        "!doc": "Gets the default value.\n@returns {Object}\n@export"
      },
      "getTypeDefDescriptor": {
        "!type": "fn() -> !this.typeDefDescriptor",
        "!span": "3147[95:23]-3167[95:43]",
        "!doc": "Gets the type of the definition descriptor.\n\n@returns {String}\n@private\n@export"
      },
      "getNativeType": {
        "!type": "fn() -> string",
        "!span": "3263[102:23]-3276[102:36]",
        "!doc": "@export"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "787[22:9]-799[22:21]",
    "!doc": "@description Creates a new AttributeDef instance, including the descriptor.\n@constructor\n@param {Object} config\n@export",
    "defaultValue": {
      "!type": "[?]",
      "!span": "1221[30:9]-1233[30:21]",
      "!doc": "Kris: Attribute definitions are shared by reference\n So the first component will have its access set correctly, the following\n components will not. Thus I commented out the delete.\ndelete config[Json.ApplicationKey.ACCESS];"
    },
    "required": {
      "!type": "bool",
      "!span": "2080[47:9]-2088[47:17]"
    }
  },
  "AttributeSet": {
    "prototype": {
      "hasAttribute": {
        "!type": "fn(name: ?) -> bool",
        "!span": "1494[49:23]-1506[49:35]",
        "!doc": "Whether attribute exists\n\n@param {String}\n           name - name of attribute\n@returns {boolean} true if attribute exists\n@private"
      },
      "get": {
        "!type": "fn(key: ?, component: ?) -> ?",
        "!span": "2541[85:23]-2544[85:26]",
        "!doc": "Returns the value referenced using property syntax.\n\n@param {String}\n           key The data key to look up.\n@returns {Object} the value of the attribute\n@protected"
      },
      "getShadowValue": {
        "!type": "fn(key: string) -> !this.shadowValues.<i>",
        "!span": "4329[142:23]-4343[142:37]"
      },
      "setShadowValue": {
        "!type": "fn(key: string, value: string)",
        "!span": "4655[154:23]-4669[154:37]"
      },
      "set": {
        "!type": "fn(key: ?, value: [AttributeSet.prototype.set.!1], component: ?)",
        "!span": "5164[173:23]-5167[173:26]",
        "!doc": "Set the attribute of the given name to the given value.\n\n@param {String}\n           key The key can be a path expression inside. E.g.\n           attribute.nestedValue.value....}\n@param {Object}\n           value The value to be set.\n\n@protected"
      },
      "clearReference": {
        "!type": "fn(key: ?) -> ?",
        "!span": "8559[264:23]-8573[264:37]",
        "!doc": "Clears a property reference value of the given name, and returns it. Does nothing if the attribute\ndoes not exist or is not a property reference value.\n\n@param {String}\n           key The key can be a path expression inside. E.g.\n           attribute.nestedValue.value....}\n\n@returns {PropertyReferenceValue} the reference that was found and cleared, or null\n@protected"
      },
      "isValueValidForAttribute": {
        "!type": "fn(attributeName: ?, value: [AttributeSet.prototype.set.!1]) -> bool",
        "!span": "9222[288:23]-9246[288:47]",
        "!doc": "Verifies if a value is valid for the type that the attribute is defined as.\nStrings as strings, arrays as arrays, etc."
      },
      "isTypeOfArray": {
        "!type": "fn(attributeName: ?) -> bool",
        "!span": "10111[322:23]-10124[322:36]"
      },
      "merge": {
        "!type": "fn(attributes: AttributeSet.!0, attributeDefSet: ?)",
        "!span": "11181[352:23]-11186[352:28]",
        "!doc": "Reset the attribute set to point at a different def set.\n\nAllows us to change the set of attributes in a set when we inject a new\ncomponent. No checking is done here, if checking is desired, it should be\ndone by the caller.\n\nDoesn't check the current state of attributes because they don't matter. This\nwill create/update attributes based on new AttributeDefSet, provided\nattribute config and current attribute values\n\n@param {AttributeDefSet}\n           attributeDefSet the new def set to install.\n@param {Object}\n           attributes - new attributes configuration\n@private"
      },
      "getDefault": {
        "!type": "fn(name: ?)",
        "!span": "11654[369:23]-11664[369:33]",
        "!doc": "Gets default attribute value.\n\n@param {String}\n           name - name of attribute\n@private"
      },
      "destroy": {
        "!type": "fn(async: bool) -> ?",
        "!span": "11999[386:23]-12006[386:30]",
        "!doc": "Destroys the attributeset.\n\n@param {Boolean}\n           async - whether to put in our own trashcan\n@private"
      },
      "initialize": {
        "!type": "fn(attributes: AttributeSet.!0)",
        "!span": "13842[447:23]-13852[447:33]",
        "!doc": "Loop through AttributeDefSet and create or update value using provided config\n\n@param {Object}\n           config - attribute configuration\n@private"
      }
    },
    "getDef": {
      "!type": "fn(key: ?, component: ?) -> [!1]",
      "!span": "1850[62:13]-1856[62:19]",
      "!doc": "Returns the highest extended reference of the attribute using property syntax.\n\n@param {String} key The data key to look up.\n@param {Object} component The component hierarchy to investigate\n@returns {Object} the attribute def\n@protected"
    },
    "!type": "fn(attributes: AttributeSet.!0, attributeDefSet: ?)",
    "!span": "1025[28:9]-1037[28:21]",
    "!doc": "@description Creates an AttributeSet instance.\n@param {Object}\n           config Sets the values with the config object, if provided.\n@param {Object}\n           valueProvider Sets the value provider for the attributes.\n@param {AttributeDefSet}\n           attributeDefSet The metadata describing the attributes in the set.\n@constructor\n@protected",
    "values": {
      "!span": "1075[29:6]-1081[29:12]",
      "!doc": "#if {\"excludeModes\" : [\"PRODUCTION\", \"PRODUCTIONDEBUG\"]}"
    },
    "shadowValues": {
      "<i>": {
        "!type": "string",
        "!span": "4839[157:26]-4842[157:29]"
      },
      "!span": "1097[30:9]-1109[30:21]"
    },
    "decorators": {
      "<i>": {
        "!type": "[?]",
        "!span": "14961[478:36]-14965[478:40]"
      },
      "!span": "1123[31:9]-1133[31:19]"
    }
  },
  "Aura": {
    "time": {
      "!type": "fn() -> number",
      "!span": "908[26:5]-912[26:9]",
      "!doc": "-- Aura inlinning bootstrap"
    },
    "bootstrap": {
      "<i>": {
        "!type": "number",
        "!span": "1123[29:19]-1127[29:23]"
      },
      "!span": "1042[27:5]-1051[27:14]"
    },
    "bootstrapMark": {
      "!type": "fn(mark: string, value: ?)",
      "!span": "1063[28:5]-1076[28:18]"
    },
    "Utils": {
      "Bitset": {
        "prototype": {
          "testBit": {
            "!type": "fn(n: ?) -> bool",
            "!span": "1136[38:28]-1143[38:35]",
            "!doc": "Tests whether a specific individual bit is or is not set.\n\n@returns {@code true} if and only if the n'th bit of the set is true.\n@export"
          },
          "setBit": {
            "!type": "fn(n: ?)",
            "!span": "1442[50:28]-1448[50:34]",
            "!doc": "Causes the n'th bit of the Bitset to be set true."
          },
          "clearBit": {
            "!type": "fn(n: ?)",
            "!span": "1725[60:28]-1733[60:36]",
            "!doc": "Causes the n'th bit of the Bitset to be set false."
          },
          "toString": {
            "!type": "fn() -> string",
            "!span": "2065[72:28]-2073[72:36]",
            "!doc": "Returns a base64 representation of the Bitset."
          },
          "trim": {
            "!type": "fn()",
            "!span": "2225[79:28]-2229[79:32]",
            "!doc": "Internal utility to remove trailing 0's from the bitset data."
          },
          "pad": {
            "!type": "fn(n: number)",
            "!span": "2545[91:28]-2548[91:31]",
            "!doc": "Internal utility to pad leading 0's onto the bitset data."
          },
          "length": {
            "!type": "fn() -> !this.data.length",
            "!span": "2813[101:28]-2819[101:34]",
            "!doc": "Returns length of the bitset, in 6-bit words (not individual bits)."
          }
        },
        "initialized": {
          "!type": "bool",
          "!span": "2897[106:18]-2908[106:29]",
          "!doc": "statics"
        },
        "alphabet": {
          "!type": "[string]",
          "!span": "3071[111:26]-3079[111:34]"
        },
        "codes": {
          "!type": "[number]",
          "!span": "3425[118:26]-3430[118:31]"
        },
        "init": {
          "!type": "fn()",
          "!span": "2937[108:18]-2941[108:22]"
        },
        "!type": "fn(str: string)",
        "!span": "779[23:11]-785[23:17]",
        "!doc": "A representation of a set of individual bits, addressable as if organized as\nan array.\n\n@constructor\n@export"
      },
      "data": {
        "!type": "[string]",
        "!span": "909[28:9]-913[28:13]"
      },
      "DocLevelHandler": {
        "prototype": {
          "setEnabled": {
            "!type": "fn(enable: bool)",
            "!span": "1672[53:37]-1682[53:47]",
            "!doc": "Set whether the handler is enabled.\n\nThis function will enable or disable the handler as necessary. Note that the\ncallback will be called only if the component is rendered.\n\n@param {Boolean} enable if truthy, the handler is enabled, otherwise disabled.\n@export"
          }
        },
        "!type": "fn(eventName: ?, callback: ?, component: +Component)",
        "!span": "1014[32:11]-1029[32:26]",
        "!doc": "Constructor for a doc level handler.\n\n@param {String}\n           eventName the name of the event (must be valid dom event)\n@param {Function}\n           callback the callback function for the event (will be wrapped)\n@param {Component}\n           component the component attached to the handler.\n\n@constructor\n@private\n@export",
        "enabled": {
          "!type": "bool",
          "!span": "1164[35:9]-1171[35:16]"
        },
        "callback": {
          "!type": "fn(eventObj: ?)",
          "!span": "1211[37:9]-1219[37:17]"
        }
      },
      "Mutex": {
        "SET_MUTEX_WAIT": {
          "!type": "number",
          "!span": "1796[48:17]-1810[48:31]"
        },
        "RETRY_WAIT": {
          "!type": "number",
          "!span": "1834[49:17]-1844[49:27]"
        },
        "MAX_LOCK_TIME": {
          "!type": "number",
          "!span": "1872[50:17]-1885[50:30]"
        },
        "CLIENT_ID": {
          "!type": "string",
          "!span": "1912[51:17]-1921[51:26]"
        },
        "GLOBAL_KEY": {
          "!type": "string",
          "!span": "1990[52:17]-2000[52:27]"
        },
        "MUTEX_X_KEY": {
          "!type": "string",
          "!span": "2034[53:17]-2045[53:28]"
        },
        "MUTEX_Y_KEY": {
          "!type": "string",
          "!span": "2081[54:17]-2092[54:28]"
        },
        "prototype": {
          "getClientId": {
            "!type": "fn() -> string",
            "!span": "2211[61:27]-2222[61:38]",
            "!doc": "Returns the unique clientId.\n@returns {String}\n@export"
          },
          "lock": {
            "!type": "fn()",
            "!span": "2605[72:27]-2609[72:31]",
            "!doc": "Acquires a lock.\n@param {String} key The identifier of the lock.\n@param {Function} callback The function to invoke after the lock is acquired, to which it is passed a function to unlock.\n@param {Number} timeout the maximum time the lock may be held (milliseconds).\n@export"
          },
          "_lockPriv": {
            "!type": "fn(key: string, callback: fn(unlock: fn() -> number|?|+Function)|string, timeout: number)",
            "!span": "3077[82:27]-3086[82:36]"
          },
          "hasLock": {
            "!type": "fn(key: string) -> bool",
            "!span": "3856[105:27]-3863[105:34]"
          },
          "_execute": {
            "!type": "fn(key: string, callback: fn(unlock: fn() -> number|?|+Function)|string)",
            "!span": "3973[109:27]-3981[109:35]"
          },
          "_clearLock": {
            "!type": "fn(key: ?)",
            "!span": "4144[115:27]-4154[115:37]"
          },
          "_retry": {
            "!type": "fn(key: string, callback: fn(unlock: fn() -> number|?|+Function)|string, timeout: number)",
            "!span": "4277[119:27]-4283[119:33]"
          },
          "_isLockAvailable": {
            "!type": "fn(key: string, timeout: number) -> bool",
            "!span": "4501[125:27]-4517[125:43]"
          },
          "_getX": {
            "!type": "fn(key: string) -> string",
            "!span": "4868[136:27]-4873[136:32]"
          },
          "_setX": {
            "!type": "fn(key: string, callback: fn())",
            "!span": "5043[141:27]-5048[141:32]"
          },
          "_getY": {
            "!type": "fn(key: string) -> string",
            "!span": "5318[146:27]-5323[146:32]"
          },
          "_setY": {
            "!type": "fn(key: string, callback: fn())",
            "!span": "5493[151:27]-5498[151:32]"
          }
        },
        "!type": "fn()",
        "!span": "1749[46:11]-1754[46:16]",
        "!doc": "This class allows code to be executed atomically (critical regions)\n\nImplemented based on \"A Fast Mutual Exclusion Algorithm\" (Leslie Lamport 1985)\nhttp://research.microsoft.com/en-us/um/people/lamport/pubs/fast-mutex.pdf\n\nAlgorithm (`_lockPriv` method):\n1.  Set X = i\n2.  If Y != 0: Restart\n3.  Set Y = i\n4.  If X != i:\n5.    Delay\n6.    If Y != i: Restart\n7.  [Has lock. Do work]\n8.  Set Y = 0\n\nIn English:\n1. Always set X to the current client’s unique identifier.\n2. If Y is not zero then another client has the lock, so restart.\n3. If Y was zero, then set Y to the client ID.\n4. If X has changed, there’s a possibility of contention. So…\n5. Delay for long enough for another client to have seen Y as zero and tried to write it. (We added a random jitter here to minimize the chance of a client being starved.)\n6. If the client didn’t win Y, then restart the whole process.\n7. The lock was won, or there was no sign of contention, so now we can do our work.\n8. Clear Y to allow another client to take the lock.\n\n@constructor\n@export"
      },
      "NumberFormat": {
        "prototype": {
          "parseError": {
            "!type": "fn(s: string)",
            "!span": "6041[175:34]-6051[175:44]"
          },
          "checkForSpecialChar": {
            "!type": "fn(c: string)",
            "!span": "6247[183:34]-6266[183:53]",
            "!doc": "Helper method to track special characters.\n@private"
          },
          "replaceCurrencies": {
            "!type": "fn()",
            "!span": "6839[212:34]-6856[212:51]",
            "!doc": "Replaces currency markers with the local currency symbol.\n@private"
          },
          "replaceCurrency": {
            "!type": "fn(str: string) -> !0",
            "!span": "7224[224:34]-7239[224:49]",
            "!doc": "@private"
          },
          "translateDigits": {
            "!type": "fn(charArray: [string]) -> !0",
            "!span": "7473[234:34]-7488[234:49]",
            "!doc": "@private"
          },
          "format": {
            "!type": "fn(number: number|string) -> string",
            "!span": "7997[249:34]-8003[249:40]",
            "!doc": "Format a number into a string. Accepts a string of the format \"#.#\" for formatting numbers\nrequiring greater than double precision.\n@param {Number|String} number The number to be formatted.\n@export"
          }
        },
        "ZERO": {
          "!type": "string",
          "!span": "5994[173:24]-5998[173:28]"
        },
        "!type": "fn(format: string|PropertyReferenceValue.lastResult, symbols: string)",
        "!span": "936[24:11]-948[24:23]",
        "!doc": "Format is a string using the java format pattern (e.g. #,##0.0). Note that this does not handle quoted\nspecial characters or exponents.\nSymbols is an optional map of localized symbols to use, otherwise it will use the current locale's symbols\n\n@constructor\n@export",
        "zeroCharCodeOffset": {
          "!type": "number",
          "!span": "1449[32:9]-1467[32:27]",
          "!doc": "default values for any format"
        },
        "hasCurrency": {
          "!type": "bool",
          "!span": "1565[33:9]-1576[33:20]"
        },
        "multiplier": {
          "!type": "number",
          "!span": "1595[34:9]-1605[34:19]"
        },
        "minDigits": {
          "!type": "number",
          "!span": "1620[35:9]-1629[35:18]"
        },
        "groupingDigits": {
          "!type": "number",
          "!span": "1644[36:9]-1658[36:23]"
        },
        "minFractionDigits": {
          "!type": "number",
          "!span": "1674[37:9]-1691[37:26]"
        },
        "maxFractionDigits": {
          "!type": "number",
          "!span": "1706[38:9]-1723[38:26]"
        },
        "prefix": {
          "!type": "string",
          "!span": "1738[39:9]-1744[39:15]"
        },
        "suffix": {
          "!type": "string",
          "!span": "1762[40:9]-1768[40:15]"
        },
        "hasNegativePattern": {
          "!type": "bool",
          "!span": "1786[41:9]-1804[41:27]"
        },
        "negativePrefix": {
          "!type": "string",
          "!span": "1823[42:9]-1837[42:23]"
        },
        "negativeSuffix": {
          "!type": "string",
          "!span": "1855[43:9]-1869[43:23]"
        }
      },
      "Override": {
        "prototype": {
          "install": {
            "!type": "fn(fn: +Function, scope: ?, priority: number)",
            "!span": "2860[73:30]-2867[73:37]",
            "!doc": "Install an override.\n\nThis installs a function on an override.\n\nThe function supplied should have the following code in it:\n------\n var config = Array.prototype.shift.apply(arguments);\n var ret = config[\"fn\"].apply(config[\"scope\"], arguments);\n return ret\n------\n\nThat stanza executes down the chain of overrides. It is not required, but if it is not executed,\nthe following overrides in the chain, and the original function, will not be executed.\n\nFIXME: we need a priority here to ensure that we install in a sortof-order.\n\n@param {Function} fn the function to install.\n@param {Object} scope the scope of the function.\n@param {number} priority"
          },
          "uninstall": {
            "!type": "fn(fn: ?) -> bool",
            "!span": "3952[115:30]-3961[115:39]",
            "!doc": "Uninstall a previously installed function.\n\nThis simply removes the override. If it is the last override, the original function is\nrestored.\n\n@param fn the function to remove."
          },
          "start": {
            "!type": "fn()",
            "!span": "4542[140:30]-4547[140:35]",
            "!doc": "Internal function to start off override processing.\n\nThis function is the entry point that overrides the function."
          },
          "continuation": {
            "!type": "fn()",
            "!span": "4843[152:30]-4855[152:42]",
            "!doc": "Internal function to continue an override chain.\n\nHACK ALERT! this is not this."
          }
        },
        "!type": "fn(instance: ?, orig: ?, proto: bool, replace: fn(bound: fn()), restore: fn(orig: ?, bound: ?)|fn(orig: ?))",
        "!span": "1298[32:11]-1306[32:19]",
        "!doc": "A def for an override.\n\nThis is rather painful, and would like to be refactored, but until we can do that, this will have to do.\nIdeally, we would be passed an 'instance' and a 'names', along with 'bound aliases' where instance[name] would\ngive the original function and we could simply assign, meaning that replace and restore would not be supplied\nas functions.\n\n@param instance the instance, if any, otherwise null.\n@param orig the original function.\n@param proto true if the original is on a prototype.\n@param replace a function to replace\n@param restore a function to restore\n@constructor",
        "proto": {
          "!type": "bool",
          "!span": "1988[43:9]-1993[43:14]"
        },
        "replace": {
          "!type": "fn(bound: fn())",
          "!span": "2012[44:9]-2019[44:16]"
        },
        "restore": {
          "!type": "fn(orig: ?, bound: ?)",
          "!span": "2040[45:9]-2047[45:16]"
        },
        "chain": {
          "!type": "[Aura.Utils.Override.chain.<i>]",
          "!span": "2068[46:9]-2073[46:14]"
        }
      },
      "SecureFilters": {
        "html": {
          "!type": "fn(val: string) -> string",
          "!span": "2247[62:18]-2251[62:22]",
          "!doc": "Encodes values for safe embedding in HTML tags and attributes.\n\nSee html(value) in README.md for full documentation.\n\n@name html\n@param {any} val will be converted to a String prior to encoding\n@return {string} the encoded string"
        },
        "js": {
          "!type": "fn(val: ?) -> string",
          "!span": "4559[137:18]-4561[137:20]",
          "!doc": "Encodes values for safe embedding in JavaScript string contexts.\n\nSee js(value) in README.md for full documentation.\n\n@name js\n@param {any} val will be converted to a String prior to encoding\n@return {string} the encoded string"
        },
        "jsAttr": {
          "!type": "fn(val: ?) -> string",
          "!span": "4985[151:18]-4991[151:24]",
          "!doc": "Encodes values embedded in HTML scripting attributes.\n\nSee jsAttr(value) in README.md for full documentation.\n\n@name jsAttr\n@param {any} val will be converted to a String prior to encoding\n@return {string} the encoded string"
        },
        "uri": {
          "!type": "fn(val: ?) -> string",
          "!span": "5372[165:18]-5375[165:21]",
          "!doc": "Percent-encodes unsafe characters in URIs.\n\nSee uri(value) in README.md for full documentation.\n\n@name uri\n@param {any} val will be converted to a String prior to encoding\n@return {string} the percent-encoded string"
        },
        "jsObj": {
          "!type": "fn(val: ?) -> string",
          "!span": "6402[193:18]-6407[193:23]",
          "!doc": "Encodes an object as JSON, but with unsafe characters in string literals\nbackslash-escaped.\n\nSee jsObj(value) in README.md for full documentation.\n\n@name jsObj\n@param {any} val\n@return {string} the JSON- and backslash-encoded string"
        },
        "css": {
          "!type": "fn(val: ?) -> string",
          "!span": "6959[210:18]-6962[210:21]",
          "!doc": "Encodes values for safe embedding in CSS context.\n\nSee css(value) in README.md for full documentation.\n\n@name css\n@param {any} val\n@return {string} the backslash-encoded string"
        },
        "style": {
          "!type": "fn(val: ?) -> string",
          "!span": "7620[232:18]-7625[232:23]",
          "!doc": "Encodes values for safe embedding in HTML style attribute context.\n\nSee style(value) in README.md for full documentation.\n\n@name style\n@param {any} val\n@return {string} the entity- and backslash-encoded string"
        },
        "!span": "763[22:11]-776[22:24]",
        "!doc": "Secure Filters (Anti-XSS) library approved by Salesforce Security\nhttps://github.com/SalesforceEng/secure-filters\nv1.0.5"
      },
      "SizeEstimator": {
        "CHARACTER_SIZE": {
          "!type": "number",
          "!span": "1029[28:14]-1043[28:28]",
          "!doc": "Note on sizing.  The following values are taken from the ECMAScript specification, where available.\nOther values are guessed.\n\nSource: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf"
        },
        "NUMBER_SIZE": {
          "!type": "number",
          "!span": "1063[29:14]-1074[29:25]"
        },
        "BOOLEAN_SIZE": {
          "!type": "number",
          "!span": "1097[30:14]-1109[30:26]"
        },
        "POINTER_SIZE": {
          "!type": "number",
          "!span": "1173[31:14]-1185[31:26]"
        },
        "prototype": {
          "hasOwnProperty": "!proto.hasOwnProperty",
          "estimateSize": "SizeEstimator.prototype.estimateSize",
          "sizeOfString": "SizeEstimator.prototype.sizeOfString"
        }
      },
      "Style": {
        "prototype": {
          "getHead": {
            "!type": "fn() -> !this.head",
            "!span": "818[28:27]-825[28:34]",
            "!doc": "Gets the head element of the HTML document.\n@returns {Object}"
          },
          "apply": {
            "!type": "fn(styleText: string) -> +Element",
            "!span": "1298[45:27]-1303[45:32]",
            "!doc": "Applies a CSS style to an element using the HTML style element.\nAppends the HTML style element as a child of the head element.\n\n@param {String} styleText The HTML style element, including the type attribute.\n@returns {Object} The style element\n@private"
          },
          "include": {
            "!type": "fn(href: string) -> +Element",
            "!span": "2305[74:27]-2312[74:34]",
            "!doc": "Includes a CSS style link element with href, rel, and type attributes.\nAppend the HTML link element as a child of the head element.\nReturns the HTML link element.\n@param {String} href Defines the location of the style sheet.\n@returns {Object} The link element\n@export"
          },
          "getCSSProperty": {
            "!type": "fn(el: +Element, cssprop: string) -> !0.currentStyle.<i>",
            "!span": "3039[91:27]-3053[91:41]",
            "!doc": "Gets the CSS property of an element.\nnote for \"background\": if we specify \"background\" in  CSS, Firefox will use \"background-color\" as key\nIE8 will use \"backgroundColor\", IE9+ are good with \"background-color\".\n@param {HTMLElement} el The HTML element\n@param {String} cssprop The CSS property to be retrieved\n@export"
          }
        },
        "!type": "fn()",
        "!span": "662[20:11]-667[20:16]",
        "!doc": "@constructor\n@export"
      },
      "Util": {
        "prototype": {
          "isIE": {
            "!type": "bool",
            "!span": "1690[50:26]-1694[50:30]",
            "!doc": "Browser check for all supported versions of Internet Explorer, does the validation using the userAgent.\n\n@returns {Boolean} true if Internet Explorer detected\n@export"
          },
          "isLocalStorageEnabled": {
            "!type": "fn() -> !this.localStorageEnabled",
            "!span": "1946[59:26]-1967[59:47]",
            "!doc": "Browser check for localStorage enablement\n\n@returns {Boolean} true if LocalStorage is available\n@export"
          },
          "isIOSWebView": {
            "!type": "fn() -> !this._isIOSWebView",
            "!span": "2599[82:26]-2611[82:38]",
            "!doc": "Whether IOS7 UIWebView\n@returns {boolean} true if IOS UIWebView\n@export"
          },
          "globalEval": {
            "!type": "fn(src: string, globals: ?, optionalSourceURL: ?)",
            "!span": "2986[95:26]-2996[95:36]",
            "!doc": "evals code globally, without enclosing the current scope\n\n@private"
          },
          "isArray": {
            "!type": "fn(arg: ?) -> bool",
            "!span": "4423[125:26]-4430[125:33]",
            "!doc": "Checks whether the specified object is an array.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object is an array, or false otherwise.\n@function\n@platform\n@export"
          },
          "isObject": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "4995[140:26]-5003[140:34]",
            "!doc": "Checks whether the specified object is a valid object.\nA valid object: Is not a DOM element, is not a native browser class (XMLHttpRequest)\nis not falsey, and is not an array, error, function string or number.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object is a valid object, or false otherwise.\n@function\n@platform\n@export"
          },
          "isPlainObject": {
            "!type": "fn(o: ?) -> bool",
            "!span": "5402[152:26]-5415[152:39]",
            "!doc": "Checks whether the specified object is a plain object or literal.\nA plain object is created using \"{}\" or \"new Object()\".\n\n@param {Object} o The object to check for.\n@returns {Boolean} True if the object is a plain object, or false otherwise.\n@export"
          },
          "isError": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "6435[186:26]-6442[186:33]",
            "!doc": "Checks whether the specified object is a valid error.\nA valid error: Is not a DOM element, native browser class (XMLHttpRequest), falsey,\narray, function string or number.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object is a valid error, or false otherwise.\n@export"
          },
          "isFunction": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "6890[199:26]-6900[199:36]",
            "!doc": "Checks whether the specified object is a valid function.\nA valid function: Is not a DOM element, native browser class (XMLHttpRequest), falsey,\narray, error, or number.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object is a valid function, or false otherwise.\n@export"
          },
          "isString": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "7214[210:26]-7222[210:34]",
            "!doc": "Checks if the object is of type string.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object is of type string, or false otherwise.\n@export"
          },
          "isNumber": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "7499[221:26]-7507[221:34]",
            "!doc": "Checks if the object is of type number.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object is of type number, or false otherwise.\n@export"
          },
          "isFiniteNumber": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "7820[232:26]-7834[232:40]",
            "!doc": "Checks if the object is a finite number (not NaN or Infinity or -Infinity)\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object is a finite number, or false otherwise.\n@export"
          },
          "isBoolean": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "8125[243:26]-8134[243:35]",
            "!doc": "Checks if the object is of type boolean.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object is of type boolean, or false otherwise.\n@export"
          },
          "isUndefined": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "8420[255:26]-8431[255:37]",
            "!doc": "Checks if the object is undefined.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object type is undefined, or false otherwise.\n@export\n@platform"
          },
          "isUndefinedOrNull": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "8733[267:26]-8750[267:43]",
            "!doc": "Checks if the object is undefined or null.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object type is undefined or null, or return false otherwise.\n@export\n@platform"
          },
          "getBooleanValue": {
            "!type": "fn(val: ?) -> bool",
            "!span": "9786[302:26]-9801[302:41]",
            "!doc": "Coerces truthy and falsy values into native booleans\n\n@param {Object} val The object to check.\n@returns {Boolean} True if the object is truthy, or false otherwise.\n@platform\n@function\n@export"
          },
          "createHtmlElement": {
            "!type": "fn(tagName: string, attributes: ?) -> +Element",
            "!span": "10349[315:26]-10366[315:43]",
            "!doc": "Creates and returns an HTML element of the specified tag name and map of attributes.\n\n@param {String} tagName Tag name of the html element to create (e.g. 'a', 'img', 'div').\n@param {Map} attributes A map of attributes that the element will have\n  (e.g. {src: 'foo.img', alt: 'Some text'}\n@returns (HTMLElement) the newly created element\n@export"
          },
          "clearNode": {
            "!type": "fn(node: +Element)",
            "!span": "11075[337:26]-11084[337:35]",
            "!doc": "Removes all children of a node, effectively clearing its body.\n\n@param {HTMLElement} node The node to be cleared.\n@export"
          },
          "getElement": {
            "!type": "fn(id: string) -> +Element|?",
            "!span": "13474[426:26]-13484[426:36]",
            "!doc": "Gets a DOM element by its id without any leading characters (e.g. #) unless the ID contains them.\n\n@param {String} id The corresponding id of the DOM element.\n@returns {Object} The element with the matching id, or null if none is found.\n@export"
          },
          "copy": {
            "!type": "fn(value: +Function) -> !0",
            "!span": "13864[437:26]-13868[437:30]",
            "!doc": "Gets a copy of an object. In the case of an Array or Object, returns a shallow copy. In the case of a literal,\nreturns the literal value.\n\n@param {Object} value The value for which to return a comparable copy.\n@returns {Object} The comparable copy of the value supplied."
          },
          "compareValues": {
            "!type": "fn(expected: ?, actual: ?) -> Aura.Utils.Util.prototype.compareValues.!ret",
            "!span": "14469[457:26]-14482[457:39]",
            "!doc": "Compares values. In the case of an Array or Object, compares first level references only.\nIn the case of a literal, directly compares value and type equality.\n\n@param {Object} expected The source value to compare.\n@param {Object} actual The target value to compare.\n@returns {Object} The result of the comparison, with reasons."
          },
          "hasClass": {
            "!type": "fn(element: ?, className: string) -> bool",
            "!span": "16614[520:26]-16622[520:34]",
            "!doc": "Checks whether the component has the specified CSS class.\n\n@example\n//find a component with aura:id=\"myCmp\" in markup\nvar myCmp = component.find(\"myCmp\");\n$A.util.hasClass(myCmp, \"myClass\");\n\n@param {Object} element The component to check.\n@param {String} className The CSS class name to check for.\n@returns {Boolean} True if the specified class is found for the component, or false otherwise.\n@export\n@platform"
          },
          "addClass": {
            "!type": "fn(element: Aura.Utils.Util.prototype.addClass.!0, newClass: string)",
            "!span": "17549[550:26]-17557[550:34]",
            "!doc": "Adds a CSS class to a component.\n\n@example\n//find a component with aura:id=\"myCmp\" in markup\nvar myCmp = component.find(\"myCmp\");\n$A.util.addClass(myCmp, \"myClass\");\n\n@param {Object} element The component to apply the class on.\n@param {String} newClass The CSS class to be applied.\n@export\n@platform"
          },
          "removeClass": {
            "!type": "fn(element: Aura.Utils.Util.prototype.removeClass.!0, newClass: string)",
            "!span": "18032[568:26]-18043[568:37]",
            "!doc": "Removes a CSS class from a component.\n\n@example\n//find a component with aura:id=\"myCmp\" in markup\nvar myCmp = component.find(\"myCmp\");\n$A.util.removeClass(myCmp, \"myClass\");\n\n@param {Object} element The component to remove the class from.\n@param {String} newClass The CSS class to be removed from the element.\n@export\n@platform"
          },
          "toggleClass": {
            "!type": "fn(element: ?, className: string, condition: bool) -> bool",
            "!span": "18550[586:26]-18561[586:37]",
            "!doc": "Toggles (adds or removes) a CSS class from a component.\n\n@example\n//find a component with aura:id=\"toggleMe\" in markup\nvar toggleText = component.find(\"toggleMe\");\n$A.util.toggleClass(toggleText, \"toggle\");\n\n@param {Object} element The component to add or remove the class from.\n@param {String} className The CSS class to be added or removed.\n@export\n@platform"
          },
          "swapClass": {
            "!type": "fn(element: ?, oldClass: [?|string]|string, newClass: [?|string]|string)",
            "!span": "19190[607:26]-19199[607:35]",
            "!doc": "Swaps an element's class by removing the selected class and adding another in its place.\n\n@param {Object} element The element to be processed.\n@param {String} oldClass The class to remove from the element.\n@param {String} newClass The class to add to the element.\n@export"
          },
          "setClass": {
            "!type": "fn(element: ?, newClass: string|[?|string], remove: bool)",
            "!span": "19590[621:26]-19598[621:34]",
            "!doc": "@private"
          },
          "buildClass": {
            "!type": "fn(oldClass: string, newClass: string|[?|string], remove: bool) -> !0",
            "!span": "21339[668:26]-21349[668:36]",
            "!doc": "@private"
          },
          "buildFlavorClass": {
            "!type": "fn(cmp: ?, flavor: ?) -> string",
            "!span": "22283[703:26]-22299[703:42]",
            "!doc": "Builds the appropriate css class name for a flavor.\n\n@param {Object} cmp The DefDescriptor of the component being flavored.\n@returns {String} flavor The flavor name.\n@export"
          },
          "createElementsFromMarkup": {
            "!type": "fn(markup: string) -> [?]",
            "!span": "23124[734:26]-23148[734:50]",
            "!doc": "Generates dom nodes from string markup\n\n@param {String} markup The markup from which to generate dom nodes\n@returns {Array} An array of the elements that were generated.\n@export"
          },
          "insertFirst": {
            "!type": "fn(newEl: [+Node]|+DocumentFragment, referenceEl: ?) -> ?",
            "!span": "23643[751:27]-23654[751:38]",
            "!doc": "Inserts element(s) as the first child of the parent element.\n\n@param {Object} newE1 The new element to insert.\n@param {Object} referenceE1 The reference element\n@returns {Object} The element that was inserted.\n@export"
          },
          "insertBefore": {
            "!type": "fn(newEl: ?, referenceEl: ?) -> ?",
            "!span": "24457[776:26]-24469[776:38]",
            "!doc": "Inserts a new element, newEl, directly before the reference element, referenceEl.\nIf the reference element is a parent node, insert the new element directly before the parent node.\n\n@param {Object} newE1 The new element to insert.\n@param {Object} referenceE1 The reference element\n@returns {Object} The element that was inserted.\n@export"
          },
          "insertAfter": {
            "!type": "fn(newEl: [+Node]|+DocumentFragment, referenceEl: ?) -> ?",
            "!span": "25204[799:26]-25215[799:37]",
            "!doc": "Inserts a new element, newEl, directly after the reference element, referenceEl.\nIf the reference element is a parent node, insert the new element directly after the parent node.\n\n@param {Object} newE1 The new element to insert.\n@param {Object} referenceE1 The reference element\n@returns {Object} The element that was inserted.\n@export"
          },
          "appendChild": {
            "!type": "fn(newEl: +DocumentFragment, referenceEl: ?) -> ?",
            "!span": "26283[827:26]-26294[827:37]",
            "!doc": "Adds a new element to the end of the reference element. Does not work if the canHaveChildren property on the reference element is false.\n\n@param {Object} newE1 The element to append as a child of the reference element.\n@param {Object} referenceE1 The existing element\n@returns {Object} The new element that was added"
          },
          "removeElement": {
            "!type": "fn(element: Aura.Utils.Util.prototype.removeElement.!0)",
            "!span": "27262[860:26]-27275[860:39]",
            "!doc": "Removes the specified element from the DOM.\n\nUse this method with caution. Since we hijack the normal delete\nfunctionality, we need to be careful of odd event processing. Specifically\nwe end up sending off some events that would not otherwise be sent.\n\nAlso note that we currently remove nodes children first, which means we\ndeconstruct our tree from the bottom up. If we reverse this, we might be\nable to add optimizations.\n\n@param {Object} element The element to be removed.\n@export"
          },
          "generateUrl": {
            "!type": "fn(url: string, params: ?, encoded: bool) -> !0",
            "!span": "30049[926:26]-30060[926:37]",
            "!doc": "Manipulate the properties of the querystring portion of a url.\n@param {String} url Any url to manipulate, if it doesn't have a question mark in it. Any hash remains not affected.\n@param {Object} params Map of key->value's to set in the url. Set key to null to remove it from the url.\n@param {Boolean} encoded True if params are alredy encoded and prevent re-encoding.\n@export"
          },
          "trim": {
            "!type": "fn(value: string) -> string",
            "!span": "32119[997:26]-32123[997:30]",
            "!doc": "Trims a string by removing newlines, spaces, and tabs from the beginning and end of the string.\n\n@param {String} value The string to be trimmed.\n@returns {String}\n@export"
          },
          "format": {
            "!type": "fn(formatString: string, arg1: string, arg2: string, argN: number) -> string",
            "!span": "32562[1009:26]-32568[1009:32]",
            "!doc": "Formats an arbitrary number of arguments into a string by replacing {0}, {1}, ... {n} with the corresponding argument supplied after 'formatString'.\n\n@param {String} formatString The string to be formatted.\n@param {String} arg1...argN The list of arguments to splice into formatString.\n@returns {String}\n@export"
          },
          "truncate": {
            "!type": "fn(st: string, len: number, ellipsis: bool, truncateByWord: bool) -> !0",
            "!span": "33670[1034:26]-33678[1034:34]",
            "!doc": "Truncates a string to the given length.\n\n@param {String} st The string to be truncated.\n@param {Number} len The length of characters. Includes the ellipsis if ellipsis is set to true.\n@param {Boolean} ellipsis If set to true, an ellipsis is added to the truncated string.\n@param {Boolean} truncateByWord If set to true, checks that no truncation occurs in the middle of a word.\n@returns {String} The truncated string.\n@export"
          },
          "createTimeoutCallback": {
            "!type": "fn(callback: fn()|+Function, toleranceMillis: number) -> fn()|+Function",
            "!span": "35228[1083:26]-35249[1083:47]",
            "!doc": "Create a function that invokes the given callback after the tolerance period\nhas passed since the last invocation of the function.\n\nThis is useful to defer responding to a stream of repetetive events until the\nend of the stream.\n\n@param {Function} callback\n         The function to be run once the tolerance period has passed.\n@param {Number} toleranceMillis\n         The tolerance duration in milliseconds.\n@returns {Function} The function to invoke in order to trigger a start/reset\n         of the tolerance period.\n@export"
          },
          "on": {
            "!type": "fn(element: <top>, eventName: string, handler: fn()|+Function, useCapture: ?, timeout: ?)",
            "!span": "37367[1136:26]-37369[1136:28]",
            "!doc": "Adds an event listener to a DOM element.\n\n@param {HTMLElement} element The DOM element to which to apply the listener.\n@param {String} eventName The name of the DOM event, minus the \"on\" prefix (e.g. \"click\", \"focus\", \"blur\", etc.).\n@param {Object} handler The JS handler to add.\n@param {Boolean} useCapture Whether to use event capturing.\n@param {Number} timeout Optional timeout (in milliseconds) that will delay the handler execution.\n@returns {Object} Either a function (success) or null (fail)\n@export"
          },
          "removeOn": {
            "!type": "fn(element: +Element, eventName: string, listener: ?, useCapture: bool)",
            "!span": "40317[1219:26]-40325[1219:34]",
            "!doc": "Removes an event listener from a DOM element. See also Util.on() a.k.a. $A.util.on()\n\n@param {HTMLElement} element The DOM element from which to remove the listener.\n@param {String} eventName The name of the DOM event, minus the \"on\" prefix (e.g. \"click\", \"focus\", \"blur\", etc.).\n@param {Function} listener The JS listener function to remove.\n@param {Boolean} useCapture Whether to use event capturing.\n@export"
          },
          "formToMap": {
            "!type": "fn(form: ?) -> Aura.Utils.Util.prototype.formToMap.!ret",
            "!span": "41113[1241:26]-41122[1241:35]",
            "!doc": "Stores the values of a form to a Map object. Values from a checkbox, radio, drop-down list, and textarea\nare stored in the Map.\n\n@param {Object} form\n@returns {Object} The map containing the values from the form input.\n@export"
          },
          "getSelectValue": {
            "!type": "fn(select: ?) -> [?|?]|?",
            "!span": "42547[1287:26]-42561[1287:40]",
            "!doc": "Gets the selected values from a list of options.\nReturns a single value if only a single option is selected.\n\n@param {Object} select\n@returns {Object} A list of selected options.\n@export"
          },
          "addValueToMap": {
            "!type": "fn(inputMap: Aura.Utils.Util.prototype.addValueToMap.!0, key: string, value: ?)",
            "!span": "43540[1318:26]-43553[1318:39]",
            "!doc": "Adds a value to a map with a given key.  If the key already exists, the values are turned into a list.\nIf the value has a dot in it - e.g. \"properties.4\" - it will be turned into an inner map, with\nthe second part as the inner key.\n\n@param {Object} inputMap The input map to be processed.\n@param {String} key The data key whose value is to be added to the input map.\n@param {Object} value The value of the data to add to the input map.\n@export"
          },
          "addMapValueToMap": {
            "!type": "fn(inputMap: Aura.Utils.Util.prototype.addMapValueToMap.!0, key: string, value: ?, subMapKey: string)",
            "!span": "44897[1358:26]-44913[1358:42]",
            "!doc": "Generates a map of values inside the main input map.  This is used, for example,\nWhen input fields have a \".\" operator, so\ninput name=\"def.def1\"\ninput name=\"def.def2\"\nget put in the input map under \"def\", as a map with \"def1\" and \"def2\" mapped to their values.\n\n@param {Object} inputMap The input map to be processed.\n@param {String} key The data key whose value is to be added to the input map.\n@param {Object} value The value of the data to add to the input map.\n@param {String} subMapKey\n@export"
          },
          "isSubDef": {
            "!type": "fn(def: ?, qname: string) -> bool",
            "!span": "45440[1377:26]-45448[1377:34]",
            "!doc": "Walks up a definition hierarchy to search for a sub definition by qualified name.\n\n@param {Object} def\n         The definition to search\n@param {String} qname\n         The qualified name to search for\n@returns {Boolean} true if qualified name is found in defs hierarchy\n@export"
          },
          "apply": {
            "!type": "fn(baseObject: [?]|?, members: ?, forceCopy: bool, deepCopy: bool)",
            "!span": "46974[1413:26]-46979[1413:31]",
            "!doc": "@description Takes the methods, and properties from one object and assigns them to another.\nReturns the base object with the members from the child object.\nThis is commonly used to apply a set of configurations to a default set, to get a single set of configuration properties.\n\n@example\n$A.util.apply(Child.prototype, Parent); // Returns a new object inheriting all the methods and properties from Parent.\n\n@example\n$A.util.apply(Child.prototype, { isCool: true }); // Parent would then have a property of child.\n\n@example\n$A.util.apply({ foo: 'bar', diameter: 10}, { diameter: 20, bat: 'man' }, true); //== {foo:'bar', diameter: 20, bat: 'man'}\n\n@example\n$A.util.apply({ foo: 'bar', diameter: 10}, { diameter: 20, bat: 'man' }, false); //== {foo:'bar', diameter: 10, bat: 'man'}\n\n@param {Object|Function} baseObject The object that will receive the methods, and properties.\n@param {Object|Function} members The methods and properties to assign to the baseObject.\n@param {Boolean} [forceCopy] If the property already exists, should we still copy the member? false by default\n@param {Boolean} [deepCopy] Should we continue to navigate child objects if we don't overwrite them? false by default"
          },
          "CAMEL_CASE_TO_HYPHENS_REGEX": {
            "!type": "+RegExp",
            "!span": "48104[1441:26]-48131[1441:53]"
          },
          "camelCaseToHyphens": {
            "!type": "fn(str: string) -> string",
            "!span": "48349[1449:26]-48367[1449:44]",
            "!doc": "Converts camelCase to hyphens.\n\n@param {String} str The string to be converted.\n@returns {String} The string containing hyphens that replaces the camelCase."
          },
          "hyphensToCamelCase": {
            "!type": "fn(str: string) -> string",
            "!span": "48637[1459:26]-48655[1459:44]",
            "!doc": "Converts hyphens to camelCase.\n\n@param {String} str The string to be converted.\n@returns {String} The string in camelCase."
          },
          "noData": {
            "embed": {
              "!type": "bool",
              "!span": "48977[1473:4]-48984[1473:11]"
            },
            "object": {
              "!type": "string",
              "!span": "48996[1474:4]-49004[1474:12]"
            },
            "applet": {
              "!type": "bool",
              "!span": "49065[1475:4]-49073[1475:12]"
            },
            "#text": {
              "!type": "bool",
              "!span": "49085[1476:4]-49092[1476:11]"
            },
            "!span": "48962[1472:26]-48968[1472:32]",
            "!doc": "@description A map of nodeNames that cannot accept custom data attributes.\n@private"
          },
          "acceptsData": {
            "!type": "fn(element: +Element) -> bool",
            "!span": "49388[1486:26]-49399[1486:37]",
            "!doc": "@description Returns whether a given DOM element can accept custom data attributes.\n\n@param {HTMLElement} element The element to check for custom data attribute support.\n@returns {Boolean} Whether element accepts custom data attributes."
          },
          "getElementAttributeValue": {
            "!type": "fn(element: +Element, attributeName: string) -> !0.<i>",
            "!span": "49962[1508:26]-49986[1508:50]",
            "!doc": "Return attributeValue of an element\n\n@param {HTMLElement} element The element from which to retrieve data.\n@param {String} attributeName The name of attribute to look up on element.\n@export"
          },
          "getDataAttribute": {
            "!type": "fn(element: +Element, key: string) -> string",
            "!span": "51222[1536:26]-51238[1536:42]",
            "!doc": "@description Returns a custom data attribute value from a DOM element.\nFor more information on custom data attributes, see http://html5doctor.com/html5-custom-data-attributes/\n@param {HTMLElement} element The element from which to retrieve data.\n@param {String} key The data key to look up on element.\n@export"
          },
          "setDataAttribute": {
            "!type": "fn(element: +Element, key: string, value: string)",
            "!span": "51941[1554:26]-51957[1554:42]",
            "!doc": "@description Sets a custom data attribute value from a DOM element.\nFor more information on custom data attributes, see http://html5doctor.com/html5-custom-data-attributes/\n@param {HTMLElement} element The element from which to retrieve data.\n@param {String} key The data key to add to element.\n@param {String} value The value of the data to add to an element. If value is undefined, the key data attribute will be removed from element.\n@export"
          },
          "getDataAttributeName": {
            "!type": "fn(key: string) -> string",
            "!span": "52309[1571:26]-52329[1571:46]",
            "!doc": "@private"
          },
          "hasDataAttribute": {
            "!type": "fn(element: +Element, key: string) -> bool",
            "!span": "52836[1588:26]-52852[1588:42]",
            "!doc": "Checks whether a custom data attribute value already exists.\n@param {HTMLElement} element The element from which to retrieve data.\n@param {String} key The data key to look up on element.\n@returns {Boolean} true if element has data attribute\n@export"
          },
          "isElement": {
            "!type": "fn(obj: +Element) -> !0",
            "!span": "53145[1597:26]-53154[1597:35]",
            "!doc": "Checks if the object is an HTML element.\n@param {Object} obj\n@returns {Boolean} True if the object is an HTMLElement object, or false otherwise."
          },
          "attachToDocumentBody": {
            "!type": "fn(element: ?)",
            "!span": "53473[1610:26]-53493[1610:46]",
            "!doc": "Attach the element to the HTML body\n@param {DOMElement} element\n@export"
          },
          "stringEndsWith": {
            "!type": "fn(fullstr: string, substr: string) -> bool",
            "!span": "53891[1623:26]-53905[1623:40]",
            "!doc": "Check for substrings at the end.\n@param {String} fullstr The string to check against.\n@param {String} substr The substring to look for at the end.\n@returns {Boolean} True if fullstr ends with substr.\n@export"
          },
          "lookup": {
            "!type": "fn(object: ?) -> ?",
            "!span": "56044[1684:26]-56050[1684:32]",
            "!doc": "Performs a series of 'safe' sequential lookup of nested properies.\n\nExample: a safe lookup for \"VALUE\" in: object: {\n   first: {\n      second: [\n          \"VALUE\"\n      ]\n   }\n}\n\nCan be done via: $A.util.lookup(object, \"first\", \"second\", 0);\nInstead of: object && object.first && object.first.second && object.first.second[0]\n\n@param {Object} root object or array to sequentially lookup properties from.\n@param {String} var-args of string property names.\n@return {Any} the looked-up property or undefined if any properties along the way were not found.\n@export"
          },
          "merge": {
            "!type": "fn(first: [Aura.Utils.Util.forEach.!0]) -> !0",
            "!span": "56713[1701:26]-56718[1701:31]",
            "!doc": "Does an in-place merge of any number of array into the first.\n@param {Array} array to receive the elements of subsequent arrays.\n@param {Array} var-args of arrays that will have their elements copied into the first.\n@returns {Array} the first array (which has been modified in-place).\n@export"
          },
          "destroyAsync": {
            "!type": "fn(cmp: +Component)",
            "!span": "65970[1950:26]-65982[1950:38]",
            "!doc": "Schedules the specified component to be asynchronously destroyed.\n@param {Component} cmp\n         The component to be destroyed.\n@private"
          },
          "instanceOf": {
            "!type": "fn(instance: ?, constructor: ?) -> bool",
            "!span": "67508[1992:26]-67518[1992:36]",
            "!doc": "Returns whether \"instance\" is, directly or indirectly, an instance of\n\"constructor.\"  An object is indirectly an instance if derivePrototypeFrom was\nused to make the child type derive from the parent type.\n\nJavaScript's instanceof operator is not used as it doesn't understand\ntype inheritance. Using this method would avoid the need for child.prototype to be\nan instance of parent; we also avoid having \"unbound\" instances.\n\n@param instance The object to test\n@param constructor  The object to test against\n@returns {Boolean} Returns true if instance is an instance of constructor.\n@export"
          },
          "emptyComponentTrash": {
            "!type": "fn()",
            "!span": "68185[2015:26]-68204[2015:45]",
            "!doc": "Destroys any components currently in the trashcan.\n@private"
          },
          "contains": {
            "!type": "fn(container: +Element, element: +Element) -> bool",
            "!span": "69065[2040:26]-69073[2040:34]",
            "!doc": "Determines if an element is either a descendant of, or the same as, another element in the DOM tree.\nBoth arguments to this function must be of type HTMLElement.\n\n@param {HTMLElement} container The element you think is the outermost container.\n@param {HTMLElement} element The element you think is buried inside the container.\n@returns {Boolean} Returns true if 'element' is indeed inside 'container', false otherwise.\n@export"
          },
          "squash": {
            "!type": "fn(event: ?, preventDefault: bool)",
            "!span": "69766[2065:26]-69772[2065:32]",
            "!doc": "Simple event squasher.\n\n@param {UIEvent} event the DOM event to squash\n@param {Boolean} preventDefault if preventDefault() should also be called\n@export"
          },
          "stripTags": {
            "!type": "fn(input: string, tags: [Aura.Utils.Util.prototype.stripTags.!1]) -> !0",
            "!span": "70355[2088:26]-70364[2088:35]",
            "!doc": "Strip off html tags from html codes.\n\n@param {String} input the input html codes\n@param {Array} tags the html tag names to be removed\n@return {String} an output string without those specified tags\n@export"
          },
          "getWindowSize": {
            "!type": "fn() -> ?",
            "!span": "71220[2118:26]-71233[2118:39]",
            "!doc": "Simple function to get client viewport dimensions. If neither window.innerWidth\nnor document.body.clientWidth is supported by the client, returns \"0\" for\nboth width and height.\n\n@return {Object} JS object with the fields \"width\" and \"height\"\n@export"
          },
          "isComponent": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "71644[2132:26]-71655[2132:37]",
            "!doc": "Checks if the object is an Aura component.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object type is a component, or return false otherwise.\n@export"
          },
          "isExpression": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "71948[2143:26]-71960[2143:38]",
            "!doc": "Checks if the object is an Aura value expression.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object type is an expression, or false otherwise.\n@export"
          },
          "isValue": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "72341[2154:26]-72348[2154:33]",
            "!doc": "Checks if the object is an Aura value object.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object type is an Aura value (PropertyReferenceValue, FunctionCallValue, PassthroughValue).\n@export"
          },
          "isAction": {
            "!type": "fn(obj: ?) -> bool",
            "!span": "72711[2166:26]-72719[2166:34]",
            "!doc": "Checks if the object is an Aura action object.\n\n@param {Object} obj The object to check for.\n@returns {Boolean} True if the object type is an Aura Action.\n@export"
          },
          "supportsTouchEvents": {
            "!type": "fn() -> !this.supportsTouchEvents.cache",
            "!span": "72961[2176:26]-72980[2176:45]",
            "!doc": "Checks if touch events are supported. Cache the result, it shouldn't change.\n\n@returns {Boolean} True if touch events are supported.\n@export"
          },
          "estimateSize": {
            "!type": "fn(obj: string|Action.prototype.getStored.!ret) -> number",
            "!span": "74941[2214:26]-74953[2214:38]",
            "!doc": "Estimate the size of an object or primitive in bytes.\n\n@param {Object} item The object or primitive whose size to estimate.\n@return {Number} The estimated size of the item in bytes.\n@export"
          },
          "toArray": {
            "!type": "fn(collection: [fn()]|+NodeList) -> [!0.length]",
            "!span": "75385[2225:26]-75392[2225:33]",
            "!doc": "Convert collection to a true array.\nWhen dealing with a NodeList, sometimes you'll need it to actually be an array to properly deal with it.\nCannot always use Array.prototype.slice.call(), since it doesn't work in IE6/7/8 on NodeLists.\n@returns An empty array if you pass a null or undefined value to collection."
          },
          "setText": {
            "!type": "fn(node: Aura.Utils.Util.prototype.setText.!0, text: ?)",
            "!span": "76013[2245:26]-76020[2245:33]",
            "!doc": "@export"
          },
          "getDebugToolComponent": {
            "!type": "fn() -> ?",
            "!span": "76545[2261:30]-76566[2261:51]",
            "!doc": "Gets the aura debug tool component whether in an iframe or not.\n@returns {Object} The debug tool component.\n@export"
          },
          "getDebugToolsAuraInstance": {
            "!type": "fn() -> !this.debugToolWindow.aura",
            "!span": "77126[2276:30]-77151[2276:55]",
            "!doc": "Gets the aura instance of debug tool which has been opened in a child window\n\n@returns {Object} Aura instance\n@export"
          },
          "setDebugToolWindow": {
            "!type": "fn(debugWindow: ?)",
            "!span": "77457[2288:30]-77475[2288:48]",
            "!doc": "Set the aura debug tool handle when opened in a popup.\n@export"
          },
          "getUrl": {
            "!type": "fn() -> string",
            "!span": "77805[2300:30]-77811[2300:36]",
            "!doc": "Grab windows url, if debug tool is a child window get url of parent\n\n@returns {String} URL of the window\n@export"
          },
          "getText": {
            "!type": "fn(node: +Node) -> !0.textContent",
            "!span": "78408[2315:30]-78415[2315:37]",
            "!doc": "Get the text content of a DOM node. Tries <code>textContent</code> followed by\n<code>innerText</code>, followed by <code>nodeValue</code> to take browser differences into account.\n@param {Node} node The node to get the text content from\n@returns {String} The text content of the DOM node or empty string if unable to extract text\n@export"
          },
          "includeScript": {
            "!type": "fn(url: string, callback: +Function)",
            "!span": "79365[2344:30]-79378[2344:43]",
            "!doc": "Loads a JavaScript resource.\n@param {String} url The URL of the JavaScript resource to load.\n@param {Function} callback Callback function that is invoked when the resource is loaded.\n@export"
          },
          "sanitizeHtml": "Aura.Utils.SecureFilters.html",
          "sanitizeJs": "Aura.Utils.SecureFilters.js",
          "sanitizeJsAttr": "Aura.Utils.SecureFilters.jsAttr",
          "sanitizeUri": "Aura.Utils.SecureFilters.uri",
          "sanitizeJsObj": "Aura.Utils.SecureFilters.jsObj",
          "sanitizeCSS": "Aura.Utils.SecureFilters.css",
          "sanitizeStyle": "Aura.Utils.SecureFilters.style",
          "bind": "Aura.Utils.Util.bind",
          "forEach": "Aura.Utils.Util.forEach",
          "map": "Aura.Utils.Util.map",
          "reduce": "Aura.Utils.Util.reduce",
          "every": "Aura.Utils.Util.every",
          "some": "Aura.Utils.Util.some",
          "filter": {},
          "isEmpty": "ExpressionFunctions.prototype.empty"
        },
        "bind": {
          "!type": "fn(method: ?) -> !0",
          "!span": "54433[1636:20]-54437[1636:24]",
          "!doc": "@export"
        },
        "forEach": {
          "!type": "fn(array: [[Aura.Utils.Util.forEach.!0]], method: fn(array: [Aura.Utils.Util.forEach.!0]), that: ?)",
          "!span": "57534[1730:20]-57541[1730:27]",
          "!doc": "Runs a function over each element in an array.\n@param {Array} array to loop over.\n@param {Function} method to call for each element.\n@param {Any} the 'this' instance inside the scope of provided method."
        },
        "map": {
          "!type": "fn(array: [?], method: ?, that: ?) -> [?]",
          "!span": "58662[1763:20]-58665[1763:23]",
          "!doc": "Returns an array containing the return value of the provided function over every element of the input array.\n@param {Array} array to loop over.\n@param {Function} tranforms an element from the input array to an element in the output array.\n@param {Any} the 'this' instance inside the scope of provided transformation method.\n@returns {Array} where every element is a result of the transformation function\napplied to the element (at the same index) from the input array."
        },
        "reduce": {
          "!type": "fn(array: [?], method: fn(current: ?, property: ?) -> !0, initial: ?)",
          "!span": "60103[1798:20]-60109[1798:26]",
          "!doc": "Loops over an array, calling a function that provides the returned result of calling the function on the\nprevious element.\n@param {Array} array to loop over.\n@param {Function} reduction method that takes the resturned result from the previous call, the current element from\nthe input array and index.\n@param {Any} the initial object passed to the first element in the array's reduction method.\n@returns {Any} the final value returned from calling the reduction method on the last element."
        },
        "every": {
          "!type": "fn(array: [?], predicate: +Function, that: ?) -> bool",
          "!span": "61609[1835:20]-61614[1835:25]",
          "!doc": "Loops over an array, calling a function that returns some boolean. Returns true if all calls return a truthy result.\n@param {Array} array to loop over.\n@param {Function} predicate that returns a boolean result based on the current array element.\n@param {Any} the 'this' instance inside the scope of provided transformation method.\n@returns {Boolean} true if all elements of the array satisfy the predicate."
        },
        "some": {
          "!type": "fn(array: [?], predicate: +Function, that: ?) -> bool",
          "!span": "63030[1872:20]-63034[1872:24]",
          "!doc": "Loops over an array, calling a function that returns some boolean. Returns true if any calls return a truthy result.\n@param {Array} array to loop over.\n@param {Function} predicate that returns a boolean result based on the current array element.\n@param {Any} the 'this' instance inside the scope of provided transformation method.\n@returns {Boolean} true if any of the elements of the array satisfy the predicate."
        },
        "filter": {
          "!type": "fn(array: [+Aura.Services.AuraClientService$AuraXHR], predicate: fn(resource: +Aura.Services.AuraClientService$AuraXHR) -> bool, that: +AuraClientService) -> [?]",
          "!span": "64454[1909:20]-64460[1909:26]",
          "!doc": "Loops over an array, constructing a new array with the elements that pass the filter predicate.\n@param {Function} predicate that returns a boolean result based on the current array element the result of which\n                  indicates whether the element will be returned in the filter result array.\n@param {Any} the 'this' instance inside the scope of provided predicate.\n@returns {Array} ordered array of elements that pass the predicate."
        },
        "!type": "fn()",
        "!span": "861[26:11]-865[26:15]",
        "!doc": "@description\nUtil methods provide utility functions for browsers in addition to\nfunctions for retrieving, manipulating, or checking DOM elements.\n@constructor\n@platform\n@export",
        "trashcan": {
          "!type": "+DocumentFragment",
          "!span": "895[27:9]-903[27:17]"
        },
        "trash": {
          "!type": "[+Node|+Node]",
          "!span": "950[28:9]-955[28:14]"
        },
        "json": {
          "!type": "+Json",
          "!span": "971[29:9]-975[29:13]"
        },
        "trashedComponentQueue": {
          "!type": "[+Component]",
          "!span": "1244[36:9]-1265[36:30]"
        },
        "dataAttributeCache": {
          "<i>": {
            "!type": "string",
            "!span": "52497[1575:32]-52500[1575:35]"
          },
          "!span": "1281[37:9]-1299[37:27]"
        },
        "sizeEstimator": {
          "!type": "+SizeEstimator",
          "!span": "1353[39:9]-1366[39:22]"
        },
        "Mutex": {
          "!type": "+Aura.Utils.Mutex",
          "!span": "1410[40:9]-1415[40:14]"
        },
        "localStorageEnabled": {
          "!type": "bool",
          "!span": "2047[61:13]-2066[61:32]"
        },
        "_isIOSWebView": {
          "!type": "bool",
          "!span": "2729[85:13]-2742[85:26]"
        },
        "gcPending": {
          "!type": "bool",
          "!span": "28710[889:17]-28719[889:26]"
        },
        "componentGCPending": {
          "!type": "bool",
          "!span": "66399[1961:17]-66417[1961:35]"
        },
        "componentGCProcessing": {
          "!type": "bool",
          "!span": "66626[1967:24]-66647[1967:45]"
        }
      },
      "!span": "1279[36:5]-1284[36:10]",
      "!doc": "-- Namespaces ------------------------------------------------------------",
      "Logger": {
        "prototype": {
          "info": "Logger.prototype.info",
          "warning": "Logger.prototype.warning",
          "assert": "Logger.prototype.assert",
          "error": "Logger.prototype.error",
          "reportError": "Logger.prototype.reportError",
          "log": "Logger.prototype.log",
          "notify": "Logger.prototype.notify",
          "getStackTrace": "Logger.prototype.getStackTrace",
          "stringVersion": "Logger.prototype.stringVersion",
          "subscribe": "Logger.prototype.subscribe",
          "unsubscribe": "Logger.prototype.unsubscribe",
          "adjustSubscriptions": "Logger.prototype.adjustSubscriptions",
          "isValidSubscriber": "Logger.prototype.isValidSubscriber",
          "isValidLevel": "Logger.prototype.isValidLevel",
          "hasSubscriptions": "Logger.prototype.hasSubscriptions",
          "devDebugConsoleLog": "Logger.prototype.devDebugConsoleLog"
        }
      }
    },
    "Errors": {
      "AuraFriendlyError": {
        "prototype": {
          "name": {
            "!type": "string",
            "!span": "1031[26:9]-1035[26:13]"
          },
          "message": {
            "!type": "string",
            "!span": "1066[27:9]-1073[27:16]"
          },
          "stackTrace": {
            "!type": "string",
            "!span": "1092[28:9]-1102[28:19]"
          },
          "component": {
            "!type": "string",
            "!span": "1188[32:9]-1197[32:18]",
            "!doc": "keep the root cause failing descriptor"
          },
          "action": {
            "length": {
              "!type": "number",
              "!span": "66402[176:60899]-66408[176:60905]"
            },
            "marker": {
              "!type": "number",
              "!span": "66474[176:60971]-66480[176:60977]"
            },
            "request": "+XMLHttpRequest"
          },
          "id": {
            "!type": "string",
            "!span": "1301[38:9]-1303[38:11]",
            "!doc": "client side error id"
          },
          "handled": {
            "!type": "bool",
            "!span": "3962[111:9]-3971[111:18]"
          },
          "reported": {
            "!type": "bool",
            "!span": "3991[112:9]-4001[112:19]"
          },
          "constructor": "AuraInstance.auraFriendlyError",
          "toString": "AuraInstance.lastKnownError.toString"
        }
      },
      "name": {
        "!type": "string",
        "!span": "1136[27:9]-1140[27:13]"
      },
      "!span": "1301[37:5]-1307[37:11]",
      "AuraError": {
        "prototype": {
          "constructor": "AuraError",
          "toString": "AuraError.prototype.toString"
        }
      }
    },
    "Context": {
      "AuraContext": {
        "prototype": {
          "initGlobalValueProviders": {
            "!type": "fn(gvps: ?, callback: +Function)",
            "!span": "4411[118:35]-4435[118:59]",
            "!doc": "Temporary shim, until W-2812858 is addressed to serialize GVPs as a map and fix $A GVPs.\nConvert config GVPs from array to map, and merge $A GVPs, and create the context GVPs.\n@export"
          },
          "getMode": {
            "!type": "fn() -> !this.mode",
            "!span": "5249[149:35]-5256[149:42]",
            "!doc": "Returns the mode for the current request. Defaults to \"PROD\" for production mode and \"DEV\" for development mode.\nThe HTTP request format is <code>http://<your server>/namespace/component?aura.mode=PROD</code>.\n\n@return {string} the mode from the server.\n@export"
          },
          "getCurrentAccess": {
            "!type": "fn() -> !this.accessStack.<i>",
            "!span": "5333[153:35]-5349[153:51]"
          },
          "getCurrentAccessCaller": {
            "!type": "fn() -> !this.accessStack.<i>",
            "!span": "5457[157:35]-5479[157:57]"
          },
          "setCurrentAccess": {
            "!type": "fn(component: ?)",
            "!span": "5587[161:35]-5603[161:51]"
          },
          "releaseCurrentAccess": {
            "!type": "fn()",
            "!span": "5923[174:35]-5943[174:55]"
          },
          "getAccessVersion": {
            "!type": "fn(name: ?) -> Component.valueProviders.<i>",
            "!span": "6023[178:35]-6039[178:51]"
          },
          "getTokens": {
            "!type": "fn() -> !this.tokens",
            "!span": "6821[204:35]-6830[204:44]",
            "!doc": "Gets the application configuration tokens allowed to be used in component markup.\n@private"
          },
          "setTokens": {
            "!type": "fn(tokens: ?)",
            "!span": "7082[213:35]-7091[213:44]",
            "!doc": "Sets the application configuration tokens allowed to be used in component markup.\n@param tokens The object map containing name value pairs of tokens.\n@private"
          },
          "addGlobalValueProvider": {
            "!type": "fn(type: string, valueProvider: ?)",
            "!span": "7334[223:35]-7356[223:57]",
            "!doc": "Adds a new global value provider.\n@param type The key to identify the valueProvider.\n@param valueProvider The valueProvider to add.\n@private"
          },
          "getGlobalValueProvider": {
            "!type": "fn(type: string) -> AuraInstance.context.contextGlobals",
            "!span": "7699[234:35]-7721[234:57]",
            "!doc": "Provides access to global value providers.\nFor example, <code>$A.get(\"$Label.Related_Lists.task_mode_today\");</code> gets the label value.\n\n@return {GlobalValueProviders}\n@private"
          },
          "encodeForServer": {
            "!type": "fn(includeDynamic: bool) -> string",
            "!span": "8043[246:35]-8058[246:50]",
            "!doc": "JSON representation of context for server requests.\n\nThis must remain in sync with AuraTestingUtil so that we can accurately test.\n\n@return {String} json representation\n@private"
          },
          "merge": {
            "!type": "fn(otherContext: ?)",
            "!span": "8824[271:35]-8829[271:40]",
            "!doc": "@param {Object} otherContext the context from the server to join in to this one.\n@export"
          },
          "getNum": {
            "!type": "fn() -> !this.num",
            "!span": "10680[327:35]-10686[327:41]",
            "!doc": "FIXME: this should return a string, and it should probably not even be here.\n\n@return {number} the 'num' for this context\n@private\n@export"
          },
          "incrementNum": {
            "!type": "fn() -> !this.num",
            "!span": "10782[334:35]-10794[334:47]",
            "!doc": "@private"
          },
          "incrementRender": {
            "!type": "fn() -> !this.renderNum",
            "!span": "10946[343:35]-10961[343:50]",
            "!doc": "@private"
          },
          "incrementTransaction": {
            "!type": "fn() -> !this.transaction",
            "!span": "11166[353:35]-11186[353:55]",
            "!doc": "@return {Number} incremented transaction number\n@private\n@export"
          },
          "getTransaction": {
            "!type": "fn() -> !this.transaction",
            "!span": "11398[362:35]-11412[362:49]",
            "!doc": "@return {Number} gets the number of the current transaction\n@private"
          },
          "updateTransactionName": {
            "!type": "fn(_transactionName: ?)",
            "!span": "11516[369:35]-11537[369:56]",
            "!doc": "@private"
          },
          "getTransactionName": {
            "!type": "fn() -> !this.transactionName",
            "!span": "11846[379:35]-11864[379:53]",
            "!doc": "@return {String} gets the name of the transaction\n@private"
          },
          "clearTransactionName": {
            "!type": "fn()",
            "!span": "11972[386:35]-11992[386:55]",
            "!doc": "@private"
          },
          "getNextGlobalId": {
            "!type": "fn() -> !this.lastGlobalId",
            "!span": "12133[394:35]-12148[394:50]",
            "!doc": "@return {Number} Next global ID\n@private"
          },
          "containsComponentConfig": {
            "!type": "fn(creationPath: string) -> bool",
            "!span": "12459[405:35]-12482[405:58]",
            "!doc": "Returns components configs object\n@param {String} creationPath creation path to check\n@return {Boolean} Whether creation path is in component configs\n@private"
          },
          "getComponentConfig": {
            "!type": "fn(creationPath: string)",
            "!span": "12694[413:35]-12712[413:53]",
            "!doc": "@param {string} creationPath the creation path to look up.\n@private"
          },
          "removeComponentConfig": {
            "!type": "fn(creationPath: string)",
            "!span": "13148[425:35]-13169[425:56]",
            "!doc": "When we have consumed the component config from the context, its worth removing it to narrow down\nthe list of pending configs left to handle.\n@param {String} creationPath is the components creationPath that we are operating on.\n@private"
          },
          "getApp": {
            "!type": "fn() -> !this.app",
            "!span": "13409[435:35]-13415[435:41]",
            "!doc": "Returns the app associated with the request.\n@export"
          },
          "joinComponentConfigs": {
            "!type": "fn(otherComponentConfigs: ?, actionId: string)",
            "!span": "13724[446:35]-13744[446:55]",
            "!doc": "@param {Object}\n     otherComponentConfigs the component configs from the server to join in.\n@param {string}\n     actionId the id of the action that we are joining in (used to amend the creationPath).\n@private"
          },
          "internalClear": {
            "!type": "fn(actionId: string, logit: bool) -> number",
            "!span": "14578[469:35]-14591[469:48]",
            "!doc": "Internal routine to clear out component configs to factor out common code.\n\n@param {string} actionId the action id that we should clear.\n@param {boolean} logit should we log as we go? including errors.\n@return {number} the count of component configs removed.\n@private"
          },
          "finishComponentConfigs": {
            "!type": "fn(actionId: string)",
            "!span": "16162[519:35]-16184[519:57]",
            "!doc": "finish off the component configs for an action.\n\nThis routine looks through all of the pending component configs, and\nflags any that are un-consumed at the end of the action. This is a\nrelatively strict enforcement, but since we have all of the partial\nconfigs to create the components, it is not clear why we would leave\nthem lying around.\n\nThe Rule: You must consume component configs in the action callback.\nyou may _not_ delay creating components.\n\n@param {string} actionId the action id that we should clear.\n@private"
          },
          "clearComponentConfigs": {
            "!type": "fn(actionId: string) -> number",
            "!span": "16682[535:35]-16703[535:56]",
            "!doc": "Clear out pending component configs.\n\nThis routine can be used in error conditions (or in tests) to clear out\nconfigs left over by an action. In this case, we remove them, and drop\nthem on the floor to be garbage collected.\n\n@public\n@param {string} actionId the action id that we should clear.\n@return {number} the count of component configs removed.\n@export"
          },
          "joinLoaded": {
            "!type": "fn(loaded: ?)",
            "!span": "16834[542:35]-16844[542:45]",
            "!doc": "@private"
          },
          "addLoaded": {
            "!type": "fn(pair: ?)",
            "!span": "17483[566:35]-17492[566:44]",
            "!doc": "Add back a loaded pair that was extracted using 'findLoaded'.\n\n@param {Object} pair the object returned by findLoaded.\n@private"
          },
          "findLoaded": {
            "!type": "fn(descriptor: string) -> ?",
            "!span": "17900[580:35]-17910[580:45]",
            "!doc": "Find a 'loaded' pair for a descriptor.\n\n@param {String} descriptor the descriptor string.\n@returns {Object} an object that can be passed to addloaded.\n@private"
          },
          "getLoaded": {
            "!type": "fn() -> !this.loaded",
            "!span": "18448[597:35]-18457[597:44]",
            "!doc": "This should be private but is needed for testing... ideas?\n\n... should move to $A.test.\n@export"
          },
          "resetLoaded": {
            "!type": "fn()",
            "!span": "18601[604:35]-18612[604:46]",
            "!doc": "Reset the loaded set to its original value at launch."
          },
          "setCurrentAction": {
            "!type": "fn(action: ?) -> !this.currentAction",
            "!span": "18824[612:35]-18840[612:51]",
            "!doc": "DCHASMAN Will be private again soon as part of the second phase of W-1450251\n@export"
          },
          "getCurrentAction": {
            "!type": "fn() -> !this.currentAction",
            "!span": "19184[624:35]-19200[624:51]",
            "!doc": "EBA - temporarily made public for helpers to obtain action - return to private when current visibility is determined\n@public\n@return {Action} the current action.\n@export"
          },
          "getContextPath": {
            "!type": "fn() -> !this.contextPath",
            "!span": "19403[635:35]-19417[635:49]",
            "!doc": "Servlet container context path\n@return {String} Servlet container context path\n@private\n@export"
          },
          "setContextPath": {
            "!type": "fn(path: ?)",
            "!span": "19516[640:35]-19530[640:49]",
            "!doc": "@export"
          }
        },
        "CLIENT_SESSION_ID": {
          "!type": "string",
          "!span": "3967[107:25]-3984[107:42]",
          "!doc": "Unique id for the current instance of Aura. In a multi-tab scenario\neach tab will have a unique id."
        },
        "!type": "fn(config: ?, initCallback: fn(context: AuraInstance.context)|+Function)",
        "!span": "1145[26:13]-1156[26:24]",
        "!doc": "@description Represents a Aura client-side context, created during HTTP requests for component definitions. A context\n           can include a mode, such as \"DEV\" for development mode or \"PROD\" for production mode.\n@constructor\n@protected\n@class AuraContext\n@param {Object} config the 'founding' config for the context from the server.\n@param {Function} initCallback an optional callback invoked after the config has finished its asynchronous initialization.\n@export",
        "loaded": {
          "!span": "1245[28:9]-1251[28:15]"
        },
        "num": {
          "!type": "number",
          "!span": "1504[37:9]-1507[37:12]"
        },
        "renderNum": {
          "!type": "number",
          "!span": "1573[40:9]-1582[40:18]",
          "!doc": "To keep track of re-rendering service call"
        },
        "transaction": {
          "!type": "number",
          "!span": "1597[41:9]-1608[41:20]"
        },
        "transactionName": {
          "!type": "string",
          "!span": "1623[42:9]-1638[42:24]"
        },
        "lastGlobalId": {
          "!type": "number",
          "!span": "1654[43:9]-1666[43:21]"
        },
        "componentConfigs": {
          "!span": "1681[44:9]-1697[44:25]"
        },
        "contextPath": {
          "!type": "string",
          "!span": "1805[48:9]-1816[48:20]"
        },
        "enableAccessChecks": {
          "!type": "bool",
          "!span": "1947[51:9]-1965[51:27]"
        },
        "isLockerServiceEnabled": {
          "!type": "bool",
          "!span": "2009[52:37]-2033[52:61]"
        },
        "logAccessFailures": {
          "!type": "bool",
          "!span": "2109[55:9]-2126[55:26]",
          "!doc": "JBUCH: TOGGLE LOGGING OFF BY DEFAULT IN PROD MODE"
        },
        "accessStack": {
          "!type": "[?]",
          "!span": "2307[60:9]-2318[60:20]"
        }
      },
      "!span": "1323[38:5]-1330[38:12]"
    },
    "System": {
      "DefDescriptor": {
        "DESCRIPTOR": {
          "!type": "string",
          "!span": "1438[35:14]-1448[35:24]",
          "!doc": "Static Members"
        },
        "prototype": {
          "getQualifiedName": "DefDescriptor.prototype.getQualifiedName",
          "getNamespace": "DefDescriptor.prototype.getNamespace",
          "getName": "DefDescriptor.prototype.getName",
          "getPrefix": "DefDescriptor.prototype.getPrefix",
          "toString": "DefDescriptor.prototype.toString"
        },
        "normalize": "DefDescriptor.normalize"
      },
      "!span": "1345[39:5]-1351[39:11]"
    },
    "Style": {
      "!span": "1367[40:5]-1372[40:10]",
      "StyleDef": {
        "prototype": {
          "apply": "StyleDef.prototype.apply",
          "remove": "StyleDef.prototype.remove",
          "getClassName": "StyleDef.prototype.getClassName",
          "getDescriptor": "StyleDef.prototype.getDescriptor",
          "isPreloaded": "StyleDef.prototype.isPreloaded"
        }
      }
    },
    "Flavors": {
      "!span": "1389[41:5]-1396[41:12]",
      "FlavorDefaultDef": {
        "prototype": {
          "getFlavor": "FlavorDefaultDef.prototype.getFlavor",
          "isContextual": "FlavorDefaultDef.prototype.isContextual"
        }
      },
      "FlavorsDef": {
        "prototype": {
          "getFlavor": "FlavorsDef.prototype.getFlavor"
        }
      }
    },
    "Value": {
      "PropertyReferenceValue": {
        "prototype": {
          "addChangeHandler": {},
          "evaluate": "PropertyReferenceValue.prototype.evaluate",
          "set": "PropertyReferenceValue.prototype.set",
          "removeChangeHandler": "PropertyReferenceValue.prototype.removeChangeHandler",
          "getExpression": "PropertyReferenceValue.prototype.getExpression",
          "getReference": "PropertyReferenceValue.prototype.getReference",
          "equals": "PropertyReferenceValue.prototype.equals",
          "isDirty": "PropertyReferenceValue.prototype.isDirty",
          "destroy": "PropertyReferenceValue.prototype.destroy",
          "toString": "PropertyReferenceValue.prototype.toString",
          "toJSON": "PropertyReferenceValue.prototype.toJSON"
        }
      },
      "ValueFactory": {
        "nextId": {
          "!type": "number",
          "!span": "2512[57:5]-2518[57:11]"
        },
        "getIndex": {},
        "valueIndex": {
          "<i>": "valueFactory.valueIndex"
        },
        "create": "valueFactory.create",
        "index": "valueFactory.index",
        "clearIndex": "valueFactory.clearIndex",
        "deIndex": "valueFactory.deIndex"
      },
      "!span": "1411[42:5]-1416[42:10]",
      "ExpressionFunctions": {
        "prototype": {
          "empty": "ExpressionFunctions.prototype.empty",
          "eq": "ExpressionFunctions.prototype.eq",
          "ne": "ExpressionFunctions.prototype.ne",
          "add": "ExpressionFunctions.prototype.add",
          "format": "ExpressionFunctions.prototype.format",
          "token": "ExpressionFunctions.prototype.token",
          "join": "ExpressionFunctions.prototype.join"
        }
      },
      "FunctionCallValue": {
        "prototype": {
          "expressionFunctions": "+ExpressionFunctions",
          "isDirty": "FunctionCallValue.prototype.isDirty",
          "evaluate": "FunctionCallValue.prototype.evaluate",
          "addChangeHandler": "FunctionCallValue.prototype.addChangeHandler",
          "getChangeHandler": "FunctionCallValue.prototype.getChangeHandler",
          "removeChangeHandler": "FunctionCallValue.prototype.removeChangeHandler",
          "destroy": "FunctionCallValue.prototype.destroy",
          "toString": "FunctionCallValue.prototype.toString"
        }
      }
    },
    "Model": {
      "ValueDef": {
        "prototype": {
          "getName": "ValueDef.prototype.getName"
        }
      },
      "!span": "1433[43:5]-1438[43:10]",
      "Model": {
        "prototype": {
          "get": "Model.prototype.get",
          "set": "Model.prototype.set",
          "destroy": "Model.prototype.destroy"
        }
      },
      "ModelDef": {
        "prototype": {
          "getDescriptor": "ModelDef.prototype.getDescriptor",
          "newInstance": "ModelDef.prototype.newInstance",
          "getMembers": "ModelDef.prototype.getMembers"
        }
      }
    },
    "Component": {
      "Component": {
        "currentComponentId": {
          "!type": "number",
          "!span": "6406[180:10]-6424[180:28]"
        },
        "prototype": {
          "toJSON": {},
          "getHandledEvents": {},
          "index": {},
          "findInstancesOf": {},
          "addValueHandler": {},
          "getFacets": {},
          "createComponentStack": {},
          "getActionCaller": {},
          "getEventDispatcher": {},
          "provide": {},
          "createActionValueProvider": {},
          "nextGlobalId": "Component.prototype.nextGlobalId",
          "setupGlobalId": "Component.prototype.setupGlobalId",
          "getName": "Component.prototype.getName",
          "getDef": "Component.prototype.getDef",
          "deIndex": "Component.prototype.deIndex",
          "find": "Component.prototype.find",
          "getSuperest": "Component.prototype.getSuperest",
          "findInstanceOf": "Component.prototype.findInstanceOf",
          "isInstanceOf": "Component.prototype.isInstanceOf",
          "implementsDirectly": "Component.prototype.implementsDirectly",
          "addHandler": {},
          "removeValueHandler": "Component.prototype.removeValueHandler",
          "addDocumentLevelHandler": "Component.prototype.addDocumentLevelHandler",
          "removeDocumentLevelHandler": "Component.prototype.removeDocumentLevelHandler",
          "finishDestroy": "Component.prototype.finishDestroy",
          "destroy": "Component.prototype.destroy",
          "isRenderedAndValid": "Component.prototype.isRenderedAndValid",
          "superRender": "Component.prototype.superRender",
          "superAfterRender": "Component.prototype.superAfterRender",
          "superRerender": "Component.prototype.superRerender",
          "superUnrender": "Component.prototype.superUnrender",
          "isRendered": "Component.prototype.isRendered",
          "setUnrendering": "Component.prototype.setUnrendering",
          "isUnrendering": "Component.prototype.isUnrendering",
          "setRendered": "Component.prototype.setRendered",
          "getRenderer": "Component.prototype.getRenderer",
          "getRenderable": "Component.prototype.getRenderable",
          "getGlobalId": "Component.prototype.getGlobalId",
          "getLocalId": "Component.prototype.getLocalId",
          "getRendering": "Component.prototype.getRendering",
          "getSuper": "Component.prototype.getSuper",
          "associateElement": "Component.prototype.associateElement",
          "disassociateElements": "Component.prototype.disassociateElements",
          "getElements": "Component.prototype.getElements",
          "getElement": "Component.prototype.getElement",
          "getReference": "Component.prototype.getReference",
          "clearReference": "Component.prototype.clearReference",
          "get": "Component.prototype.get",
          "getShadowAttribute": "Component.prototype.getShadowAttribute",
          "set": "Component.prototype.set",
          "setShadowAttribute": "Component.prototype.setShadowAttribute",
          "markDirty": "Component.prototype.markDirty",
          "markClean": "Component.prototype.markClean",
          "fireChangeEvent": "Component.prototype.fireChangeEvent",
          "autoDestroy": "Component.prototype.autoDestroy",
          "getConcreteComponent": "Component.prototype.getConcreteComponent",
          "isConcrete": "Component.prototype.isConcrete",
          "getAttributeValueProvider": "Component.prototype.getAttributeValueProvider",
          "setAttributeValueProvider": "Component.prototype.setAttributeValueProvider",
          "getComponentValueProvider": "Component.prototype.getComponentValueProvider",
          "getOwner": "Component.prototype.getOwner",
          "addValueProvider": "Component.prototype.addValueProvider",
          "removeValueProvider": "Component.prototype.removeValueProvider",
          "getModel": "Component.prototype.getModel",
          "getEvent": "Component.prototype.getEvent",
          "getEventByDescriptor": "Component.prototype.getEventByDescriptor",
          "fire": "Component.prototype.fire",
          "isDirty": "Component.prototype.isDirty",
          "isValid": "Component.prototype.isValid",
          "toString": "Component.prototype.toString",
          "hasEventHandler": "Component.prototype.hasEventHandler",
          "isFlavorable": "Component.prototype.isFlavorable",
          "getFlavor": "Component.prototype.getFlavor",
          "render": "Component.prototype.render",
          "afterRender": "Component.prototype.afterRender",
          "rerender": "Component.prototype.rerender",
          "unrender": "Component.prototype.unrender",
          "getVersion": "Component.prototype.getVersion",
          "getVersionInternal": "Component.prototype.getVersionInternal",
          "getValueProvider": "Component.prototype.getValueProvider",
          "setupValueProviders": "Component.prototype.setupValueProviders",
          "createStyleValueProvider": {},
          "setupComponentDef": "Component.prototype.setupComponentDef",
          "setupSuper": "Component.prototype.setupSuper",
          "setSuperComponent": "Component.prototype.setSuperComponent",
          "setupAttributes": "Component.prototype.setupAttributes",
          "validatePartialConfig": "Component.prototype.validatePartialConfig",
          "getMethodHandler": "Component.prototype.getMethodHandler",
          "setupComponentEvents": "Component.prototype.setupComponentEvents",
          "getHandler": "Component.prototype.getHandler",
          "setupApplicationEventHandlers": "Component.prototype.setupApplicationEventHandlers",
          "setupValueEventHandlers": "Component.prototype.setupValueEventHandlers",
          "setupMethods": "Component.prototype.setupMethods",
          "setupModel": "Component.prototype.setupModel",
          "setupFlavors": "Component.prototype.setupFlavors",
          "doIndex": "Component.prototype.doIndex",
          "doDeIndex": "Component.prototype.doDeIndex",
          "replaceComponentClass": "Component.prototype.replaceComponentClass",
          "injectComponent": "Component.prototype.injectComponent",
          "setProvided": "Component.prototype.setProvided",
          "associateRenderedBy": "Component.prototype.associateRenderedBy",
          "_$getSelfGlobalId$": "Component.prototype._$getSelfGlobalId$",
          "_$getRawValue$": "Component.prototype._$getRawValue$"
        }
      },
      "ComponentDef": {
        "valueEvents": {
          "change": {
            "!type": "string",
            "!span": "13378[436:4]-13386[436:12]"
          },
          "init": {
            "!type": "string",
            "!span": "13413[437:4]-13419[437:10]"
          },
          "destroy": {
            "!type": "string",
            "!span": "13444[438:4]-13453[438:13]"
          }
        },
        "prototype": {
          "getAllStyleDefs": {},
          "getAllFlavoredStyleDefs": {},
          "getDynamicallyFlavorable": {},
          "getDescriptor": "ComponentDef.prototype.getDescriptor",
          "isAbstract": "ComponentDef.prototype.isAbstract",
          "getSuperDef": "ComponentDef.prototype.getSuperDef",
          "getHelper": "ComponentDef.prototype.getHelper",
          "getRequiredVersionDefs": "ComponentDef.prototype.getRequiredVersionDefs",
          "hasRemoteDependencies": "ComponentDef.prototype.hasRemoteDependencies",
          "getStyleClassName": "ComponentDef.prototype.getStyleClassName",
          "getStyleDef": "ComponentDef.prototype.getStyleDef",
          "getDefaultFlavor": "ComponentDef.prototype.getDefaultFlavor",
          "getExplicitDefaultFlavor": "ComponentDef.prototype.getExplicitDefaultFlavor",
          "hasFlavorableChild": "ComponentDef.prototype.hasFlavorableChild",
          "getFlavorOverrides": "ComponentDef.prototype.getFlavorOverrides",
          "isDynamicallyFlavorable": "ComponentDef.prototype.isDynamicallyFlavorable",
          "getAttributeDefs": "ComponentDef.prototype.getAttributeDefs",
          "getFacets": "ComponentDef.prototype.getFacets",
          "getControllerDef": "ComponentDef.prototype.getControllerDef",
          "getModelDef": "ComponentDef.prototype.getModelDef",
          "getEventDef": "ComponentDef.prototype.getEventDef",
          "getEventNameByDescriptor": "ComponentDef.prototype.getEventNameByDescriptor",
          "getAllEvents": "ComponentDef.prototype.getAllEvents",
          "getAppHandlerDefs": "ComponentDef.prototype.getAppHandlerDefs",
          "getCmpHandlerDefs": "ComponentDef.prototype.getCmpHandlerDefs",
          "getValueHandlerDefs": "ComponentDef.prototype.getValueHandlerDefs",
          "toString": "ComponentDef.prototype.toString",
          "isInstanceOf": "ComponentDef.prototype.isInstanceOf",
          "implementsDirectly": "ComponentDef.prototype.implementsDirectly",
          "getLocationChangeEvent": "ComponentDef.prototype.getLocationChangeEvent",
          "getLayouts": "ComponentDef.prototype.getLayouts",
          "initSuperDef": "ComponentDef.prototype.initSuperDef",
          "initStyleDefs": "ComponentDef.prototype.initStyleDefs"
        }
      },
      "ComponentDefStorage": {
        "prototype": {
          "EVICTION_TARGET_LOAD": {
            "!type": "number",
            "!span": "954[27:30]-974[27:50]",
            "!doc": "Target size, as a percent of max size, for component def storage during eviction."
          },
          "MUTEX_KEY": {
            "!type": "string",
            "!span": "1098[32:30]-1107[32:39]",
            "!doc": "Key to use of the MutexLocker to guarantee atomic execution across tabs."
          },
          "EVICTION_HEADROOM": {
            "!type": "number",
            "!span": "1402[42:30]-1419[42:47]",
            "!doc": "Minimum head room, as a percent of max size, to allocate after eviction and adding new definitions."
          },
          "TRANSACTION_SENTINEL_KEY": {
            "!type": "string",
            "!span": "1573[48:30]-1597[48:54]",
            "!doc": "Storage key used to track transactional bounds.\nTODO W-2365447 - replace this with bulk remove + put"
          },
          "clear": {},
          "restoreAll": {},
          "useDefinitionStorage": "ComponentDefStorage.prototype.useDefinitionStorage",
          "setupDefinitionStorage": "ComponentDefStorage.prototype.setupDefinitionStorage",
          "getStorage": "ComponentDefStorage.prototype.getStorage",
          "storeDefs": "ComponentDefStorage.prototype.storeDefs",
          "removeDefs": "ComponentDefStorage.prototype.removeDefs",
          "getAll": "ComponentDefStorage.prototype.getAll",
          "enqueue": "ComponentDefStorage.prototype.enqueue"
        }
      },
      "!span": "1455[44:5]-1464[44:14]",
      "ComponentClassRegistry": {
        "prototype": {
          "buildConstructor": {},
          "hasComponentClass": "ComponentClassRegistry.prototype.hasComponentClass",
          "addComponentClass": "ComponentClassRegistry.prototype.addComponentClass",
          "getComponentClass": "ComponentClassRegistry.prototype.getComponentClass",
          "buildComponentClass": "ComponentClassRegistry.prototype.buildComponentClass",
          "buildInheritance": "ComponentClassRegistry.prototype.buildInheritance",
          "buildLibraries": "ComponentClassRegistry.prototype.buildLibraries"
        }
      },
      "InvalidComponent": {
        "prototype": {
          "getDef": "InvalidComponent.prototype.getDef",
          "index": "InvalidComponent.prototype.index",
          "deIndex": "InvalidComponent.prototype.deIndex",
          "find": "InvalidComponent.prototype.find",
          "findInstancesOf": "InvalidComponent.prototype.findInstancesOf",
          "getSuperest": "InvalidComponent.prototype.getSuperest",
          "findInstanceOf": "InvalidComponent.prototype.findInstanceOf",
          "isInstanceOf": "InvalidComponent.prototype.isInstanceOf",
          "implementsDirectly": "InvalidComponent.prototype.implementsDirectly",
          "addHandler": "InvalidComponent.prototype.addHandler",
          "addValueHandler": "InvalidComponent.prototype.addValueHandler",
          "removeValueHandler": "InvalidComponent.prototype.removeValueHandler",
          "finishDestroy": "InvalidComponent.prototype.finishDestroy",
          "destroy": "InvalidComponent.prototype.destroy",
          "isRendered": "InvalidComponent.prototype.isRendered",
          "setUnrendering": "InvalidComponent.prototype.setUnrendering",
          "isUnrendering": "InvalidComponent.prototype.isUnrendering",
          "setRendered": "InvalidComponent.prototype.setRendered",
          "getRenderer": "InvalidComponent.prototype.getRenderer",
          "getGlobalId": "InvalidComponent.prototype.getGlobalId",
          "getLocalId": "InvalidComponent.prototype.getLocalId",
          "getRendering": "InvalidComponent.prototype.getRendering",
          "getSuper": "InvalidComponent.prototype.getSuper",
          "associateElement": "InvalidComponent.prototype.associateElement",
          "getElements": "InvalidComponent.prototype.getElements",
          "getElement": "InvalidComponent.prototype.getElement",
          "get": "InvalidComponent.prototype.get",
          "set": "InvalidComponent.prototype.set",
          "getConcreteComponent": "InvalidComponent.prototype.getConcreteComponent",
          "isConcrete": "InvalidComponent.prototype.isConcrete",
          "getEventDispatcher": "InvalidComponent.prototype.getEventDispatcher",
          "getModel": "InvalidComponent.prototype.getModel",
          "getEvent": "InvalidComponent.prototype.getEvent",
          "getEventByDescriptor": "InvalidComponent.prototype.getEventByDescriptor",
          "fire": "InvalidComponent.prototype.fire",
          "isValid": "InvalidComponent.prototype.isValid",
          "toString": "InvalidComponent.prototype.toString",
          "getFacets": "InvalidComponent.prototype.getFacets",
          "raiseInvalidComponentError": "InvalidComponent.prototype.raiseInvalidComponentError"
        }
      }
    },
    "Provider": {
      "GlobalValueProviders": {
        "prototype": {
          "STORAGE_KEY": {
            "!type": "string",
            "!span": "2659[68:31]-2670[68:42]",
            "!doc": "Persistent storage key for GVPs."
          },
          "MUTEX_KEY": {
            "!type": "string",
            "!span": "2814[74:31]-2823[74:40]",
            "!doc": "Key to use of the MutexLocker to guarantee atomic execution across tabs."
          },
          "LOADED_FROM_PERSISTENT_STORAGE": {
            "!type": "bool",
            "!span": "3070[83:31]-3100[83:61]",
            "!doc": "True if GVPs were loaded from persistent storage."
          },
          "merge": "GlobalValueProviders.prototype.merge",
          "getStorage": "GlobalValueProviders.prototype.getStorage",
          "loadFromStorage": "GlobalValueProviders.prototype.loadFromStorage",
          "load": "GlobalValueProviders.prototype.load",
          "addValueProvider": "GlobalValueProviders.prototype.addValueProvider",
          "getValueProvider": "GlobalValueProviders.prototype.getValueProvider",
          "get": "GlobalValueProviders.prototype.get"
        }
      },
      "!span": "1477[45:5]-1485[45:13]",
      "LabelQueue": {
        "prototype": {
          "getComponents": {},
          "addComponent": "LabelQueue.prototype.addComponent",
          "getReturnValues": "LabelQueue.prototype.getReturnValues",
          "addReturnValue": "LabelQueue.prototype.addReturnValue",
          "getCallbacks": "LabelQueue.prototype.getCallbacks",
          "addCallback": "LabelQueue.prototype.addCallback",
          "setRequested": "LabelQueue.prototype.setRequested",
          "isRequested": "LabelQueue.prototype.isRequested",
          "reset": "LabelQueue.prototype.reset"
        }
      },
      "ContextValueProvider": {
        "prototype": {
          "getValues": "ContextValueProvider.prototype.getValues",
          "getStorableValues": "ContextValueProvider.prototype.getStorableValues",
          "serializeForServer": "ContextValueProvider.prototype.serializeForServer",
          "merge": "ContextValueProvider.prototype.merge",
          "get": "ContextValueProvider.prototype.get",
          "set": "ContextValueProvider.prototype.set",
          "extract": "ContextValueProvider.prototype.extract"
        }
      },
      "LabelValueProvider": {
        "prototype": {
          "requestServerLabel": "LabelValueProvider.prototype.requestServerLabel",
          "getQueue": "LabelValueProvider.prototype.getQueue",
          "removeQueue": "LabelValueProvider.prototype.removeQueue",
          "getQueueKey": "LabelValueProvider.prototype.getQueueKey",
          "getValues": "LabelValueProvider.prototype.getValues",
          "merge": "LabelValueProvider.prototype.merge",
          "get": "LabelValueProvider.prototype.get"
        }
      },
      "ObjectValueProvider": {
        "prototype": {
          "getValues": "ObjectValueProvider.prototype.getValues",
          "merge": "ObjectValueProvider.prototype.merge",
          "get": "ObjectValueProvider.prototype.get"
        }
      }
    },
    "Library": {
      "!span": "1499[46:5]-1506[46:12]",
      "LibraryIncludeRegistry": {
        "prototype": {
          "hasLibraryInclude": "LibraryIncludeRegistry.prototype.hasLibraryInclude",
          "addLibraryInclude": "LibraryIncludeRegistry.prototype.addLibraryInclude",
          "getLibraryInclude": "LibraryIncludeRegistry.prototype.getLibraryInclude",
          "buildLibraryInclude": "LibraryIncludeRegistry.prototype.buildLibraryInclude",
          "clearDependencyQueue": "LibraryIncludeRegistry.prototype.clearDependencyQueue",
          "enqueueDependency": "LibraryIncludeRegistry.prototype.enqueueDependency",
          "dequeueDependency": "LibraryIncludeRegistry.prototype.dequeueDependency",
          "cloneDependencyQueue": "LibraryIncludeRegistry.prototype.cloneDependencyQueue",
          "hasDependencyQueue": "LibraryIncludeRegistry.prototype.hasDependencyQueue",
          "hasDependencyQueueChanged": "LibraryIncludeRegistry.prototype.hasDependencyQueueChanged"
        }
      },
      "LibraryRegistry": {
        "prototype": {
          "initLibraries": "LibraryRegistry.prototype.initLibraries",
          "hasLibrary": "LibraryRegistry.prototype.hasLibrary",
          "addLibrary": "LibraryRegistry.prototype.addLibrary",
          "getLibrary": "LibraryRegistry.prototype.getLibrary",
          "buildLibrary": "LibraryRegistry.prototype.buildLibrary"
        }
      }
    },
    "Event": {
      "Event": {
        "prototype": {
          "fire": {
            "!type": "fn(params: ?|string)",
            "!span": "8175[236:93]-8179[237:0]",
            "!doc": "Fires the Event. Checks if the Event has already been fired before firing.\nReturns null if a handler has destroyed the component.\nMaps the component handlers to the event dispatcher.\n@param {Object} params Optional A set of parameters for the Event. Any previous parameters of the same name will be overwritten.\n@platform\n@export"
          },
          "getSource": {
            "!type": "fn() -> !this.source",
            "!span": "1554[48:27]-1563[48:36]",
            "!doc": "Gets the source component that fired this component event.\nThis method doesn't work for application events.\n\n@returns {Object}\n@platform\n@export"
          },
          "getDef": {
            "!type": "fn() -> !this.eventDef",
            "!span": "1714[57:27]-1720[57:33]",
            "!doc": "Gets the Event Definition.\nReturns an EventDef object.\n@export"
          },
          "stopPropagation": {
            "!type": "fn()",
            "!span": "1967[68:27]-1982[68:42]",
            "!doc": "Sets wether the event can bubble or not\n@param {Boolean} bubble The param wether this event should bubble or not\nThe default is false\n@platform\n@export"
          },
          "setComponentEvent": {
            "!type": "fn() -> !this",
            "!span": "2413[79:27]-2430[79:44]",
            "!doc": "Sets the event as a \"componentEvent\" (won't bubble)\nThis type of event was used historically as a construct to call an action of a child\nSince the advent of \"methods\", this type of event communication is discouraged and a \"method\" is preferred.\nNOTE: Calling events on a child is discouraged and will be deprecated\n@export"
          },
          "getName": {
            "!type": "fn() -> !this.eventName",
            "!span": "2692[90:27]-2699[90:34]",
            "!doc": "Gets the name of the Event.\nReturns a name of type String, the unique identifier that the component can use to call this Action.\n@platform\n@export"
          },
          "setParams": {
            "!type": "fn(config: ?|string)",
            "!span": "2988[101:27]-2997[101:36]",
            "!doc": "Sets parameters for the Event. Does not modify an event that has already been fired.\nMaps key in config to attributeDefs.\n@param {Object} config The parameters for the Event.\n@platform\n@export"
          },
          "setParam": {
            "!type": "fn(key: string, value: ?)",
            "!span": "3965[128:27]-3973[128:35]",
            "!doc": "Sets a parameter for the Event. Does not modify an event that has already been fired.\n@param {String} key The name of the parameter.\n@param {Object} value The value of the parameter.\n@platform\n@export"
          },
          "getParam": {
            "!type": "fn(name: string) -> !this.params.<i>",
            "!span": "4700[145:27]-4708[145:35]",
            "!doc": "Gets an Event parameter. Returns the parameters.\n@param {String} name The name of the Event. For example, <code>event.getParam(\"button\")</code> returns the value of the pressed mouse button (0, 1, or 2).\n@platform\n@export"
          },
          "getParams": {
            "!type": "fn() -> !this.params",
            "!span": "4892[154:27]-4901[154:36]",
            "!doc": "Gets all the Event parameters. Returns the collection of parameters.\n@platform\n@export"
          },
          "statsIndex": {
            "!type": "[Aura.Event.Event.prototype.statsIndex.<i>]",
            "!span": "4999[159:27]-5009[159:37]",
            "!doc": "#if {\"modes\" : [\"STATS\"]}"
          },
          "dispatchNonComponentEventHandlers": {
            "!type": "fn()",
            "!span": "5051[162:27]-5084[162:60]",
            "!doc": "#end"
          },
          "dispatchComponentEventHandlers": {
            "!type": "fn()",
            "!span": "6947[204:27]-6977[204:57]"
          }
        },
        "!type": "fn(config: ?|Aura.Event.Event.!0)",
        "!span": "863[23:11]-868[23:16]",
        "!doc": "@description Creates an Event with name, source component, event definition, event dispatcher, parameters, and sets the fired flag to false.\n@constructor\n@param {Object} config\n@platform\n@export",
        "params": {
          "expression": "string",
          "index": "string",
          "responseUpdated": "bool",
          "arguments": {
            "<i>": {
              "!type": "fn()",
              "!span": "70866[2169:36]-70875[2169:45]"
            },
            "!span": "70742[2166:32]-70744[2166:34]"
          },
          "!span": "1069[28:9]-1075[28:15]",
          "value": "+Component",
          "oldValue": "PropertyReferenceValue.lastResult",
          "action": "+Action"
        },
        "fired": {
          "!type": "bool",
          "!span": "1091[29:9]-1096[29:14]"
        },
        "eventStopPropagation": {
          "!type": "bool",
          "!span": "1115[30:9]-1135[30:29]"
        },
        "componentEvent": {
          "!type": "bool",
          "!span": "1154[31:9]-1168[31:23]"
        },
        "handled": {
          "!type": "bool",
          "!span": "29736[265:20621]-29745[265:20630]"
        }
      },
      "!span": "1521[47:5]-1526[47:10]",
      "EventDef": {
        "prototype": {
          "getDescriptor": "EventDef.prototype.getDescriptor",
          "getEventType": "EventDef.prototype.getEventType",
          "getAttributeDefs": "EventDef.prototype.getAttributeDefs",
          "getSuperDef": "EventDef.prototype.getSuperDef",
          "initSuperDef": "EventDef.prototype.initSuperDef"
        }
      }
    },
    "Controller": {
      "Action": {
        "prototype": {
          "nextActionId": {
            "!type": "number",
            "!span": "3241[100:17]-3253[100:29]",
            "!doc": "Instance methods:"
          },
          "popCreationPath": {},
          "getStored": {},
          "getStorageErrorHandler": {},
          "prepareToSend": {},
          "copyToRefresh": {},
          "getRefreshAction": {},
          "getId": "Action.prototype.getId",
          "getNextGlobalId": "Action.prototype.getNextGlobalId",
          "reactivatePath": "Action.prototype.reactivatePath",
          "forceCreationPath": "Action.prototype.forceCreationPath",
          "setDeferred": "Action.prototype.setDeferred",
          "isDeferred": "Action.prototype.isDeferred",
          "releaseCreationPath": "Action.prototype.releaseCreationPath",
          "pushCreationPath": "Action.prototype.pushCreationPath",
          "topPath": "Action.prototype.topPath",
          "setCreationPathIndex": "Action.prototype.setCreationPathIndex",
          "setCompletion": "Action.prototype.setCompletion",
          "complete": "Action.prototype.complete",
          "getCurrentPath": "Action.prototype.getCurrentPath",
          "getDef": "Action.prototype.getDef",
          "setParams": "Action.prototype.setParams",
          "setParam": "Action.prototype.setParam",
          "getParam": "Action.prototype.getParam",
          "getParams": "Action.prototype.getParams",
          "getComponent": "Action.prototype.getComponent",
          "setCallback": "Action.prototype.setCallback",
          "getCallback": "Action.prototype.getCallback",
          "setAllAboardCallback": "Action.prototype.setAllAboardCallback",
          "callAllAboardCallback": "Action.prototype.callAllAboardCallback",
          "wrapCallback": "Action.prototype.wrapCallback",
          "run": "Action.prototype.run",
          "runDeprecated": "Action.prototype.runDeprecated",
          "getState": "Action.prototype.getState",
          "getReturnValue": "Action.prototype.getReturnValue",
          "getError": "Action.prototype.getError",
          "isBackground": "Action.prototype.isBackground",
          "setBackground": "Action.prototype.setBackground",
          "runAfter": "Action.prototype.runAfter",
          "updateFromResponse": "Action.prototype.updateFromResponse",
          "finishAction": "Action.prototype.finishAction",
          "abortIfComponentInvalid": "Action.prototype.abortIfComponentInvalid",
          "abort": "Action.prototype.abort",
          "setAbortable": "Action.prototype.setAbortable",
          "getAbortableId": "Action.prototype.getAbortableId",
          "isRefreshAction": "Action.prototype.isRefreshAction",
          "isAbortable": "Action.prototype.isAbortable",
          "setExclusive": "Action.prototype.setExclusive",
          "isExclusive": "Action.prototype.isExclusive",
          "setStorable": "Action.prototype.setStorable",
          "isStorable": "Action.prototype.isStorable",
          "setCaboose": "Action.prototype.setCaboose",
          "isCaboose": "Action.prototype.isCaboose",
          "_isStorable": "Action.prototype._isStorable",
          "getStorageKey": "Action.prototype.getStorageKey",
          "isFromStorage": "Action.prototype.isFromStorage",
          "setChained": "Action.prototype.setChained",
          "isChained": "Action.prototype.isChained",
          "toJSON": "Action.prototype.toJSON",
          "markException": "Action.prototype.markException",
          "markError": "Action.prototype.markError",
          "incomplete": "Action.prototype.incomplete",
          "getRetryFromStorageAction": "Action.prototype.getRetryFromStorageAction",
          "getStorage": "Action.prototype.getStorage",
          "parseAndFireEvent": "Action.prototype.parseAndFireEvent",
          "fireRefreshEvent": "Action.prototype.fireRefreshEvent"
        },
        "getStorageKey": "Action.getStorageKey",
        "getStorage": "Action.getStorage"
      },
      "!span": "1565[49:5]-1575[49:15]",
      "ActionDef": {
        "prototype": {
          "getName": "ActionDef.prototype.getName",
          "getDescriptor": "ActionDef.prototype.getDescriptor",
          "getActionType": "ActionDef.prototype.getActionType",
          "isClientAction": "ActionDef.prototype.isClientAction",
          "isServerAction": "ActionDef.prototype.isServerAction",
          "isBackground": "ActionDef.prototype.isBackground",
          "isCaboose": "ActionDef.prototype.isCaboose",
          "newInstance": "ActionDef.prototype.newInstance",
          "toString": "ActionDef.prototype.toString"
        }
      },
      "ControllerDef": {
        "prototype": {
          "getDescriptor": "ControllerDef.prototype.getDescriptor",
          "getActionDef": "ControllerDef.prototype.getActionDef",
          "get": "ControllerDef.prototype.get"
        }
      }
    },
    "Attribute": {
      "!span": "1587[50:5]-1596[50:14]",
      "AttributeDef": "AttributeDef",
      "AttributeSet": "AttributeSet",
      "AttributeDefSet": {
        "prototype": {
          "each": "AttributeDefSet.prototype.each",
          "getDef": "AttributeDefSet.prototype.getDef",
          "getNames": "AttributeDefSet.prototype.getNames",
          "getValues": "AttributeDefSet.prototype.getValues"
        }
      }
    },
    "Method": {
      "MethodDef": {
        "prototype": {
          "getDescriptor": {
            "!type": "fn() -> !this.descriptor",
            "!span": "1279[34:32]-1292[34:45]",
            "!doc": "Gets the descriptor. Returns a DefDescriptor object that contains the metadata for the attribute.\n@returns {DefDescriptor} The qualified name for a DefDescriptor object has the format <code>prefix://namespace:name</code>.\n@export"
          }
        },
        "!type": "fn(config: ?)",
        "!span": "783[22:12]-792[22:21]",
        "!doc": "@description Creates a new MethodDef instance, including the descriptor.\n@constructor\n@param {Object} config\n@export"
      },
      "!span": "1609[51:5]-1615[51:11]"
    },
    "L10n": {
      "!span": "1631[52:5]-1635[52:9]",
      "AuraLocalizationContext": "AuraLocalizationContext"
    },
    "Services": {
      "AuraClientServiceMarker": {
        "!type": "number",
        "!span": "738[22:14]-761[22:37]",
        "!doc": "AuraXHR: struct used to represent a connection.\n\n@private\n@constructor"
      },
      "AuraClientService$AuraXHR": {
        "prototype": {
          "reset": {
            "!type": "fn()",
            "!span": "1006[34:50]-1011[34:55]",
            "!doc": "Reset the xhr."
          },
          "addAction": {
            "!type": "fn(action: ?)",
            "!span": "1160[42:50]-1169[42:59]",
            "!doc": "add an action."
          },
          "getAction": {
            "!type": "fn(id: ?) -> string|fn()",
            "!span": "1505[54:50]-1514[54:59]",
            "!doc": "get an action for a response."
          }
        },
        "!type": "fn()",
        "!span": "782[24:14]-807[24:39]",
        "length": {
          "!type": "number",
          "!span": "840[25:9]-846[25:15]"
        },
        "marker": {
          "!type": "number",
          "!span": "861[26:9]-867[26:15]"
        },
        "actions": {
          "!span": "912[28:9]-919[28:16]"
        },
        "className": {
          "!type": "string",
          "!span": "21228[659:24]-21239[659:35]"
        }
      },
      "length": {
        "!type": "number",
        "!span": "840[25:9]-846[25:15]"
      },
      "marker": {
        "!type": "number",
        "!span": "861[26:9]-867[26:15]"
      },
      "actions": {
        "!span": "912[28:9]-919[28:16]"
      },
      "AuraClientService$AuraActionCollector": {
        "!type": "fn()",
        "!span": "1741[69:14]-1778[69:51]",
        "!doc": "A handy structure to hold data.\n\n@constructor\n@private",
        "clientActions": {
          "!type": "[AuraInstance.context.contextGlobals|string]",
          "!span": "1870[71:9]-1883[71:22]",
          "!doc": "Collected client actions for execution."
        },
        "clientIndex": {
          "!type": "number",
          "!span": "1899[72:9]-1910[72:20]",
          "!doc": "Start our index at 0"
        },
        "actionsToCollect": {
          "!type": "number",
          "!span": "1967[75:9]-1983[75:25]",
          "!doc": "collected server actions to send."
        },
        "collected": {
          "!type": "[AuraInstance.context.contextGlobals|string]",
          "!span": "1998[76:9]-2007[76:18]"
        },
        "completionIndex": {
          "!type": "number",
          "!span": "2136[81:9]-2151[81:24]"
        },
        "actionsCompleted": {
          "!type": "number",
          "!span": "2200[84:9]-2216[84:25]",
          "!doc": "server actions completed."
        }
      },
      "clientActions": {
        "!type": "[AuraInstance.context.contextGlobals|string]",
        "!span": "1870[71:9]-1883[71:22]"
      },
      "clientIndex": {
        "!type": "number",
        "!span": "1899[72:9]-1910[72:20]"
      },
      "actionsToCollect": {
        "!type": "number",
        "!span": "1967[75:9]-1983[75:25]"
      },
      "collected": {
        "!type": "[AuraInstance.context.contextGlobals|string]",
        "!span": "1998[76:9]-2007[76:18]"
      },
      "collecting": {
        "!type": "[AuraInstance.context.contextGlobals|string]",
        "!span": "2023[77:9]-2033[77:19]"
      },
      "actionsToComplete": {
        "!type": "[Aura.Services.actionsToComplete.<i>]",
        "!span": "2103[80:9]-2120[80:26]",
        "!doc": "collected server actions to complete (stored)"
      },
      "completionIndex": {
        "!type": "number",
        "!span": "2136[81:9]-2151[81:24]"
      },
      "actionsCompleted": {
        "!type": "number",
        "!span": "2200[84:9]-2216[84:25]"
      },
      "AuraClientService": {
        "prototype": {
          "decode": {},
          "init": {},
          "send": {},
          "createXHR": {},
          "buildParams": {},
          "createIntegrationErrorConfig": {},
          "shouldSendOutForegroundActions": {},
          "sendAsSingle": {},
          "getAndClearDupes": {},
          "setQueueSize": "AuraClientService.prototype.setQueueSize",
          "deferPendingActions": "AuraClientService.prototype.deferPendingActions",
          "throwExceptionEvent": "AuraClientService.prototype.throwExceptionEvent",
          "fireDoneWaiting": "AuraClientService.prototype.fireDoneWaiting",
          "tearDown": "AuraClientService.prototype.tearDown",
          "setInCollection": "AuraClientService.prototype.setInCollection",
          "clearInCollection": "AuraClientService.prototype.clearInCollection",
          "isDisconnectedOrCancelled": "AuraClientService.prototype.isDisconnectedOrCancelled",
          "singleAction": "AuraClientService.prototype.singleAction",
          "isBB10": "AuraClientService.prototype.isBB10",
          "getManifestURL": "AuraClientService.prototype.getManifestURL",
          "isManifestPresent": "AuraClientService.prototype.isManifestPresent",
          "countAvailableXHRs": "AuraClientService.prototype.countAvailableXHRs",
          "getAvailableXHR": "AuraClientService.prototype.getAvailableXHR",
          "releaseXHR": "AuraClientService.prototype.releaseXHR",
          "hardRefresh": "AuraClientService.prototype.hardRefresh",
          "isDevMode": "AuraClientService.prototype.isDevMode",
          "actualDumpCachesAndReload": "AuraClientService.prototype.actualDumpCachesAndReload",
          "dumpCachesAndReload": "AuraClientService.prototype.dumpCachesAndReload",
          "handleAppCache": "AuraClientService.prototype.handleAppCache",
          "setOutdated": "AuraClientService.prototype.setOutdated",
          "setConnected": "AuraClientService.prototype.setConnected",
          "saveTokenToStorage": "AuraClientService.prototype.saveTokenToStorage",
          "loadTokenFromStorage": "AuraClientService.prototype.loadTokenFromStorage",
          "initHost": "AuraClientService.prototype.initHost",
          "inFlightXHRs": "AuraClientService.prototype.inFlightXHRs",
          "idle": "AuraClientService.prototype.idle",
          "runWhenXHRIdle": "AuraClientService.prototype.runWhenXHRIdle",
          "processXHRIdleQueue": "AuraClientService.prototype.processXHRIdleQueue",
          "areActionsWaiting": "AuraClientService.prototype.areActionsWaiting",
          "initDefs": "AuraClientService.prototype.initDefs",
          "runAfterInitDefs": "AuraClientService.prototype.runAfterInitDefs",
          "loadComponent": "AuraClientService.prototype.loadComponent",
          "inAuraLoop": "AuraClientService.prototype.inAuraLoop",
          "pushStack": "AuraClientService.prototype.pushStack",
          "popStack": "AuraClientService.prototype.popStack",
          "postProcess": "AuraClientService.prototype.postProcess",
          "process": "AuraClientService.prototype.process",
          "continueProcessing": "AuraClientService.prototype.continueProcessing",
          "getStoredResult": "AuraClientService.prototype.getStoredResult",
          "enqueueStoredAction": "AuraClientService.prototype.enqueueStoredAction",
          "executeStoredAction": "AuraClientService.prototype.executeStoredAction",
          "collectServerAction": "AuraClientService.prototype.collectServerAction",
          "continueClientActions": "AuraClientService.prototype.continueClientActions",
          "runClientActions": "AuraClientService.prototype.runClientActions",
          "executeClientAction": "AuraClientService.prototype.executeClientAction",
          "finishCollection": "AuraClientService.prototype.finishCollection",
          "sendActionXHRs": "AuraClientService.prototype.sendActionXHRs",
          "continueCompletions": "AuraClientService.prototype.continueCompletions",
          "finishProcessing": "AuraClientService.prototype.finishProcessing",
          "deDupe": "AuraClientService.prototype.deDupe",
          "xhrSetTimeout": "AuraClientService.prototype.xhrSetTimeout",
          "xhrClearTimeout": "AuraClientService.prototype.xhrClearTimeout",
          "receive": "AuraClientService.prototype.receive",
          "processErrors": "AuraClientService.prototype.processErrors",
          "processResponses": "AuraClientService.prototype.processResponses",
          "buildStorableServerAction": "AuraClientService.prototype.buildStorableServerAction",
          "processIncompletes": "AuraClientService.prototype.processIncompletes",
          "parseAndFireEvent": "AuraClientService.prototype.parseAndFireEvent",
          "resetToken": "AuraClientService.prototype.resetToken",
          "runActions": "AuraClientService.prototype.runActions",
          "injectComponent": "AuraClientService.prototype.injectComponent",
          "renderInjection": "AuraClientService.prototype.renderInjection",
          "injectComponentAsync": "AuraClientService.prototype.injectComponentAsync",
          "addComponentHandlers": "AuraClientService.prototype.addComponentHandlers",
          "isConnected": "AuraClientService.prototype.isConnected",
          "enqueueAction": "AuraClientService.prototype.enqueueAction",
          "deferAction": "AuraClientService.prototype.deferAction",
          "hasActionStorage": "AuraClientService.prototype.hasActionStorage",
          "isActionInStorage": "AuraClientService.prototype.isActionInStorage",
          "revalidateAction": "AuraClientService.prototype.revalidateAction",
          "invalidateAction": "AuraClientService.prototype.invalidateAction",
          "isInternalNamespace": "AuraClientService.prototype.isInternalNamespace",
          "isPrivilegedNamespace": "AuraClientService.prototype.isPrivilegedNamespace",
          "allowAccess": "AuraClientService.prototype.allowAccess",
          "invalidSession": "AuraClientService.prototype.invalidSession",
          "setUseBootstrapCache": "AuraClientService.prototype.setUseBootstrapCache",
          "disableBootstrapCacheOnNextLoad": "AuraClientService.prototype.disableBootstrapCacheOnNextLoad",
          "clearDisableBootstrapCacheOnNextLoad": "AuraClientService.prototype.clearDisableBootstrapCacheOnNextLoad",
          "getUseBootstrapCache": "AuraClientService.prototype.getUseBootstrapCache",
          "setXHRTimeout": "AuraClientService.prototype.setXHRTimeout",
          "populatePersistedActionsFilter": "AuraClientService.prototype.populatePersistedActionsFilter",
          "setupPersistedActionsFilter": "AuraClientService.prototype.setupPersistedActionsFilter"
        }
      },
      "AuraComponentService": {
        "prototype": {
          "newComponentArray": {},
          "requestComponent": {},
          "clearDefsFromStorage": {},
          "getUpstreamDependencies": {},
          "createInternalConfig": {},
          "getComponentConfigs": {},
          "getUnusedDefinitions": {},
          "destroy": {},
          "getRegisteredComponentDescriptors": {},
          "get": "AuraComponentService.prototype.get",
          "getComponent": "AuraComponentService.prototype.getComponent",
          "getDescriptorFromConfig": "AuraComponentService.prototype.getDescriptorFromConfig",
          "createDescriptorConfig": "AuraComponentService.prototype.createDescriptorConfig",
          "countComponents": "AuraComponentService.prototype.countComponents",
          "getRenderingComponentForElement": "AuraComponentService.prototype.getRenderingComponentForElement",
          "getAttributeProviderForElement": "AuraComponentService.prototype.getAttributeProviderForElement",
          "createComponent": "AuraComponentService.prototype.createComponent",
          "createComponentFromConfig": "AuraComponentService.prototype.createComponentFromConfig",
          "createComponents": "AuraComponentService.prototype.createComponents",
          "newComponent": "AuraComponentService.prototype.newComponent",
          "newComponentDeprecated": "AuraComponentService.prototype.newComponentDeprecated",
          "createComponentInstance": "AuraComponentService.prototype.createComponentInstance",
          "addComponentClass": "AuraComponentService.prototype.addComponentClass",
          "getComponentClass": "AuraComponentService.prototype.getComponentClass",
          "hasComponentClass": "AuraComponentService.prototype.hasComponentClass",
          "newComponentAsync": "AuraComponentService.prototype.newComponentAsync",
          "computeValue": "AuraComponentService.prototype.computeValue",
          "index": "AuraComponentService.prototype.index",
          "hasDefinition": "AuraComponentService.prototype.hasDefinition",
          "getDefinition": "AuraComponentService.prototype.getDefinition",
          "getComponentDef": "AuraComponentService.prototype.getComponentDef",
          "getDef": "AuraComponentService.prototype.getDef",
          "createFromSavedComponentConfigs": "AuraComponentService.prototype.createFromSavedComponentConfigs",
          "createComponentDef": "AuraComponentService.prototype.createComponentDef",
          "getControllerDef": "AuraComponentService.prototype.getControllerDef",
          "getDefFromRelationship": "AuraComponentService.prototype.getDefFromRelationship",
          "createControllerDef": "AuraComponentService.prototype.createControllerDef",
          "getActionDef": "AuraComponentService.prototype.getActionDef",
          "createActionDef": "AuraComponentService.prototype.createActionDef",
          "getModelDef": "AuraComponentService.prototype.getModelDef",
          "createModelDef": "AuraComponentService.prototype.createModelDef",
          "hasLibrary": "AuraComponentService.prototype.hasLibrary",
          "saveLibraryConfig": "AuraComponentService.prototype.saveLibraryConfig",
          "getLibrary": "AuraComponentService.prototype.getLibrary",
          "addLibraryInclude": "AuraComponentService.prototype.addLibraryInclude",
          "getLibraryInclude": "AuraComponentService.prototype.getLibraryInclude",
          "deIndex": "AuraComponentService.prototype.deIndex",
          "getDynamicNamespaces": "AuraComponentService.prototype.getDynamicNamespaces",
          "getIndex": "AuraComponentService.prototype.getIndex",
          "isConfigDescriptor": "AuraComponentService.prototype.isConfigDescriptor",
          "saveComponentConfig": "AuraComponentService.prototype.saveComponentConfig",
          "restoreDefsFromStorage": "AuraComponentService.prototype.restoreDefsFromStorage",
          "saveDefsToStorage": "AuraComponentService.prototype.saveDefsToStorage",
          "createComponentPrivAsync": "AuraComponentService.prototype.createComponentPrivAsync",
          "createComponentPriv": "AuraComponentService.prototype.createComponentPriv",
          "findDependencies": "AuraComponentService.prototype.findDependencies",
          "buildDependencyGraph": "AuraComponentService.prototype.buildDependencyGraph",
          "sortDependencyGraph": "AuraComponentService.prototype.sortDependencyGraph",
          "splitComponentsAndActions": "AuraComponentService.prototype.splitComponentsAndActions",
          "evictDefsFromStorage": "AuraComponentService.prototype.evictDefsFromStorage",
          "pruneDefsFromStorage": "AuraComponentService.prototype.pruneDefsFromStorage"
        }
      },
      "AuraEventService": {
        "prototype": {
          "addHandler": {},
          "removeHandler": {},
          "getRegisteredEvents": {},
          "qualifyEventName": "AuraEventService.prototype.qualifyEventName",
          "newEvent": "AuraEventService.prototype.newEvent",
          "getNewEvent": "AuraEventService.prototype.getNewEvent",
          "dispatchEventHandlers": "AuraEventService.prototype.dispatchEventHandlers",
          "bubbleEvent": "AuraEventService.prototype.bubbleEvent",
          "get": "AuraEventService.prototype.get",
          "getEventDef": "AuraEventService.prototype.getEventDef",
          "getDef": "AuraEventService.prototype.getDef",
          "hasDefinition": "AuraEventService.prototype.hasDefinition",
          "createDescriptorConfig": "AuraEventService.prototype.createDescriptorConfig",
          "getDefinition": "AuraEventService.prototype.getDefinition",
          "getDescriptorFromConfig": "AuraEventService.prototype.getDescriptorFromConfig",
          "createFromSavedConfigs": "AuraEventService.prototype.createFromSavedConfigs",
          "createEventDef": "AuraEventService.prototype.createEventDef",
          "saveEventConfig": "AuraEventService.prototype.saveEventConfig",
          "hasHandlers": "AuraEventService.prototype.hasHandlers",
          "hasPendingEvents": "AuraEventService.prototype.hasPendingEvents"
        }
      },
      "AuraHistoryService": {
        "prototype": {
          "get": {},
          "parseQueryString": {},
          "set": "AuraHistoryService.prototype.set",
          "replace": "AuraHistoryService.prototype.replace",
          "back": "AuraHistoryService.prototype.back",
          "setTitle": "AuraHistoryService.prototype.setTitle",
          "forward": "AuraHistoryService.prototype.forward",
          "reset": "AuraHistoryService.prototype.reset",
          "usePushState": "AuraHistoryService.prototype.usePushState",
          "init": "AuraHistoryService.prototype.init",
          "getEvent": "AuraHistoryService.prototype.getEvent",
          "changeHandler": "AuraHistoryService.prototype.changeHandler",
          "parseLocation": "AuraHistoryService.prototype.parseLocation",
          "getLocationHash": "AuraHistoryService.prototype.getLocationHash"
        }
      },
      "AuraRenderingService": {
        "prototype": {
          "getUpdatedFacetInfo": {},
          "statsIndex": {
            "afterRender": {
              "<i>": {
                "startTime": {
                  "!type": "number",
                  "!span": "7621[216:8]-7632[216:19]"
                },
                "endTime": {
                  "!type": "number",
                  "!span": "7654[217:8]-7663[217:17]"
                }
              }
            },
            "render": {
              "<i>": {
                "startTime": {
                  "!type": "number",
                  "!span": "3170[85:8]-3181[85:19]"
                },
                "endTime": {
                  "!type": "number",
                  "!span": "3203[86:8]-3212[86:17]"
                },
                "component": "AuraRenderingService.prototype.statsIndex.render.<i>.component"
              }
            },
            "rerender": {
              "<i>": {
                "startTime": {
                  "!type": "number",
                  "!span": "5769[160:8]-5780[160:19]"
                },
                "endTime": {
                  "!type": "number",
                  "!span": "5802[161:8]-5811[161:17]"
                }
              }
            },
            "rerenderDirty": {
              "<i>": {
                "components": {
                  "<i>": {
                    "why": {
                      "<i>": {
                        "!type": "bool",
                        "!span": "20185[544:17]-20195[544:27]"
                      }
                    }
                  }
                },
                "renderingTime": {
                  "!type": "number",
                  "!span": "24501[662:24]-24516[662:39]"
                }
              }
            },
            "unrender": {
              "<i>": {
                "startTime": {
                  "!type": "number",
                  "!span": "9691[279:8]-9702[279:19]"
                },
                "endTime": {
                  "!type": "number",
                  "!span": "9724[280:8]-9733[280:17]"
                }
              }
            }
          },
          "storeFacetInfo": {},
          "renderFacet": {},
          "render": "AuraRenderingService.prototype.render",
          "rerender": "AuraRenderingService.prototype.rerender",
          "afterRender": "AuraRenderingService.prototype.afterRender",
          "unrender": "AuraRenderingService.prototype.unrender",
          "rerenderFacet": "AuraRenderingService.prototype.rerenderFacet",
          "unrenderFacet": "AuraRenderingService.prototype.unrenderFacet",
          "getMarker": "AuraRenderingService.prototype.getMarker",
          "addDirtyValue": "AuraRenderingService.prototype.addDirtyValue",
          "hasDirtyValue": "AuraRenderingService.prototype.hasDirtyValue",
          "isDirtyValue": "AuraRenderingService.prototype.isDirtyValue",
          "rerenderDirty": "AuraRenderingService.prototype.rerenderDirty",
          "removeDirtyValue": "AuraRenderingService.prototype.removeDirtyValue",
          "cleanComponent": "AuraRenderingService.prototype.cleanComponent",
          "getArray": "AuraRenderingService.prototype.getArray",
          "evalStrings": "AuraRenderingService.prototype.evalStrings",
          "finishRender": "AuraRenderingService.prototype.finishRender",
          "insertElements": "AuraRenderingService.prototype.insertElements",
          "getFlavorClass": "AuraRenderingService.prototype.getFlavorClass",
          "addAuraClass": "AuraRenderingService.prototype.addAuraClass",
          "associateElements": "AuraRenderingService.prototype.associateElements",
          "createMarker": "AuraRenderingService.prototype.createMarker",
          "isMarker": "AuraRenderingService.prototype.isMarker"
        }
      },
      "LockerService": {},
      "MetricsService": {
        "prototype": {
          "initialize": {
            "!type": "fn()",
            "!span": "2020[51:39]-2030[51:49]",
            "!doc": " Initialize function\n@private"
          },
          "instrument": {
            "!type": "fn(instance: Aura.Services.MetricsService.prototype.instrument.!0, method: string, ns: string, async: bool, before: ?, after: ?, override: fn(original: ?, config: ?)|fn(original: ?))",
            "!span": "2638[71:39]-2648[71:49]",
            "!doc": "Instrument a particular method (function) of an object, useful for AOP\n@param {Object} instance Object that holds the method to hook\n@param {string} method Method name\n@param {string} ns Namespace\n@param {boolean} async\n@param {function(Object)} before\n@param {function} after\n@param {function} override\n@export"
          },
          "unInstrument": {
            "!type": "fn(instance: Aura.Services.MetricsService.prototype.unInstrument.!0, method: string)",
            "!span": "3992[118:39]-4004[118:51]",
            "!doc": "UnInstrument a particular method (function) of an object, useful for AOP\n@param {Object} instance Object that holds the method to hook\n@param {string} method Method name\n@export"
          },
          "initializePlugins": {
            "!type": "fn()",
            "!span": "4260[128:39]-4277[128:56]",
            "!doc": "Initialize registered plugins\n@private"
          },
          "initializePlugin": {
            "!type": "fn(pluginName: string, PluginContructor: fn(config: ?))",
            "!span": "4654[141:39]-4670[141:55]",
            "!doc": "Initialize a give plugin\n@param {string} pluginName Plugin name\n@param {Object|function} Construtor or Objecct for the plugin\n@private"
          },
          "applicationReady": {
            "!type": "fn()",
            "!span": "5075[152:39]-5091[152:55]",
            "!doc": "Internal method called once the application is ready\n@private"
          },
          "syntheticTransactionStart": {
            "!type": "fn(ns: string, name: string, config: ?) -> string",
            "!span": "6213[186:39]-6238[186:64]",
            "!doc": "Create a transaction based on a given configuration\n@param {string} ns Namespace of the transaction\n@param {string} name Name of the transaction\n@param {Object} transaction Transaction\n@public\n@export"
          },
          "onTransactionEnd": {
            "!type": "fn(callback: ?)",
            "!span": "6600[199:39]-6616[199:55]",
            "!doc": "Add a callback everytime a transaction ends.\n@param {function} callback Function to execute for every transaction\n@public\n@export"
          },
          "detachOnTransactionEnd": {
            "!type": "fn(callback: ?)",
            "!span": "6894[209:39]-6916[209:61]",
            "!doc": "Unbind a callback everytime a transaction ends.\n@param {function} callback Function to detach for every transaction\n@public\n@export"
          },
          "onTransactionsKilled": {
            "!type": "fn(callback: ?)",
            "!span": "7192[219:39]-7212[219:59]",
            "!doc": "Add a callback everytime a transaction ends.\n@param {function} callback Function to execute for every transaction\n@public\n@export"
          },
          "detachOnKilledTransactions": {
            "!type": "fn(callback: ?)",
            "!span": "7494[229:39]-7520[229:65]",
            "!doc": "Unbind a callback everytime a transaction ends.\n@param {function} callback Function to detach for every transaction\n@public\n@export"
          },
          "detachHandlerOfType": {
            "!type": "fn(callback: ?, name: string)",
            "!span": "7835[238:39]-7854[238:58]",
            "!doc": "Unbind a callback for a give action\n@param {function} callback Function to detach for every transaction\n@param {name} callback Function to detach for every transaction"
          },
          "inTransaction": {
            "!type": "fn(ignorePageTransactions: ?) -> bool",
            "!span": "8269[254:39]-8282[254:52]",
            "!doc": "Check if we are in a transcation already\n@return {boolean} Wether we are in a transaction\n@public\n@export"
          },
          "transaction": {
            "!type": "fn(ns: string, name: ?, config: ?)",
            "!span": "8828[274:39]-8839[274:50]",
            "!doc": "Create a transaction\n@param {string} ns Namespace of the transaction\n@param {string} id Id of the transaction\n@param {Object} config Configuration and context for the transaction\n@public\n@export"
          },
          "transactionUpdate": {
            "!type": "fn(ns: string, name: ?, config: ?)",
            "!span": "9468[295:39]-9485[295:56]",
            "!doc": "Update a transaction\n@param {string} ns Namespace of the transaction\n@param {string} id Id of the transaction\n@param {Object} config Configuration and context for the transaction\n@public\n@export"
          },
          "transactionStart": {
            "!type": "fn(ns: string, name: string, config: ?) -> string",
            "!span": "10053[312:39]-10069[312:55]",
            "!doc": "Start a transaction\n@param {string} ns Namespace of the transaction\n@param {string} id Id of the transaction\n@param {Object} config Configuration and context for the transaction\n@public\n@export"
          },
          "transactionEnd": {
            "!type": "fn(ns: string, name: string, config: ?, postProcess: ?)",
            "!span": "10419[324:39]-10433[324:53]",
            "!doc": "Finish a transaction\n@param {string} ns Namespace of the transaction\n@param {string} id Id of the transaction\n@param {Object} config Configuration and context for the transaction\n@public\n@export"
          },
          "clearTransactions": {
            "!type": "fn()",
            "!span": "14244[413:39]-14261[413:56]",
            "!doc": "Clear all saved transactions\n@public\n@export"
          },
          "callHandlers": {
            "!type": "fn(type: string, t: ?|[?|Aura.Services.MetricsService.transactions.<i>])",
            "!span": "14420[421:39]-14432[421:51]",
            "!doc": "Internal method to call globalHandlers attached\n@private"
          },
          "killLongRunningTransactions": {
            "!type": "fn()",
            "!span": "14809[435:39]-14836[435:66]",
            "!doc": "Tries to kill transaction than are been in the queue for a long period of time\ndefined via static param on metricsService\n@private"
          },
          "getCurrentPageTransaction": {
            "!type": "fn() -> !this.transactions.<i>",
            "!span": "15580[458:39]-15605[458:64]",
            "!doc": "Get the current page transaction\nhas pageTransaction config flag\n@export"
          },
          "getCurrentMarks": {
            "!type": "fn() -> Aura.Services.MetricsService.prototype.getCurrentMarks.!ret",
            "!span": "15914[470:39]-15929[470:54]",
            "!doc": "Returns a clone of the marks currently available on the collector\n@export"
          },
          "getVersion": {
            "!type": "fn(includePlugins: ?) -> string|?",
            "!span": "16104[478:39]-16114[478:49]",
            "!doc": "Returns the metricsService version\n@export"
          },
          "defaultPostProcessing": {
            "!type": "fn(customMarks: [?]) -> [!0.<i>]",
            "!span": "16644[499:39]-16665[499:60]",
            "!doc": "Default post processing for marks (only enabled in non production environments)\n@private"
          },
          "getTransactions": {
            "!type": "fn() -> [?|Aura.Services.MetricsService.transactions.<i>]",
            "!span": "17628[527:39]-17643[527:54]",
            "!doc": "Get all internal stored transactions\n@export"
          },
          "getTransaction": {
            "!type": "fn(ns: string, id: string) -> ?|Aura.Services.MetricsService.transactions.<i>",
            "!span": "18008[541:39]-18022[541:53]",
            "!doc": "Get a internal stored transaction by id\n@param {?string} ns Namespace of the transaction\n@param {string} id Id of the transaction\n@export"
          },
          "setClearCompletedTransactions": {
            "!type": "fn(value: bool)",
            "!span": "18664[562:39]-18693[562:68]",
            "!doc": "Set the internal storage of transactions\n@export"
          },
          "createTransaction": {
            "!type": "fn(ns: string, name: string, config: ?) -> string",
            "!span": "18975[575:39]-18992[575:56]",
            "!doc": "Creates a transaction\n@param {string} ns Namespace of the mark\n@param {string} name of the mark\n@param {Object} config Config object\n@private"
          },
          "mark": {
            "!type": "fn(ns: string, name: string, context: ?) -> Aura.Services.MetricsService.prototype.mark.!ret",
            "!span": "19748[601:39]-19752[601:43]",
            "!doc": "Creates a mark for a give namespace and key action\n@param {string} ns Namespace of the mark\n@param {string} name of the mark\n@param {Object} context Context Object\n@export\n@public"
          },
          "markStart": {
            "!type": "fn(ns: string, name: string, context: ?) -> Aura.Services.MetricsService.prototype.mark.!ret",
            "!span": "20373[619:39]-20382[619:48]",
            "!doc": "Creates a start mark for a give namespace and key action\n@param {string} ns Namespace of the mark\n@param {string} name of the mark\n@param {Object} context Context Object\n@export\n@public"
          },
          "markEnd": {
            "!type": "fn(ns: string, name: string, context: ?) -> Aura.Services.MetricsService.prototype.mark.!ret",
            "!span": "21001[637:39]-21008[637:46]",
            "!doc": "Creates a end mark for a give namespace and key action\n@param {string} ns Namespace of the mark\n@param {string} name of the mark\n@param {Object} context Context Object\n@export\n@public"
          },
          "createMarkNode": {
            "!type": "fn(ns: string, name: string, eventType: string, options: ?) -> Aura.Services.MetricsService.prototype.mark.!ret",
            "!span": "21619[655:39]-21633[655:53]",
            "!doc": "Creates a mark node\n@param {string} ns Namespace of the mark\n@param {string} name of the mark\n@param {string} eventType Type of the mark\n@param {Object} options Options\n@private"
          },
          "clearMarks": {
            "!type": "fn(ns: ?)",
            "!span": "22074[672:39]-22084[672:49]",
            "!doc": "Clear Marks\n@param {?string=} ns Namespace of the marks to clean\n@public\n@export"
          },
          "getPageStartTime": {
            "!type": "fn() -> !this.pageStartTime",
            "!span": "22452[688:39]-22468[688:55]",
            "!doc": "Get the page firstByte timestamp from either performance API or a mark in the page\n@private"
          },
          "time": {
            "!type": "fn() -> number|?",
            "!span": "22992[709:39]-22996[709:43]",
            "!doc": "Generates a bootstrap mark\n@param {string} mark Key of the mark\n@param {?} value Value of the mark\n@public\n@export"
          },
          "microsecondsResolution": {
            "!type": "fn() -> bool",
            "!span": "23221[718:39]-23243[718:61]",
            "!doc": "Returns if the resolution is microseconds (using the performance API if supported)\n@public\n@export"
          },
          "disablePlugins": {
            "!type": "fn()",
            "!span": "23407[728:39]-23421[728:53]",
            "!doc": "Disable all plugins\n@public\n@export"
          },
          "disablePlugin": {
            "!type": "fn(name: string)",
            "!span": "23660[740:39]-23673[740:52]",
            "!doc": "Diable a plugin by name\n@param {string} name Name of the plugin\n@public\n@export"
          },
          "enablePlugins": {
            "!type": "fn()",
            "!span": "23905[752:39]-23918[752:52]",
            "!doc": "Enable all plugins\n@public\n@export"
          },
          "enablePlugin": {
            "!type": "fn(name: string)",
            "!span": "24154[764:39]-24166[764:51]",
            "!doc": "Enable plugin by name\n@param {string} name Name of the plugin\n@public\n@export"
          },
          "registerPlugin": {
            "!type": "fn(pluginConfig: ?)",
            "!span": "24463[777:39]-24477[777:53]",
            "!doc": "Register a plugin for metricsServices\n@param {Object} pluginConfig A plugin object\n@public\n@export"
          },
          "registerBeacon": {
            "!type": "fn(beacon: ?)",
            "!span": "24993[793:39]-25007[793:53]",
            "!doc": "Register a beacon (transport layer) on which to send the finishes transactions\n@param {Object} beacon Beacon object that hold a \"sendData\" method\n@public\n@export"
          },
          "getBootstrapMetrics": {
            "!type": "fn() -> !this.bootstrap",
            "!span": "25333[803:39]-25352[803:58]",
            "!doc": "Returns a JSON Object which contains the bootstrap metrics of the framework and the application\n@public\n@return {Object}\n@export"
          }
        },
        "VERSION": {
          "!type": "string",
          "!span": "1368[37:29]-1375[37:36]",
          "!doc": "Version"
        },
        "PERFTIME": {
          "!type": "bool",
          "!span": "1418[39:29]-1426[39:37]"
        },
        "START": {
          "!type": "string",
          "!span": "1684[41:29]-1689[41:34]"
        },
        "END": {
          "!type": "string",
          "!span": "1733[42:29]-1736[42:32]"
        },
        "STAMP": {
          "!type": "string",
          "!span": "1780[43:29]-1785[43:34]"
        },
        "DEFAULT": {
          "!type": "string",
          "!span": "1829[44:29]-1836[44:36]"
        },
        "MAXTIME": {
          "!type": "number",
          "!span": "1880[45:29]-1887[45:36]"
        },
        "!type": "fn()",
        "!span": "736[23:14]-750[23:28]",
        "!doc": "@description The metrics service implementation\n@constructor\n@export",
        "collector": {
          "default": {
            "!type": "[?]",
            "!span": "820[24:39]-829[24:48]"
          },
          "<i>": {
            "!type": "[?]",
            "!span": "4898[144:19]-4908[144:29]"
          },
          "!span": "790[24:9]-799[24:18]"
        },
        "globalHandlers": {
          "transactionEnd": {
            "!type": "[?]",
            "!span": "876[25:39]-892[25:55]"
          },
          "transactionsKilled": {
            "!type": "[?]",
            "!span": "898[25:61]-918[25:81]"
          },
          "!span": "846[25:9]-860[25:23]"
        },
        "bootstrap": {
          "<i>": {
            "!type": "number",
            "!span": "25586[810:22]-25587[810:23]"
          },
          "cache": {
            "appCache": {
              "!type": "bool",
              "!span": "25789[816:12]-25799[816:22]"
            },
            "!span": "25764[815:18]-25771[815:25]"
          },
          "timing": {
            "appCache": {
              "!type": "number",
              "!span": "27238[844:16]-27248[844:26]"
            },
            "redirectTime": {
              "!type": "number",
              "!span": "27312[845:16]-27326[845:30]"
            },
            "!span": "26115[823:22]-26123[823:30]"
          },
          "requests": {
            "!type": "[Aura.Services.MetricsService.bootstrap.requests.<i>]",
            "!span": "29134[879:26]-29144[879:36]"
          },
          "!span": "935[26:9]-944[26:18]"
        },
        "registeredPlugins": {
          "!span": "976[27:9]-993[27:26]",
          "<i>": "TransportMetricsPlugin"
        },
        "pluginInstances": {
          "!span": "1017[28:9]-1032[28:24]",
          "<i>": "TransportMetricsPlugin"
        },
        "beaconProviders": {
          "!span": "1058[29:9]-1073[29:24]",
          "!doc": "#if {\"modes\" : [\"PRODUCTION\"]}"
        },
        "transactions": {
          "<i>": {
            "id": {
              "!type": "string",
              "!span": "19133[578:12]-19137[578:16]"
            },
            "offsets": {
              "<i>": {
                "!type": "number",
                "!span": "19405[586:16]-19406[586:17]"
              },
              "!span": "19167[579:12]-19176[579:21]"
            },
            "ts": {
              "!type": "number",
              "!span": "19201[580:12]-19205[580:16]"
            },
            "!span": "13614[389:30]-13619[389:35]"
          },
          "!span": "1099[30:9]-1111[30:21]"
        },
        "doneBootstrap": {
          "!type": "bool",
          "!span": "1140[31:9]-1153[31:22]"
        },
        "pluginsInitialized": {
          "!type": "bool",
          "!span": "1184[32:9]-1202[32:27]"
        },
        "clearCompleteTransactions": {
          "!type": "bool",
          "!span": "1228[33:9]-1253[33:34]"
        },
        "_isDisconnected": {
          "!type": "bool",
          "!span": "9649[176:4146]-9664[176:4161]"
        },
        "lastSendTime": {
          "!type": "number",
          "!span": "68475[176:62972]-68487[176:62984]"
        },
        "state": {
          "!type": "string",
          "!span": "29416[176:23913]-29421[176:23918]"
        },
        "needsCleaning": {
          "!type": "bool",
          "!span": "19844[176:14341]-19857[176:14354]"
        },
        "fired": {
          "!type": "bool",
          "!span": "8367[176:2864]-8372[176:2869]"
        }
      },
      "AuraStorageService": {
        "prototype": {
          "CryptoAdapter": {
            "NAME": {
              "!type": "string",
              "!span": "3096[78:14]-3100[78:18]",
              "!doc": "Name of adapter."
            },
            "LOG_LEVEL": {
              "INFO": {
                "id": {
                  "!type": "number",
                  "!span": "3175[82:15]-3177[82:17]"
                },
                "fn": {
                  "!type": "string",
                  "!span": "3182[82:22]-3184[82:24]"
                }
              },
              "WARNING": {
                "id": {
                  "!type": "number",
                  "!span": "3210[83:15]-3212[83:17]"
                },
                "fn": {
                  "!type": "string",
                  "!span": "3217[83:22]-3219[83:24]"
                }
              }
            },
            "ALGO": {
              "!type": "string",
              "!span": "3281[88:14]-3285[88:18]",
              "!doc": "Encryption algorithm."
            },
            "IV_LENGTH": {
              "!type": "number",
              "!span": "3359[91:14]-3368[91:23]",
              "!doc": "Initialization vector length (bytes)."
            },
            "SENTINEL": {
              "!type": "string",
              "!span": "3459[94:14]-3467[94:22]",
              "!doc": "A sentinel value to verify the key against pre-existing data."
            },
            "engine": "crypto",
            "setKey": "CryptoAdapter.setKey",
            "register": "CryptoAdapter.register",
            "prototype": {
              "getName": "CryptoAdapter.prototype.getName",
              "fallbackToMemoryAdapter": "CryptoAdapter.prototype.fallbackToMemoryAdapter",
              "initialize": "CryptoAdapter.prototype.initialize",
              "isCrypto": "CryptoAdapter.prototype.isCrypto",
              "executeQueue": "CryptoAdapter.prototype.executeQueue",
              "getInitializationError": "CryptoAdapter.prototype.getInitializationError",
              "enqueue": "CryptoAdapter.prototype.enqueue",
              "getSize": "CryptoAdapter.prototype.getSize",
              "getItem": "CryptoAdapter.prototype.getItem",
              "getItemInternal": "CryptoAdapter.prototype.getItemInternal",
              "decrypt": "CryptoAdapter.prototype.decrypt",
              "getAll": "CryptoAdapter.prototype.getAll",
              "objectToArrayBuffer": "CryptoAdapter.prototype.objectToArrayBuffer",
              "arrayBufferToObject": "CryptoAdapter.prototype.arrayBufferToObject",
              "setSentinalItem": "CryptoAdapter.prototype.setSentinalItem",
              "setItem": "CryptoAdapter.prototype.setItem",
              "setItemInternal": "CryptoAdapter.prototype.setItemInternal",
              "removeItem": "CryptoAdapter.prototype.removeItem",
              "removeItemInternal": "CryptoAdapter.prototype.removeItemInternal",
              "clear": "CryptoAdapter.prototype.clear",
              "clearOnInit": "CryptoAdapter.prototype.clearOnInit",
              "sweep": "CryptoAdapter.prototype.sweep",
              "deleteStorage": "CryptoAdapter.prototype.deleteStorage",
              "suspendSweeping": "CryptoAdapter.prototype.suspendSweeping",
              "resumeSweeping": "CryptoAdapter.prototype.resumeSweeping",
              "isSecure": "CryptoAdapter.prototype.isSecure",
              "isPersistent": "CryptoAdapter.prototype.isPersistent",
              "log": "CryptoAdapter.prototype.log"
            }
          },
          "getStorage": "AuraStorageService.prototype.getStorage",
          "getStorages": "AuraStorageService.prototype.getStorages",
          "initStorage": "AuraStorageService.prototype.initStorage",
          "registerAdapter": "AuraStorageService.prototype.registerAdapter",
          "isRegisteredAdapter": "AuraStorageService.prototype.isRegisteredAdapter",
          "getAdapterConfig": "AuraStorageService.prototype.getAdapterConfig",
          "createAdapter": "AuraStorageService.prototype.createAdapter",
          "fireModified": "AuraStorageService.prototype.fireModified",
          "selectAdapter": "AuraStorageService.prototype.selectAdapter",
          "deleteStorage": "AuraStorageService.prototype.deleteStorage",
          "setVersion": "AuraStorageService.prototype.setVersion",
          "getVersion": "AuraStorageService.prototype.getVersion",
          "setIsolation": "AuraStorageService.prototype.setIsolation"
        }
      },
      "!span": "1653[53:5]-1661[53:13]",
      "AuraComponentContext": {
        "prototype": {
          "Frame": {},
          "push": "AuraComponentContext.prototype.push",
          "pop": "AuraComponentContext.prototype.pop",
          "currentContext": "AuraComponentContext.prototype.currentContext",
          "addNote": "AuraComponentContext.prototype.addNote",
          "getNote": "AuraComponentContext.prototype.getNote",
          "clearNote": "AuraComponentContext.prototype.clearNote"
        }
      },
      "AuraExpressionService": {
        "prototype": {
          "getReference": "AuraExpressionService.prototype.getReference",
          "clearReferences": "AuraExpressionService.prototype.clearReferences",
          "updateGlobalReference": "AuraExpressionService.prototype.updateGlobalReference",
          "updateGlobalReferences": "AuraExpressionService.prototype.updateGlobalReferences",
          "addListener": "AuraExpressionService.prototype.addListener",
          "removeListener": "AuraExpressionService.prototype.removeListener",
          "create": "AuraExpressionService.prototype.create",
          "createPassthroughValue": "AuraExpressionService.prototype.createPassthroughValue",
          "normalize": "AuraExpressionService.prototype.normalize",
          "resolve": "AuraExpressionService.prototype.resolve"
        }
      },
      "AuraLocalizationService": {
        "prototype": {
          "formatNumber": "AuraLocalizationService.prototype.formatNumber",
          "formatPercent": "AuraLocalizationService.prototype.formatPercent",
          "formatCurrency": "AuraLocalizationService.prototype.formatCurrency",
          "getNumberFormat": "AuraLocalizationService.prototype.getNumberFormat",
          "getDefaultNumberFormat": "AuraLocalizationService.prototype.getDefaultNumberFormat",
          "getDefaultPercentFormat": "AuraLocalizationService.prototype.getDefaultPercentFormat",
          "getDefaultCurrencyFormat": "AuraLocalizationService.prototype.getDefaultCurrencyFormat",
          "displayDuration": "AuraLocalizationService.prototype.displayDuration",
          "displayDurationInDays": "AuraLocalizationService.prototype.displayDurationInDays",
          "displayDurationInHours": "AuraLocalizationService.prototype.displayDurationInHours",
          "displayDurationInMilliseconds": "AuraLocalizationService.prototype.displayDurationInMilliseconds",
          "displayDurationInMinutes": "AuraLocalizationService.prototype.displayDurationInMinutes",
          "displayDurationInMonths": "AuraLocalizationService.prototype.displayDurationInMonths",
          "displayDurationInSeconds": "AuraLocalizationService.prototype.displayDurationInSeconds",
          "displayDurationInYears": "AuraLocalizationService.prototype.displayDurationInYears",
          "duration": "AuraLocalizationService.prototype.duration",
          "endOf": "AuraLocalizationService.prototype.endOf",
          "formatDate": "AuraLocalizationService.prototype.formatDate",
          "formatDateUTC": "AuraLocalizationService.prototype.formatDateUTC",
          "formatDateTime": "AuraLocalizationService.prototype.formatDateTime",
          "formatDateTimeUTC": "AuraLocalizationService.prototype.formatDateTimeUTC",
          "formatTime": "AuraLocalizationService.prototype.formatTime",
          "formatTimeUTC": "AuraLocalizationService.prototype.formatTimeUTC",
          "getDaysInDuration": "AuraLocalizationService.prototype.getDaysInDuration",
          "getHoursInDuration": "AuraLocalizationService.prototype.getHoursInDuration",
          "getLocalizedDateTimeLabels": "AuraLocalizationService.prototype.getLocalizedDateTimeLabels",
          "getToday": "AuraLocalizationService.prototype.getToday",
          "getDateStringBasedOnTimezone": "AuraLocalizationService.prototype.getDateStringBasedOnTimezone",
          "getMillisecondsInDuration": "AuraLocalizationService.prototype.getMillisecondsInDuration",
          "getMinutesInDuration": "AuraLocalizationService.prototype.getMinutesInDuration",
          "getMonthsInDuration": "AuraLocalizationService.prototype.getMonthsInDuration",
          "getSecondsInDuration": "AuraLocalizationService.prototype.getSecondsInDuration",
          "getYearsInDuration": "AuraLocalizationService.prototype.getYearsInDuration",
          "isPeriodTimeView": "AuraLocalizationService.prototype.isPeriodTimeView",
          "isAfter": "AuraLocalizationService.prototype.isAfter",
          "isBefore": "AuraLocalizationService.prototype.isBefore",
          "isSame": "AuraLocalizationService.prototype.isSame",
          "parseDateTime": "AuraLocalizationService.prototype.parseDateTime",
          "parseDateTimeISO8601": "AuraLocalizationService.prototype.parseDateTimeISO8601",
          "parseDateTimeUTC": "AuraLocalizationService.prototype.parseDateTimeUTC",
          "startOf": "AuraLocalizationService.prototype.startOf",
          "toISOString": "AuraLocalizationService.prototype.toISOString",
          "translateFromLocalizedDigits": "AuraLocalizationService.prototype.translateFromLocalizedDigits",
          "translateFromOtherCalendar": "AuraLocalizationService.prototype.translateFromOtherCalendar",
          "translateToLocalizedDigits": "AuraLocalizationService.prototype.translateToLocalizedDigits",
          "translateToOtherCalendar": "AuraLocalizationService.prototype.translateToOtherCalendar",
          "UTCToWallTime": "AuraLocalizationService.prototype.UTCToWallTime",
          "WallTimeToUTC": "AuraLocalizationService.prototype.WallTimeToUTC",
          "displayDateTime": "AuraLocalizationService.prototype.displayDateTime",
          "getNormalizedFormat": "AuraLocalizationService.prototype.getNormalizedFormat",
          "getStrictModeFormat": "AuraLocalizationService.prototype.getStrictModeFormat",
          "getStrictModeDateTimeString": "AuraLocalizationService.prototype.getStrictModeDateTimeString",
          "getNormalizedLangLocale": "AuraLocalizationService.prototype.getNormalizedLangLocale",
          "getTimeZoneInfo": "AuraLocalizationService.prototype.getTimeZoneInfo",
          "getUTCFromWallTime": "AuraLocalizationService.prototype.getUTCFromWallTime",
          "getWallTimeFromUTC": "AuraLocalizationService.prototype.getWallTimeFromUTC",
          "init": "AuraLocalizationService.prototype.init",
          "pad": "AuraLocalizationService.prototype.pad",
          "doublePad": "AuraLocalizationService.prototype.doublePad"
        }
      },
      "AuraStyleService": {
        "prototype": {
          "applyTokens": "AuraStyleService.prototype.applyTokens",
          "applyAllTokens": "AuraStyleService.prototype.applyAllTokens",
          "removeTokens": "AuraStyleService.prototype.removeTokens"
        }
      }
    },
    "Storage": {
      "CryptoAdapter": {
        "NAME": {
          "!type": "string",
          "!span": "3096[78:14]-3100[78:18]",
          "!doc": "Name of adapter."
        },
        "LOG_LEVEL": {
          "INFO": {
            "id": {
              "!type": "number",
              "!span": "3175[82:15]-3177[82:17]"
            },
            "fn": {
              "!type": "string",
              "!span": "3182[82:22]-3184[82:24]"
            }
          },
          "WARNING": {
            "id": {
              "!type": "number",
              "!span": "3210[83:15]-3212[83:17]"
            },
            "fn": {
              "!type": "string",
              "!span": "3217[83:22]-3219[83:24]"
            }
          }
        },
        "ALGO": {
          "!type": "string",
          "!span": "3281[88:14]-3285[88:18]",
          "!doc": "Encryption algorithm."
        },
        "IV_LENGTH": {
          "!type": "number",
          "!span": "3359[91:14]-3368[91:23]",
          "!doc": "Initialization vector length (bytes)."
        },
        "SENTINEL": {
          "!type": "string",
          "!span": "3459[94:14]-3467[94:22]",
          "!doc": "A sentinel value to verify the key against pre-existing data."
        },
        "engine": "crypto",
        "setKey": "CryptoAdapter.setKey",
        "register": "CryptoAdapter.register",
        "prototype": {
          "getName": "CryptoAdapter.prototype.getName",
          "fallbackToMemoryAdapter": "CryptoAdapter.prototype.fallbackToMemoryAdapter",
          "initialize": "CryptoAdapter.prototype.initialize",
          "isCrypto": "CryptoAdapter.prototype.isCrypto",
          "executeQueue": "CryptoAdapter.prototype.executeQueue",
          "getInitializationError": "CryptoAdapter.prototype.getInitializationError",
          "enqueue": "CryptoAdapter.prototype.enqueue",
          "getSize": "CryptoAdapter.prototype.getSize",
          "getItem": "CryptoAdapter.prototype.getItem",
          "getItemInternal": "CryptoAdapter.prototype.getItemInternal",
          "decrypt": "CryptoAdapter.prototype.decrypt",
          "getAll": "CryptoAdapter.prototype.getAll",
          "objectToArrayBuffer": "CryptoAdapter.prototype.objectToArrayBuffer",
          "arrayBufferToObject": "CryptoAdapter.prototype.arrayBufferToObject",
          "setSentinalItem": "CryptoAdapter.prototype.setSentinalItem",
          "setItem": "CryptoAdapter.prototype.setItem",
          "setItemInternal": "CryptoAdapter.prototype.setItemInternal",
          "removeItem": "CryptoAdapter.prototype.removeItem",
          "removeItemInternal": "CryptoAdapter.prototype.removeItemInternal",
          "clear": "CryptoAdapter.prototype.clear",
          "clearOnInit": "CryptoAdapter.prototype.clearOnInit",
          "sweep": "CryptoAdapter.prototype.sweep",
          "deleteStorage": "CryptoAdapter.prototype.deleteStorage",
          "suspendSweeping": "CryptoAdapter.prototype.suspendSweeping",
          "resumeSweeping": "CryptoAdapter.prototype.resumeSweeping",
          "isSecure": "CryptoAdapter.prototype.isSecure",
          "isPersistent": "CryptoAdapter.prototype.isPersistent",
          "log": "CryptoAdapter.prototype.log"
        }
      },
      "IndexedDBAdapter": {
        "NAME": {
          "!type": "string",
          "!span": "3089[81:17]-3093[81:21]",
          "!doc": "Name of the adapter"
        },
        "LOG_LEVEL": {
          "INFO": {
            "id": {
              "!type": "number",
              "!span": "3174[85:15]-3176[85:17]"
            },
            "fn": {
              "!type": "string",
              "!span": "3181[85:22]-3183[85:24]"
            }
          },
          "WARNING": {
            "id": {
              "!type": "number",
              "!span": "3209[86:15]-3211[86:17]"
            },
            "fn": {
              "!type": "string",
              "!span": "3216[86:22]-3218[86:24]"
            }
          }
        },
        "prototype": {
          "getName": "IndexedDBAdapter.prototype.getName",
          "initialize": "IndexedDBAdapter.prototype.initialize",
          "getSize": "IndexedDBAdapter.prototype.getSize",
          "getItem": "IndexedDBAdapter.prototype.getItem",
          "getAll": "IndexedDBAdapter.prototype.getAll",
          "suspendSweeping": "IndexedDBAdapter.prototype.suspendSweeping",
          "resumeSweeping": "IndexedDBAdapter.prototype.resumeSweeping",
          "setItem": "IndexedDBAdapter.prototype.setItem",
          "removeItem": "IndexedDBAdapter.prototype.removeItem",
          "clearOnInit": "IndexedDBAdapter.prototype.clearOnInit",
          "clear": "IndexedDBAdapter.prototype.clear",
          "sweep": "IndexedDBAdapter.prototype.sweep",
          "setupDB": "IndexedDBAdapter.prototype.setupDB",
          "createTables": "IndexedDBAdapter.prototype.createTables",
          "executeQueue": "IndexedDBAdapter.prototype.executeQueue",
          "getInitializationError": "IndexedDBAdapter.prototype.getInitializationError",
          "enqueue": "IndexedDBAdapter.prototype.enqueue",
          "getItemInternal": "IndexedDBAdapter.prototype.getItemInternal",
          "walkInternal": "IndexedDBAdapter.prototype.walkInternal",
          "setItemInternal": "IndexedDBAdapter.prototype.setItemInternal",
          "removeItemInternal": "IndexedDBAdapter.prototype.removeItemInternal",
          "clearInternal": "IndexedDBAdapter.prototype.clearInternal",
          "expireCache": "IndexedDBAdapter.prototype.expireCache",
          "updateSize": "IndexedDBAdapter.prototype.updateSize",
          "refreshSize": "IndexedDBAdapter.prototype.refreshSize",
          "setSize": "IndexedDBAdapter.prototype.setSize",
          "log": "IndexedDBAdapter.prototype.log",
          "deleteStorage": "IndexedDBAdapter.prototype.deleteStorage",
          "deleteStorageInternal": "IndexedDBAdapter.prototype.deleteStorageInternal"
        },
        "register": "IndexedDBAdapter.register"
      },
      "MemoryAdapter": {
        "NAME": {
          "!type": "string",
          "!span": "961[29:14]-965[29:18]"
        },
        "LOG_LEVEL": {
          "INFO": {
            "id": {
              "!type": "number",
              "!span": "1040[33:15]-1042[33:17]"
            },
            "fn": {
              "!type": "string",
              "!span": "1047[33:22]-1049[33:24]"
            }
          },
          "WARNING": {
            "id": {
              "!type": "number",
              "!span": "1075[34:15]-1077[34:17]"
            },
            "fn": {
              "!type": "string",
              "!span": "1082[34:22]-1084[34:24]"
            }
          }
        },
        "prototype": {
          "reset": "MemoryAdapter.prototype.reset",
          "getName": "MemoryAdapter.prototype.getName",
          "getSize": "MemoryAdapter.prototype.getSize",
          "getItem": "MemoryAdapter.prototype.getItem",
          "getAll": "MemoryAdapter.prototype.getAll",
          "updateMRU": "MemoryAdapter.prototype.updateMRU",
          "setItem": "MemoryAdapter.prototype.setItem",
          "removeItem": "MemoryAdapter.prototype.removeItem",
          "removeItemInternal": "MemoryAdapter.prototype.removeItemInternal",
          "clear": "MemoryAdapter.prototype.clear",
          "expireCache": "MemoryAdapter.prototype.expireCache",
          "getMRU": "MemoryAdapter.prototype.getMRU",
          "log": "MemoryAdapter.prototype.log",
          "sweep": "MemoryAdapter.prototype.sweep",
          "deleteStorage": "MemoryAdapter.prototype.deleteStorage"
        },
        "Entry": {
          "prototype": {
            "getItem": "MemoryAdapter.Entry.prototype.getItem",
            "getSize": "MemoryAdapter.Entry.prototype.getSize"
          }
        }
      },
      "AuraStorage": {
        "KEY_DELIMITER": {
          "!type": "string",
          "!span": "16785[516:12]-16798[516:25]",
          "!doc": "Storage key delimiter, separating isolation and version key from\nthe user-provided key.\n@private"
        },
        "SWEEP_INTERVAL": {
          "MIN": {
            "!type": "number",
            "!span": "16892[522:8]-16897[522:13]"
          },
          "MAX": {
            "!type": "number",
            "!span": "16923[523:8]-16928[523:13]"
          }
        },
        "prototype": {
          "getName": "AuraStorage.prototype.getName",
          "getSize": "AuraStorage.prototype.getSize",
          "getMaxSize": "AuraStorage.prototype.getMaxSize",
          "getDefaultAutoRefreshInterval": "AuraStorage.prototype.getDefaultAutoRefreshInterval",
          "clear": "AuraStorage.prototype.clear",
          "get": "AuraStorage.prototype.get",
          "inFlightOperations": "AuraStorage.prototype.inFlightOperations",
          "getAll": "AuraStorage.prototype.getAll",
          "put": "AuraStorage.prototype.put",
          "remove": "AuraStorage.prototype.remove",
          "sweep": "AuraStorage.prototype.sweep",
          "suspendSweeping": "AuraStorage.prototype.suspendSweeping",
          "resumeSweeping": "AuraStorage.prototype.resumeSweeping",
          "log": "AuraStorage.prototype.log",
          "logError": "AuraStorage.prototype.logError",
          "isPersistent": "AuraStorage.prototype.isPersistent",
          "isSecure": "AuraStorage.prototype.isSecure",
          "setVersion": "AuraStorage.prototype.setVersion",
          "getVersion": "AuraStorage.prototype.getVersion",
          "deleteStorage": "AuraStorage.prototype.deleteStorage",
          "updateKeyPrefix": "AuraStorage.prototype.updateKeyPrefix"
        }
      },
      "!span": "1675[54:5]-1682[54:12]"
    },
    "Locker": {
      "SecureObject": {
        "createFilteredMethod": {},
        "createFilteredProperty": {},
        "addIfSupported": {},
        "addMethodIfSupported": {},
        "FunctionPrototypeBind": "SecureObject.FunctionPrototypeBind",
        "ArrayPrototypeSlice": "SecureObject.ArrayPrototypeSlice",
        "isDOMElementOrNode": "SecureObject.isDOMElementOrNode",
        "addToCache": "SecureObject.addToCache",
        "getCached": "SecureObject.getCached",
        "filterEverything": {},
        "unfilterEverything": {},
        "addPropertyIfSupported": "SecureObject.addPropertyIfSupported"
      },
      "!span": "1697[55:5]-1703[55:11]"
    },
    "OverrideMap$Instance": {
      "!type": "+Aura.OverrideMap",
      "!span": "40326[1094:5]-40346[1094:25]"
    },
    "OverrideMap": {
      "!type": "fn()",
      "!span": "3894[70:5]-3905[70:16]",
      "!doc": "Ideally, this would be done with names and using the closure compiler to generate them. That would make\nthis much simpler and cleaner, including allowing us to not have separate functions for replace and restore\nit could all be done with two sets of instance/name pairs (1) plain names, (2) bound names.",
      "map": {
        "enqueueAction": {
          "!type": "+Aura.Utils.Override",
          "!span": "3958[72:8]-3973[72:23]"
        },
        "!span": "3942[71:9]-3945[71:12]",
        "ClientService": {
          "decode": "+Aura.Utils.Override",
          "send": "+Aura.Utils.Override",
          "receive": "+Aura.Utils.Override",
          "processResponses": "+Aura.Utils.Override",
          "getAvailableXHR": "+Aura.Utils.Override"
        },
        "ComponentService": {
          "createComponentPriv": "+Aura.Utils.Override"
        },
        "Action": {
          "finishAction": "+Aura.Utils.Override",
          "abort": "+Aura.Utils.Override",
          "runDeprecated": "+Aura.Utils.Override"
        },
        "Event": {
          "fire": "+Aura.Utils.Override"
        },
        "outputComponent": "+Aura.Utils.Override",
        "StorageService": {
          "selectAdapter": "+Aura.Utils.Override"
        },
        "RenderingService": {
          "addDirtyValue": "+Aura.Utils.Override"
        },
        "MetricsService": {
          "transaction": "+Aura.Utils.Override"
        }
      }
    },
    "!span": "837[22:4]-841[22:8]",
    "_Aura": "Aura"
  },
  "AuraInstance": {
    "prototype": {
      "setCurrentTransactionId": {
        "!type": "fn()",
        "!span": "20848[594:23]-20871[594:46]",
        "!doc": "Does nothing.\n\n@public\n@deprecated"
      },
      "getCurrentTransactionId": {
        "!type": "fn()",
        "!span": "20990[603:23]-21013[603:46]",
        "!doc": "Does nothing.\n\n@returns undefined\n@public\n@deprecated"
      },
      "initAsync": {
        "!type": "fn(config: ?)",
        "!span": "21853[617:23]-21862[617:32]",
        "!doc": "Initializes Aura with context info about the app that should be loaded.\n@param {Object} config\n\n{\n     <code>config.descriptor</code> : The descriptor of the application or component that should be loaded as the root. For example, <code>\"markup://foo:bar\"</code><br />\n     <code>config.attributes</code> : The attributes that should be passed into the root component when it is constructed. For example, <code>{at1 : 1, at2 : \"asdf\"}</code><br />\n     <code>config.defType</code> : The defType of the descriptor.  For example, <code>\"DEFINITION\"</code> or <code>\"APPLICATION\"</code><br />\n     <code>config.lastmod</code> : The timestamp, in millis of the latest changes to the preloaded metadata associated with this application.\n}\n@public"
      },
      "setLanguage": {
        "!type": "fn()",
        "!span": "26351[716:23]-26362[716:34]",
        "!doc": "Set the language for the HTML document.\n\nThis must be called after the context is initialized and we have our GVPs set up."
      },
      "initConfig": {
        "!type": "fn(config: ?, useExisting: bool, doNotInitializeServices: bool)",
        "!span": "27197[734:23]-27207[734:33]",
        "!doc": "Initializes Aura with context info but without retrieving component from server. Used for synchronous initialization.\n\nWhoever named this function should be shot, but I won't rename for now. Eventually we want to use\nstartApplication, and make it either auto-require app.js or have the caller load app.js and then invoke\nstartApplication with the data.\n\n@param {Object} config The configuration attributes\n@param {Boolean} useExisting\n@param {Boolean} doNotInitializeServices Set to true if the History service should not be initialized, or false if\n  it should. Defaults to true for Aura Integration Service.\n@public"
      },
      "initPriv": {
        "!type": "fn(config: ?, token: string, container: ?, doNotInitializeServices?: bool)",
        "!span": "28565[763:23]-28573[763:31]",
        "!doc": "Initializes Aura in debug environment.\n\n@param {Object} config The descriptor (\"markup://foo:bar\"), attributes, defType (\"APPLICATION\" or \"COMPONENT\"), and\n       timestamp of last modified change\n@param {String} token\n@param {Object} container Sets the container for the component.\n@param {Boolean=} doNotInitializeServices True if the History service should not be initialized, or false if\n       it should. Defaults to true for Aura Integration Service.\n@private"
      },
      "addTearDownHandler": {
        "!type": "fn()",
        "!span": "29197[782:23]-29215[782:41]",
        "!doc": "Add default handler to aura:systemError event\n@private"
      },
      "addDefaultErrorHandler": {
        "!type": "fn(app: AuraClientService.prototype.decode.!ret|bool)",
        "!span": "29433[790:23]-29455[790:45]",
        "!doc": "Add default handler to aura:systemError event\n@private"
      },
      "finishInit": {
        "!type": "fn(doNotInitializeServices: bool)",
        "!span": "29866[806:23]-29876[806:33]",
        "!doc": "Signals that initialization has completed.\n@private"
      },
      "showErrors": {
        "!type": "fn(toggle?: bool) -> !this.displayErrors",
        "!span": "31235[846:23]-31245[846:33]",
        "!doc": "Optionally sets and returns whether to display error dialog\n\n@private\n@param {Boolean} [toggle] toggles display of error dialog\n@returns {Boolean} whether to display error dialog"
      },
      "handleError": {
        "!type": "fn(message: ?, e: ?)",
        "!span": "31421[856:23]-31432[856:34]",
        "!doc": "@private"
      },
      "reportError": {
        "!type": "fn(message: ?, error: ?)",
        "!span": "33470[907:23]-33481[907:34]",
        "!doc": "Report error to the server after handling it.\nNote that the method should only be used if try-catch mechanism\nof error handling is not desired or not functional (ex: in nested promises)\n@public\n@param {String} message The message to display.\n@param {Error} error An error object to be included in handling and reporting.\n@platform"
      },
      "warning": {
        "!type": "fn(w: string, e: +Error)",
        "!span": "34915[942:23]-34922[942:30]",
        "!doc": "<code>$A.warning()</code> should be used in the case where poor programming practices have been used.\n\nThese warnings will not, in general, be displayed to the user, but they will appear in the console (if\navailiable), and in the aura debug window.\n\n@public\n@param {String} w The message to display.\n@param {Error} e an error, if any.\n@platform"
      },
      "message": {
        "!type": "fn(msg: string)",
        "!span": "35205[953:23]-35212[953:30]",
        "!doc": "Displays an error message to the user. Currently used for displaying errors that do not cause the application to\nstop completely.\n\n@public\n@param {String} msg The message to display."
      },
      "getCallback": {
        "!type": "fn(callback: fn()|+Function) -> fn()",
        "!span": "35794[973:23]-35805[973:34]",
        "!doc": "Returns a callback which is safe to invoke from outside Aura, e.g. as an event handler or in a setTimeout.\n@public\n@function\n@param {Function} callback The method to call after reestablishing Aura context.\n@platform"
      },
      "getToken": {
        "!type": "fn(token: string)",
        "!span": "37435[1014:23]-37443[1014:31]",
        "!doc": "Returns the application token referenced by name.\n@function\n@param {String} token The name of the application configuration token to retrieve, for example, <code>$A.getToken(\"section.configuration\")</code>.\n@public\n@platform"
      },
      "get": {
        "!type": "fn(key: string, callback: +Function) -> AuraInstance.context.contextGlobals",
        "!span": "38152[1033:23]-38155[1033:26]",
        "!doc": "Returns the value referenced using property syntax. Gets the value from the specified global value provider.\n@public\n@function\n@param {String} key The data key to look up on element, for example, <code>$A.get(\"$Label.section.key\")</code>.\n@param {Function} callback The method to call with the result if a server trip is expected.\n@platform"
      },
      "set": {
        "!type": "fn(key: string, value: ?)",
        "!span": "39299[1063:23]-39302[1063:26]",
        "!doc": "Sets the value referenced using property syntax on the specified global value provider.\n@public\n@function\n@param {String} key The data key we want to change on the global value provider, for example, <code>$A.set(\"$Custom.something\",\"new Value\")</code>.\n@param {Object} value The value to set the key location to. If the global value provider does not implement .set(), this method will throw an exception.</code>.\n@platform"
      },
      "getReference": {
        "!type": "fn(key: string|?) -> +PropertyReferenceValue",
        "!span": "40235[1090:23]-40247[1090:35]",
        "!doc": "Returns a live reference to the global value indicated using property syntax.\n\n@param {String} key The data key for which to return a reference.\n@return {PropertyReferenceValue}\n@public\n@platform\n@export"
      },
      "installOverride": {
        "!type": "fn(name: string, fn: +Function, scope: ?, priority: number)",
        "!span": "40829[1107:23]-40844[1107:38]",
        "!doc": "Override a function in aura.\n\nThis should only be available to plugins, and only works on functions designed for this purpose.\n\n@param {string} name the name of the override point\n@param {Function} fn the function to insert in the chain.\n@param {Object} scope a scope for invoking the function.\n@param {number} priority a priority for the function (0 = highest -> first, 100 = lowest ->last, default 50)\n@public"
      },
      "uninstallOverride": {
        "!type": "fn(name: string, fn: fn())",
        "!span": "41455[1127:23]-41472[1127:40]",
        "!doc": "Remore an override in aura.\n\n@public"
      },
      "getRoot": {
        "!type": "fn() -> !this.root",
        "!span": "42064[1144:23]-42071[1144:30]",
        "!doc": "Gets the component that is passed to a controller method. For example, <code>$A.getRoot().get(\"v.attrName\");</code> returns the attribute from the root component.\n@public\n@function\n@platform"
      },
      "setRoot": {
        "!type": "fn(root: AuraClientService.prototype.decode.!ret|bool)",
        "!span": "42156[1151:23]-42163[1151:30]",
        "!doc": "@private"
      },
      "getContext": {
        "!type": "fn() -> !this.context",
        "!span": "42429[1162:23]-42439[1162:33]",
        "!doc": "Gets the current <code>AuraContext</code>. The context consists of the mode, descriptor, and namespaces to be loaded.\n\n@public\n@function\n@return {AuraContext} current context"
      },
      "run": {
        "!type": "fn(func: +Function|fn(), name: string)",
        "!span": "42917[1178:23]-42920[1178:26]",
        "!doc": "Runs a function within the standard Aura lifecycle.\n\nThis ensures that <code>enqueueAction</code> methods and rerendering are handled properly.\n\nfrom JavaScript outside of controllers, renderers, providers.\n@param {Function} func The function to run.\n@param {String} name an optional name for the stack.\n@public\n@platform\n@deprecated Use <code>getCallback()</code> instead."
      },
      "assert": {
        "!type": "fn(condition: ?, assertMessage: string)",
        "!span": "44439[1215:23]-44445[1215:29]",
        "!doc": "Checks the condition and if the condition is false, displays an error message.\n\nDisplays an error message if condition is false, runs <code>trace()</code> and stops JS execution. The\napp will cease to function until reloaded if this is called, and errors are not caught.\nInternal assertion, should never happen\n<p>For example, <code>$A.assert(cmp.get(\"v.name\") , \"The name attribute is required.\");</code> checks for the name attribute.\n\nThis is protected as it is an internal assertion, should never happen.\n\n@param {Boolean} condition True prevents the error message from being displayed, or false otherwise.\n@param {String} assertMessage A message to be displayed when condition is false"
      },
      "userAssert": {
        "!type": "fn(condition: bool, msg: string)",
        "!span": "44956[1227:23]-44966[1227:33]",
        "!doc": "Checks for a specified user condition, only to be used for fatal errors!. Displays an error message if condition is\nfalse, and stops JS execution. The app will cease to function until reloaded if this is called.\n\n@param {Boolean} condition The conditional expression to be evaluated.\n@param {String} msg The message to be displayed when the condition is false.\n@public"
      },
      "log": {
        "!type": "fn(value: string|?, error: AuraInstance.prototype.log.!1)",
        "!span": "45653[1244:23]-45656[1244:26]",
        "!doc": " Logs to the browser's JavaScript console if it is available.\n This method doesn't log in PROD or PRODDEBUG modes.\n If both value and error are passed in, value shows up in the console as a group with value logged within the group.\n If only value is passed in, value is logged without grouping.\n <p>For example, <code>$A.log(action.getError());</code> logs the error from an action.</p>\n\n@public\n@param {Object} value The first object to log.\n@param {Object} error The error messages to be logged in the stack trace.\n@platform"
      },
      "trace": {
        "!type": "fn()",
        "!span": "45878[1252:23]-45883[1252:28]",
        "!doc": "Logs a stack trace. Trace calls using <code>console.trace()</code> if defined on the console implementation.\n@public"
      },
      "setMode": {
        "!type": "fn(mode: string)",
        "!span": "46217[1264:23]-46224[1264:30]",
        "!doc": "Sets mode to production (default), development, or testing.\n\n@param {String} mode Possible values are production \"PROD\", development \"DEV\", or testing \"PTEST\".\n@private"
      },
      "getValueProvider": {
        "!type": "fn(type: string) -> AuraInstance.context.contextGlobals",
        "!span": "46575[1276:23]-46591[1276:39]",
        "!doc": "Get GVP directly.\n@param {String} type The type of global value provider to retrieve.\n@return {GlobalValueProvider} The global value provider, such as $Label, $Browser, $Locale, etc.\n\n@private"
      },
      "addValueProvider": {
        "!type": "fn(type: string, valueProvider: ?)",
        "!span": "47168[1289:23]-47184[1289:39]",
        "!doc": "jslint sub: true"
      },
      "getDefinition": {
        "!type": "fn(descriptor: string, callback: +Function)",
        "!span": "48605[1313:23]-48618[1313:36]",
        "!doc": "Gets the event or component definition. If it is not currently on the client, we will access the server to attempt to retrieve it.\n\n@public\n\n@param  {String}   descriptor Descriptor in the pattern prefix:name or markup://prefix:name. Use e.prefix:name, or markup://e.prefix:name for an event definition.\n@param  {Function} callback   Function whos first parameter is the requested definition if it exists. Otherwise the first parameter is null.\n@return undefined"
      },
      "getDefinitions": {
        "!type": "fn(descriptors: [?], callback: +Function)",
        "!span": "49720[1330:23]-49734[1330:37]",
        "!doc": "Similar to $A.getDefinition() will retrieve an array of definitions at one time. Optimal if you expect them not to be available on the client.\n@public\n@param  {Array}   descriptors An Array of Descriptors in the format expected by $A.getDefinition() can be a mix of events and component descriptors.\n@param  {Function} callback   Function whos first parameter is an array of the definitions requested. Some definitions may be null, which are those definitions you don't have access to or did not exist.\n@return undefined             Always use the callback to access the definitions you requested."
      },
      "hasDefinition": {
        "!type": "fn(descriptor: string) -> bool",
        "!span": "52784[1404:23]-52797[1404:36]",
        "!doc": "Detect if a definition is present on the client. May still exist on the server.\n@public\n@param  {String}   descriptor Descriptor in the pattern prefix:name. Use e.prefix:name for an event definition.\n@return {Boolean}             True if the definition is present on the client."
      },
      "Perf": {
        "currentLogLevel": {
          "name": {
            "!type": "string",
            "!span": "1153[44:8]-1157[44:12]"
          },
          "value": {
            "!type": "number",
            "!span": "1180[45:8]-1185[45:13]"
          }
        },
        "enabled": {
          "!type": "bool",
          "!span": "7558[299:4]-7565[299:11]",
          "!doc": "Whether the full Kylie framework is loaded, as opposed to just the stubs.\n\n@type {boolean}\n@const"
        },
        "mark": "PerfShim.mark",
        "endMark": "PerfShim.endMark",
        "startTransaction": "PerfShim.startTransaction",
        "endTransaction": "PerfShim.endTransaction",
        "updateTransaction": "PerfShim.updateTransaction",
        "toJson": "PerfShim.toJson",
        "setBeaconData": "PerfShim.setBeaconData",
        "getBeaconData": "PerfShim.getBeaconData",
        "clearBeaconData": "PerfShim.clearBeaconData",
        "removeStats": "PerfShim.removeStats",
        "updateMarkName": "PerfShim.updateMarkName",
        "measureToJson": "PerfShim.measureToJson",
        "setTimer": "PerfShim.setTimer",
        "toPostVar": "PerfShim.toPostVar",
        "getMeasures": "PerfShim.getMeasures",
        "stat": "PerfShim.stat",
        "getStat": "PerfShim.getStat",
        "onLoad": "PerfShim.onLoad",
        "isOnLoadFired": "PerfShim.isOnLoadFired",
        "util": {
          "setCookie": "PerfShim.util.setCookie"
        }
      },
      "mark": "PerfShim.mark",
      "endMark": "PerfShim.endMark",
      "toJson": "PerfShim.toJson",
      "getBeaconData": "PerfShim.getBeaconData",
      "setBeaconData": "PerfShim.setBeaconData",
      "clearBeaconData": "PerfShim.clearBeaconData",
      "removeStats": "PerfShim.removeStats",
      "startTransaction": "PerfShim.startTransaction",
      "endTransaction": "PerfShim.endTransaction",
      "updateTransaction": "PerfShim.updateTransaction",
      "error": "AuraInstance.error"
    },
    "!type": "fn()",
    "!span": "8197[218:9]-8209[218:21]",
    "!doc": "@class Aura\n@classdesc The Aura framework. Default global instance name is $A.\n@constructor\n\n@borrows Aura.Services.AuraClientService#enqueueAction as enqueueAction\n@borrows Aura.Services.AuraClientService#deferAction as deferAction\n@borrows Aura.Services.AuraRenderingService#render as render\n@borrows Aura.Services.AuraRenderingService#rerender as rerender\n@borrows Aura.Services.AuraRenderingService#unrender as unrender\n@borrows Aura.Services.AuraRenderingService#afterRender as afterRender\n@borrows Aura.Services.AuraComponentService#get as getCmp\n@borrows Aura.Services.AuraComponentService#createComponent as createComponent\n@borrows Aura.Services.AuraComponentService#createComponents as createComponents\n@borrows Aura.Services.AuraComponentService#getComponent as getComponent\n@borrows Aura.Services.AuraComponentService#newComponentDeprecated as newCmp\n@borrows Aura.Services.AuraComponentService#newComponentDeprecated as newCmpDeprecated\n@borrows Aura.Services.AuraComponentService#newComponentAsync as newCmpAsync\n@borrows Aura.Services.AuraEventService.newEvent as getEvt",
    "globalValueProviders": {
      "!span": "8224[219:9]-8244[219:29]",
      "!doc": "Restore original provider (order doesn't matter)"
    },
    "displayErrors": {
      "!type": "bool",
      "!span": "8260[220:9]-8273[220:22]"
    },
    "logger": {
      "!type": "+Logger",
      "!span": "8299[222:9]-8305[222:15]"
    },
    "util": {
      "!type": "+Aura.Utils.Util",
      "!span": "8608[231:9]-8612[231:13]",
      "!doc": "Collection of basic utility methods to operate on the DOM and Aura Components. <br/>\nSee the documentation for <a href=\"#reference?topic=api:Util\">Util</a> for the members.\n\n@type $A.ns.Util\n@platform"
    },
    "auraFriendlyError": {
      "prototype": {
        "name": {
          "!type": "string",
          "!span": "1031[26:9]-1035[26:13]"
        },
        "message": {
          "!type": "string",
          "!span": "1066[27:9]-1073[27:16]"
        },
        "stackTrace": {
          "!type": "string",
          "!span": "1092[28:9]-1102[28:19]"
        },
        "component": {
          "!type": "string",
          "!span": "1188[32:9]-1197[32:18]",
          "!doc": "keep the root cause failing descriptor"
        },
        "action": {
          "length": {
            "!type": "number",
            "!span": "66402[176:60899]-66408[176:60905]"
          },
          "marker": {
            "!type": "number",
            "!span": "66474[176:60971]-66480[176:60977]"
          },
          "request": "+XMLHttpRequest"
        },
        "id": {
          "!type": "string",
          "!span": "1301[38:9]-1303[38:11]",
          "!doc": "client side error id"
        },
        "handled": {
          "!type": "bool",
          "!span": "3962[111:9]-3971[111:18]"
        },
        "reported": {
          "!type": "bool",
          "!span": "3991[112:9]-4001[112:19]"
        },
        "constructor": "AuraInstance.auraFriendlyError",
        "toString": "AuraInstance.lastKnownError.toString"
      },
      "!type": "fn()",
      "!span": "8797[235:9]-8814[235:26]",
      "!doc": "@description Creates an AuraFriendlyError instance.\n@constructor\n@param {String} message - the detail message about the error.\n@param {Object} innerError - an Error object whose properties are to be placed into AuraFriendlyError.\n@param {String} severity - the severity of the error. Aura built-in values are defined in $A.severity.\n@export"
    },
    "severity": {
      "ALERT": {
        "!type": "string",
        "!span": "9665[252:8]-9670[252:13]"
      },
      "FATAL": {
        "!type": "string",
        "!span": "9689[253:8]-9694[253:13]"
      },
      "QUIET": {
        "!type": "string",
        "!span": "9713[254:8]-9718[254:13]"
      },
      "!span": "9644[251:9]-9652[251:17]",
      "!doc": "work around closure compiler"
    },
    "lastKnownError": {
      "name": {
        "!type": "string",
        "!span": "1031[26:9]-1035[26:13]"
      },
      "message": {
        "!type": "string",
        "!span": "1066[27:9]-1073[27:16]"
      },
      "stackTrace": {
        "!type": "string",
        "!span": "1092[28:9]-1102[28:19]"
      },
      "component": {
        "!type": "string",
        "!span": "1188[32:9]-1197[32:18]",
        "!doc": "keep the root cause failing descriptor"
      },
      "action": {
        "length": {
          "!type": "number",
          "!span": "66402[176:60899]-66408[176:60905]"
        },
        "marker": {
          "!type": "number",
          "!span": "66474[176:60971]-66480[176:60977]"
        },
        "request": "+XMLHttpRequest"
      },
      "id": {
        "!type": "string",
        "!span": "1301[38:9]-1303[38:11]",
        "!doc": "client side error id"
      },
      "handled": {
        "!type": "bool",
        "!span": "3962[111:9]-3971[111:18]"
      },
      "reported": {
        "!type": "bool",
        "!span": "3991[112:9]-4001[112:19]"
      },
      "toString": {
        "!type": "fn() -> string",
        "!span": "1364[32:40]-1372[32:48]"
      },
      "!proto": "AuraError.prototype",
      "!span": "9745[257:9]-9759[257:23]",
      "constructor": "AuraInstance.auraFriendlyError"
    },
    "localizationService": {
      "!type": "+AuraLocalizationService",
      "!span": "10150[266:9]-10169[266:28]",
      "!doc": "Instance of the AuraLocalizationService which provides utility methods for localizing data or getting formatters for numbers, currencies, dates, etc.<br/>\nSee the documentation for <a href=\"#reference?topic=api:AuraLocalizationService\">AuraLocalizationService</a> for the members.\n\n@type AuraLocalizationService\n@platform"
    },
    "clientService": {
      "!type": "+AuraClientService",
      "!span": "10227[267:9]-10240[267:22]",
      "!doc": "For cacheable actions check the storage service to see if we already have a viable cached action\nresponse we can complete immediately. In this case, we get a callback, so we create a callback\nfor each one (ugh, this could have been handled via passing an additional param to the action,\nbut we don't have that luxury now.)"
    },
    "componentService": {
      "!type": "+AuraComponentService",
      "!span": "10298[268:9]-10314[268:25]"
    },
    "renderingService": {
      "!type": "+AuraRenderingService",
      "!span": "10372[269:9]-10388[269:25]"
    },
    "expressionService": {
      "!type": "+AuraExpressionService",
      "!span": "10446[270:9]-10463[270:26]"
    },
    "historyService": {
      "!type": "+AuraHistoryService",
      "!span": "10521[271:9]-10535[271:23]",
      "!doc": "Check for HTML5 window.history.pushState support"
    },
    "eventService": {
      "!type": "+AuraEventService",
      "!span": "10593[272:9]-10605[272:21]"
    },
    "storageService": {
      "!type": "+AuraStorageService",
      "!span": "10663[273:9]-10677[273:23]"
    },
    "styleService": {
      "!type": "+AuraStyleService",
      "!span": "10735[274:9]-10747[274:21]"
    },
    "metricsService": {
      "!type": "+Aura.Services.MetricsService",
      "!span": "10805[275:9]-10819[275:23]"
    },
    "lockerService": {
      "isEnabled": {
        "!type": "fn()",
        "!span": "3605[149:2]-3614[149:11]"
      },
      "createForDef": {
        "!type": "fn(code: ?, def: ?) -> AuraInstance.lockerService.createForDef.!ret",
        "!span": "3690[153:2]-3702[153:14]"
      },
      "getEnv": {
        "!type": "fn(key: SecureAura.!1, doNotCreate: ?) -> SecureWindow.!ret",
        "!span": "4179[165:2]-4185[165:8]"
      },
      "getEnvForSecureObject": {
        "!type": "fn(st: SecureDOMEvent.!ret, doNotCreate: ?) -> SecureWindow.!ret",
        "!span": "4461[175:2]-4482[175:23]"
      },
      "create": {
        "!type": "fn(code: ?, key: SecureAura.!1, optionalSourceURL: string) -> AuraInstance.lockerService.createForDef.!ret",
        "!span": "4642[180:2]-4648[180:8]"
      },
      "destroy": {
        "!type": "fn(locker: ?)",
        "!span": "5666[210:2]-5673[210:9]"
      },
      "destroyAll": {
        "!type": "fn()",
        "!span": "5799[217:2]-5809[217:12]"
      },
      "wrapComponent": {
        "!type": "fn(component: +Component|+Aura.Utils.Util.prototype.globalEval.!ret) -> !0",
        "!span": "5879[222:2]-5892[222:15]"
      },
      "wrapComponentEvent": {
        "!type": "fn(component: +Component, event: ?) -> !1",
        "!span": "6385[244:2]-6403[244:20]"
      },
      "unwrap": {
        "!type": "fn(st: ?) -> !0.<i>.!ret",
        "!span": "6866[258:2]-6872[258:8]"
      },
      "trust": {
        "!type": "fn(from: ?)",
        "!span": "7147[267:2]-7152[267:7]"
      },
      "markOpaque": {
        "!type": "fn(st: ?)",
        "!span": "7353[276:2]-7363[276:12]"
      },
      "isOpaque": {
        "!type": "fn(st: goog.exportSymbol.!1) -> bool",
        "!span": "7429[280:2]-7437[280:10]"
      },
      "showLockedNodes": {
        "!type": "fn(root: +Document|+Element)",
        "!span": "7575[285:2]-7590[285:17]"
      },
      "util": {
        "getKeyForNamespace": {
          "!type": "fn(namespace: ?) -> SecureAura.!1",
          "!span": "7946[304:3]-7964[304:21]"
        },
        "isKeyed": {
          "!type": "fn(thing: ?) -> bool",
          "!span": "8199[316:3]-8206[316:10]"
        },
        "hasAccess": {
          "!type": "fn(from: ?, to: ?) -> bool",
          "!span": "8293[320:3]-8302[320:12]"
        },
        "verifyAccess": {
          "!type": "fn(from: ?, to: ?, options: ?)",
          "!span": "8488[327:3]-8500[327:15]"
        },
        "applyKey": {
          "!type": "fn(thing: ?, key: SecureAura.!1)",
          "!span": "8878[339:3]-8886[339:11]"
        },
        "!span": "7907[302:9]-7911[302:13]"
      },
      "!span": "10873[276:9]-10886[276:22]",
      "!doc": "defining LockerService as a service"
    },
    "devToolService": {
      "views": {
        "componentDef": {
          "!type": "fn() -> [?]",
          "!span": "1709[71:12]-1723[71:26]"
        },
        "controllerDef": {
          "!type": "fn() -> [+ControllerDef]",
          "!span": "1849[74:12]-1864[74:27]"
        },
        "modelDef": {
          "!type": "fn() -> [+ModelDef]",
          "!span": "1991[77:12]-2001[77:22]"
        },
        "functionCallValue": {
          "!type": "fn() -> [valueFactory.valueIndex]",
          "!span": "2164[82:12]-2183[82:31]"
        },
        "passthroughValue": {
          "!type": "fn() -> [?]",
          "!span": "2309[85:12]-2327[85:30]"
        },
        "PropertyReferenceValue": {
          "!type": "fn() -> [valueFactory.valueIndex]",
          "!span": "2452[88:12]-2476[88:36]"
        },
        "value": {
          "!type": "fn() -> [?]",
          "!span": "2607[91:12]-2614[91:19]"
        },
        "rerenderings": {
          "!type": "fn() -> [AuraRenderingService.prototype.statsIndex.rerenderDirty.<i>]",
          "!span": "3046[103:12]-3060[103:26]"
        },
        "renderings": {
          "!type": "fn() -> [?]",
          "!span": "3175[107:12]-3187[107:24]"
        },
        "event": {
          "!type": "fn() -> [Aura.Event.Event.prototype.statsIndex.<i>]",
          "!span": "3740[123:12]-3747[123:19]"
        },
        "!span": "1552[67:8]-1559[67:15]",
        "component": {}
      },
      "filters": {
        "!span": "3865[129:8]-3874[129:17]",
        "noop": "AuraInstance.devToolService.defaultFilter"
      },
      "select": {
        "!type": "fn(config: ?)",
        "!span": "4111[140:8]-4117[140:14]",
        "!doc": "Returns the number of filtered rows and groups.\n@public\n@param {Object} config"
      },
      "applyGroupBy": {
        "!type": "fn(groupBy: ?, rows: [AuraInstance.devToolService.applyGroupBy.!1.<i>], rawRows: [+Component]) -> AuraInstance.devToolService.applyGroupBy.!ret",
        "!span": "5410[175:8]-5422[175:20]"
      },
      "filterFields": {
        "!type": "fn(fields: [?]|string, derivedFields: ?, rows: [+Component]) -> [AuraInstance.devToolService.applyGroupBy.!1.<i>]|[+Component]",
        "!span": "6222[195:8]-6234[195:20]"
      },
      "processField": {
        "!type": "fn(root: +Component|fn(), fields: [string], place: number) -> !0.<i>",
        "!span": "7950[242:8]-7962[242:20]"
      },
      "initCap": {
        "!type": "fn(str: string)",
        "!span": "9289[281:8]-9296[281:15]"
      },
      "applyFilter": {
        "!type": "fn(filter: fn() -> bool, rows: ?, rawRows: [+Component]) -> AuraInstance.devToolService.applyFilter.!ret",
        "!span": "9420[286:8]-9431[286:19]"
      },
      "output": {
        "!type": "fn(cmp: ?)",
        "!span": "9945[304:8]-9951[304:14]"
      },
      "accessbilityAide": {
        "nodeListToObjectArray": {
          "!type": "fn(array: [AuraInstance.devToolService.accessbilityAide.nodeListToObjectArray.!0.<i>], nodeList: ?, activeClass: string)",
          "!span": "10400[314:12]-10421[314:33]",
          "!doc": "@param array       - the array that we are going add elements to\n@param nodeList    - array of elements that are needed to be turned into an array of objects\n@param activeClass - class of where the active element is (null if on the current tag, non null if on a child)"
        },
        "findTopLevelErrors": {
          "!type": "fn(panels: [AuraInstance.devToolService.accessbilityAide.nodeListToObjectArray.!0.<i>], topPanelsCount: ?, elementsCovered: bool) -> [?]",
          "!span": "11280[339:12]-11298[339:30]",
          "!doc": "@param panels - the panels that we are going to look at (panelSlide, forcePanel, etc. Items that can basically be set to active)\n@param topPanelsCount the panels that could take over the page\n@return all errors that are found"
        },
        "inputDefaultErrorAide": {
          "!type": "fn(uls: ?, inputTags: ?, selectTags: ?, textAreaTags: ?) -> [!0.<i>]",
          "!span": "14881[404:13]-14902[404:34]",
          "!doc": "Helper functions that returns an error array when ever an inputDefaultError that is not associated with an ID is used\n@param   uls          - all of the ULs on the page\n@param   inputTags    - all of the input tags that can be associated with the inputDefaultError\n@param   selectTags   - all of the select tags that can be associated with the inputDefaultError\n@param   textAreaTags - all of the textAreaTags tags that can be associated with the inputDefaultError\n@returns array        - error array,"
        },
        "findMatchingId": {
          "!type": "fn(id: string, tags: ?, attribute2find: string) -> bool",
          "!span": "16608[435:13]-16622[435:27]",
          "!doc": "Helper function that will return true if the two values equal each other\n@param   id             - value that we are expecting\n@param   tags           - tags to iterate through\n@param   attribute2find - attribute that we want to extract from the ID\n@returns boolean    - true signifies that it was found"
        },
        "doesContain": {
          "!type": "fn(attribute: string, val: string) -> bool",
          "!span": "17638[458:12]-17649[458:23]",
          "!doc": "Helper function that will return true if the two values equal each other\n@param   attribute  - Contents of the attribute that we want to look at\n@param   val        - What we want to compare the attribute to\n@returns boolean    - Signifies whether or not they are equal"
        },
        "doesNotContain": {
          "!type": "fn(attribute: ?, dict: ?) -> bool",
          "!span": "18118[467:12]-18132[467:26]",
          "!doc": "Helper function that tells us whether something is in the dict or not\n@param   attribute  - Contents of the attribute that we want to look at\n@param   dict       - list of items that attribute should be equal to\n@returns boolean    - returns true if attribute value is not dict"
        },
        "checkParentMatchesTag": {
          "!type": "fn(tag: ?, parentTag: string) -> bool",
          "!span": "18724[477:12]-18745[477:33]",
          "!doc": "Goes up the tree (until it reaches the body tag) and finds whether the initial tag param is in another sent up tag\n@param   tag       - The starting tag that we are going to use to go up the tree\n@param   nameOfTag - Name of the tag that we should find should the the starting tags parent\n@returns boolean   - Signifies whether or not the tag we want was found or not (found: true, else: false)"
        },
        "getDictFromTags": {
          "!type": "fn(labels: ?, attribute: string) -> AuraInstance.devToolService.accessbilityAide.getDictFromTags.!ret",
          "!span": "19472[493:12]-19487[493:27]",
          "!doc": "Function that goes through all labels and turns the for attribute into a key\n@param   labels    - All the labels that we want to go through\n@param   attribute - The attribute that is being sought (for, id, title, etc)\n@returns dictionary  - Mapping of for atrib value to booleans"
        },
        "findAllImgTags": {
          "!type": "fn(allImgTags: ?, imgErrorMsg: string) -> string",
          "!span": "20270[513:12]-20284[513:26]",
          "!doc": "Function that goes through all Image tags, makes sure it is set, then checks the alt tag\n@param   imgErrorMsg                - Default error message telling user why they should set alt tag"
        },
        "getPropertyFromDescendantTag": {
          "!type": "fn(element: ?, property: string, childTag: string)",
          "!span": "23802[589:12]-23830[589:40]",
          "!doc": "Function that checks all descendants of an element for a matching tag and retrieves the specified property\nfrom the first encountered element - May need refactoring\n\n@param element - element whose descendants to check\n@param property - the property to retrieve from the child element\n@param childTag - the tag to match with the child elements\n@returns property - property to be retrieved or null if property does not exist"
        },
        "matchLabelToInput": {
          "!type": "fn(lbls: ?) -> [!0.<i>]",
          "!span": "24773[608:12]-24790[608:29]",
          "!doc": "Function that goes through all the labels and checks that they are associated with an input through the 'for' attribute\nor that they have a child input tag.\n\n@param lbls          -  All the labels to go over\n@returns errorArray  -  Returns all the erroneous labels"
        },
        "inputLabelAide": {
          "!type": "fn(lbls: ?, inputTags: ?) -> [!1.<i>]",
          "!span": "27669[666:12]-27683[666:26]",
          "!doc": "Function that goes through all labels and check for either the for attribute and the label id, or if a parent tag is a label\nThis function skips over several input types: submit, reset, image, hidden, and button. All of these have labels associated\nwith them in different ways\n\n@param   lbls       - All of the labels to\n@param   inputTags  - The attribute that is being sought (for, id, title, etc)\n@returns array     - All erroneous tags"
        },
        "checkForAttrib": {
          "!type": "fn(tags: [?], attribute: string, errorVal: string, evalFunc: fn(attribute: string, val: string) -> bool) -> [?]",
          "!span": "30308[719:12]-30322[719:26]",
          "!doc": "Function that goes finds all given tags and makes sure that they all have an attribute set\n@param   tags   - Name of the tag to find all instances of\n@param   attribute - The attribute that is being sought (for, id, title, etc)\n@param   errorVal  - Value that this attribute should not be set to\n@param   evalFunc  - Function to evaluate whether or not attribute is valid\n@returns array    - All erroneous tags"
        },
        "attribStringVal": {
          "!type": "fn(attribs: ?) -> string",
          "!span": "31074[737:12]-31089[737:27]",
          "!doc": "This method grabs all attributes of a tag and turns them into strings\n@param   attribs - All of the attributes in a tag\n@returns string - String value of all of the tag attributes"
        },
        "getStackTrace": {
          "!type": "fn(tag: ?) -> string",
          "!span": "31874[756:12]-31887[756:25]",
          "!doc": "Method that looks at the given tag and will look print out the next two parents components names\n@param   tag     - The initial tag to find the parents of\n@returns String  - The string representation of the the cmp stack trace"
        },
        "formatOutput": {
          "!type": "fn(tagError: string, errArray: [?]) -> string",
          "!span": "33790[795:12]-33802[795:24]",
          "!doc": "Method grabs everything from the given array and prints out the error and the tag(s) that are the issue\n@param   tagError - The error message for the given tag\n@param   errArray - The array of errors\n@returns String - Either the empty string or a string representation of the error"
        },
        "checkHeadHasCorrectTitle": {
          "!type": "fn(hdErrMsg: string, hd: ?) -> [!1]",
          "!span": "34893[821:12]-34917[821:36]",
          "!doc": "Method looks at the given tags title, and makes sure that it is not the empty string\n@param   hd - The head tag\n@returns Array - Returns an array of all erroneous values"
        },
        "anchrDoesNotHaveImgWithAlt": {
          "!type": "fn(anchor: ?) -> bool",
          "!span": "35521[834:12]-35547[834:38]",
          "!doc": "Method looks at the given anchors img (if it exists) and checks to see if it has an img atrib\n@param   anchor  - The anchor in question\n@returns Boolean - Returns whether a valid img alt was found"
        },
        "checkAnchorHasInnerText": {
          "!type": "fn(anchors: ?) -> [!0.<i>]",
          "!span": "36279[853:13]-36302[853:36]",
          "!doc": "Method looks at the given arrays for anchor statements that are the empty string\n@param   anchors - The anchor tags in the document\n@returns Array - Returns an array of all erroneous values"
        },
        "radioButtonAide": {
          "!type": "fn(inputTags: ?) -> [?]",
          "!span": "37874[883:13]-37889[883:28]",
          "!doc": "Method grabs everything from the given array and finds all tags that are erroneous\n@param   inputTags - radio and checkbox inputs\n@returns array     - Array of all errors that have been found"
        },
        "buttonLabelAide": {
          "!type": "fn(buttons: ?) -> [!0.<i>]",
          "!span": "39765[928:14]-39780[928:29]",
          "!doc": "Method that takes in a list of buttons and makes sure that they all have some text associated with them in the labels\n@param   buttons     - All buttons that are on the page\n@returns Array    - Array of all the errors"
        },
        "checkTables": {
          "!type": "fn(tables: ?) -> [?]",
          "!span": "40947[954:16]-40958[954:27]",
          "!doc": "Method that goes through all tables present on the page and makes sure the tags underneath them have either an id or scope associated with them\n@param   tables        - The tags to find\n@returns Array         - The error array"
        },
        "findNextHeader": {
          "!type": "fn(tags: ?, nextTag: string, allHdrs: ?|?) -> [?]",
          "!span": "45433[1037:17]-45447[1037:31]",
          "!doc": "Method that takes in a list of h#, the tag that show follow directly after, and all possible items that can be found.\nIt will start start searching through siblings of h# to find invalid-nested tags and return an error array with them if found\n@param   tags     - Array of all h# tags to look at\n@param   nextTag  - String representation of the very next tag that we should see.\n            i.e. if tags contains all h1 tags, nextTag should be \"h2\"\n@param   allHdrs  - Dictionary of all possible h# we can see.\n               i.e. if tags is a list of all h1 tags in the document, then allHdrs will be a dictionary\n               of h2-h6.\n@returns Array    - Array of all the errors"
        },
        "!span": "10022[307:8]-10038[307:24]"
      },
      "verifyAccessibility": {
        "checkImagesHaveAlts": {
          "tag": {
            "!type": "string",
            "!span": "47165[1082:14]-47170[1082:19]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "47203[1083:14]-47209[1083:20]"
          },
          "!span": "47127[1081:12]-47146[1081:31]",
          "!doc": "Check making sure that all images have an alt attribute present\n@returns String - Returns a string representation of the errors"
        },
        "checkInputsHaveLabel": {
          "tag": {
            "!type": "string",
            "!span": "47810[1096:16]-47815[1096:21]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "47850[1097:16]-47856[1097:22]"
          },
          "!span": "47769[1095:12]-47789[1095:32]",
          "!doc": "Check making sure all inputs have an associated label\n@returns String - Returns a string representation of the errors"
        },
        "checkButtonHaveLabel": {
          "tag": {
            "!type": "string",
            "!span": "49410[1121:16]-49415[1121:21]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "49450[1122:16]-49456[1122:22]"
          },
          "!span": "49369[1120:12]-49389[1120:32]",
          "!doc": "Check making sure all buttons have non empty label\n@returns String - Returns a string representation of the errors"
        },
        "checkAnchorHasText": {
          "tag": {
            "!type": "string",
            "!span": "50176[1136:13]-50181[1136:18]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "50213[1137:13]-50219[1137:19]"
          },
          "!span": "50140[1135:12]-50158[1135:30]",
          "!doc": "Check making sure that all anchors have text associated with them\n@returns String - Returns a string representation of the errors"
        },
        "checkIframeHasTitle": {
          "tag": {
            "!type": "string",
            "!span": "50936[1150:15]-50941[1150:20]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "50974[1151:15]-50980[1151:21]"
          },
          "!span": "50897[1149:12]-50916[1149:31]",
          "!doc": "Check making sure that all iframes have a non empty title associated with them\n@returns String - Returns a string representation of the errors"
        },
        "checkCorrectHeaderOrder": {
          "tag": {
            "!type": "string",
            "!span": "52701[1183:13]-52706[1183:18]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "52738[1184:13]-52744[1184:19]"
          },
          "!span": "52660[1182:12]-52683[1182:35]",
          "!doc": "Check making sure the head element is set correctly\n@returns String - Returns a string representation of the errors"
        },
        "checkTableCellsHaveScope": {
          "tag": {
            "!type": "string",
            "!span": "53621[1201:16]-53626[1201:21]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "53661[1202:16]-53667[1202:22]"
          },
          "!span": "53576[1200:12]-53600[1200:36]",
          "!doc": "Check making sure that table cells have scope in them, and that they are equal to row, col, rowgroup, colgroup\n@returns String - Returns a string representation of the errors"
        },
        "checkFieldsetsAreCorrect": {
          "tag": {
            "!type": "string",
            "!span": "54467[1215:16]-54472[1215:21]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "54507[1216:16]-54513[1216:22]"
          },
          "!span": "54422[1214:12]-54446[1214:36]",
          "!doc": "Check making sure that all fieldset tags do not have the display:none field set and makes sure that each one has a legend\n@returns String - Returns a string representation of the errors"
        },
        "checkRadioGrouping": {
          "tag": {
            "!type": "string",
            "!span": "55882[1246:16]-55887[1246:21]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "55922[1247:16]-55928[1247:22]"
          },
          "!span": "55843[1245:12]-55861[1245:30]",
          "!doc": "Check making sure that all radio and checkboxes are grouped within a fieldset\n@returns String - Returns a string representation of the errors"
        },
        "checkNestedHeader": {
          "tag": {
            "!type": "string",
            "!span": "56667[1261:16]-56672[1261:21]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "56707[1262:16]-56713[1262:22]"
          },
          "!span": "56629[1260:12]-56646[1260:29]",
          "!doc": "Checking to make sure that all nested Headers have a single level of difference\n@returns String - Returns a string representation of the errors"
        },
        "checkTopLevelPanels": {
          "tag": {
            "!type": "string",
            "!span": "58334[1287:16]-58339[1287:21]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "58374[1288:16]-58380[1288:22]"
          },
          "!span": "58294[1286:12]-58313[1286:31]",
          "!doc": "Test that will verify that all top level panels have the correct aria associated with them\n@returns String - Returns a string representation of the errors"
        },
        "checkInputdefaultErrorLinkage": {
          "tag": {
            "!type": "string",
            "!span": "60339[1316:16]-60344[1316:21]"
          },
          "func": {
            "!type": "fn(domElem: ?) -> string",
            "!span": "60379[1317:16]-60385[1317:22]"
          },
          "!span": "60289[1315:12]-60318[1315:41]",
          "!doc": "Check making sure that if an inputDefaultError exists on the page, that there is a corresponding input associated with it\n@returns String - Returns a string representation of the errors"
        },
        "!span": "46904[1076:8]-46923[1076:27]"
      },
      "checkAccessibility": {
        "!type": "fn(domElem: +Document, checksToRun: [string]) -> string",
        "!span": "61428[1332:8]-61446[1332:26]",
        "!doc": "Calls all functions in VerifyAccessibility and stores the result in a string\n@param domElem     - element to start at. Can be null or a dom element\n@param checksToSkip - Array of function names to run. Defaults to run all.\n@returns String    - Returns a a concatenated string representation of all errors or the empty string"
      },
      "help": {
        "!type": "fn() -> string",
        "!span": "62560[1358:8]-62564[1358:12]"
      },
      "helpText": {
        "!type": "[?]",
        "!span": "63097[1376:6]-63105[1376:14]"
      },
      "defaultView": {
        "!type": "fn() -> [+Component]",
        "!span": "68708[1534:6]-68719[1534:17]"
      },
      "defaultFields": {
        "!type": "string",
        "!span": "68753[1535:6]-68766[1535:19]"
      },
      "defaultFilter": {
        "!type": "fn() -> bool",
        "!span": "68813[1537:6]-68826[1537:19]"
      },
      "!span": "11004[279:9]-11018[279:23]",
      "!doc": "#if {\"excludeModes\" : [\"PRODUCTION\", \"PRODUCTIONDEBUG\"]}",
      "newStatement": "AuraInstance.getQueryStatement"
    },
    "services": {
      "get": {
        "!type": "fn(key: ?) -> AuraClientService.prototype.decode.!ret|bool",
        "!span": "13847[402:8]-13850[402:11]"
      },
      "c": {
        "get": {
          "!type": "fn(name: ?) -> +Action",
          "!span": "20228[566:8]-20231[566:11]"
        },
        "!span": "20210[564:13]-20213[564:16]"
      },
      "!span": "11087[284:9]-11095[284:17]",
      "!doc": "@field",
      "rendering": "+AuraRenderingService",
      "event": "+AuraEventService",
      "component": "+AuraComponentService",
      "client": "+AuraClientService",
      "history": "+AuraHistoryService",
      "localization": "+AuraLocalizationService",
      "storage": "+AuraStorageService",
      "cmp": "+AuraComponentService",
      "e": "+AuraEventService",
      "l10n": "+AuraLocalizationService",
      "style": "+AuraStyleService",
      "metrics": "+Aura.Services.MetricsService",
      "locker": "AuraInstance.lockerService"
    },
    "pushCreationPath": {
      "!type": "fn(creationPath: string)",
      "!span": "16051[442:9]-16067[442:25]",
      "!doc": "Pushes current portion of attribute's creationPath onto stack\n@param {String} creationPath\n\n@public"
    },
    "popCreationPath": {
      "!type": "fn(creationPath: string)",
      "!span": "16477[461:9]-16492[461:24]",
      "!doc": "pops current portion of attribute's creationPath from stack\n@param {String} creationPath\n\n@public"
    },
    "setCreationPathIndex": {
      "!type": "fn(idx: ?)",
      "!span": "16905[479:9]-16925[479:29]",
      "!doc": "sets pathIndex for the current attribute on creationPath's stack\n@param {String} creationPath\n\n@public"
    },
    "getQueryStatement": {
      "!type": "fn() -> AuraInstance.getQueryStatement.!ret",
      "!span": "18622[522:9]-18641[522:28]"
    },
    "qhelp": {
      "!type": "fn() -> string",
      "!span": "18688[523:9]-18695[523:16]"
    },
    "finishedInit": {
      "!type": "bool",
      "!span": "30056[810:13]-30070[810:27]"
    },
    "mode": {
      "!type": "string",
      "!span": "46253[1265:9]-46257[1265:13]"
    },
    "enableAssertions": {
      "!type": "bool",
      "!span": "46275[1266:9]-46291[1266:25]"
    },
    "context": {
      "globalValueProviders": {
        "!span": "2558[69:17]-2578[69:37]",
        "valueProviders": {
          "$Browser": {
            "!type": "+ObjectValueProvider",
            "!span": "1438[36:8]-1448[36:18]"
          },
          "$Label": {
            "!type": "+LabelValueProvider",
            "!span": "1515[37:8]-1523[37:16]"
          },
          "$Global": {
            "!type": "+ContextValueProvider",
            "!span": "1660[39:8]-1669[39:17]"
          },
          "!span": "1411[35:9]-1425[35:23]",
          "$Locale": "+ObjectValueProvider",
          "<i>": "+ObjectValueProvider"
        }
      },
      "contextGlobals": {
        "length": {
          "!type": "number",
          "!span": "66402[176:60899]-66408[176:60905]"
        },
        "marker": {
          "!type": "number",
          "!span": "66474[176:60971]-66480[176:60977]"
        },
        "!span": "2604[70:17]-2618[70:31]",
        "request": "+XMLHttpRequest"
      },
      "!span": "22407[629:15]-22414[629:22]",
      "!doc": "creating context.",
      "currentAction": "+Action"
    },
    "initialized": {
      "!type": "bool",
      "!span": "28969[771:15]-28980[771:26]"
    },
    "error": {
      "!type": "fn(msg: string, e?: +Error)",
      "!span": "65332[1417:11]-65337[1417:16]",
      "!doc": "@description Use <code>$A.error()</code> in response to a serious error that has no recovery path.\n\nIf this occurs during a test, the test will be stopped unless you add calls to '$A.test.expectAuraError' for\neach error that occurs. <code>auraErrorsExpectedDuringInit</code> allows server side errors to not stop the\ntest as well.\n\n\n@public\n@param {String} msg The error message to be displayed to the user.\n@param {Error} [e] The error object to be displayed to the user.\n@platform\n@deprecated throw new Error(msg) instead"
    },
    "hasErrors": {
      "!type": "bool",
      "!span": "4186[147:11]-4197[147:22]"
    }
  },
  "$A": {
    "!type": "+AuraInstance",
    "!span": "1866[61:7]-1870[61:11]",
    "!doc": "@description This, $A, is supposed to be our ONLY window-polluting top-level variable. Everything else in Aura is\n           attached to it.\n\n@platform\n@namespace\n@alias $A\n\n@borrows AuraComponentService#createComponent as $A.createComponent\n@borrows AuraComponentService#createComponents as $A.createComponents\n@borrows AuraComponentService#getComponent as $A.getComponent\n@borrows AuraClientService#enqueueAction as $A.enqueueAction\n@borrows AuraInstance#getRoot as $A.getRoot\n@borrows AuraInstance#getCallback as $A.getCallback\n@borrows AuraInstance#get as $A.get\n@borrows AuraInstance#set as $A.set\n@borrows AuraInstance#error as $A.error\n@borrows AuraInstance#log as $A.log\n@borrows AuraInstance#warning as $A.warning\n@borrows AuraInstance#run as $A.run\n@borrows AuraComponentService#newComponentDeprecated as $A.newCmp\n@borrows AuraComponentService#newComponentAsync as $A.newCmpAsync\n@borrows AuraInstance#localizationService as localizationService\n@borrows AuraInstance#util as util\n@borrows AuraInstance#reportError as $A.reportError"
  },
  "AuraClientService": {
    "prototype": {
      "setQueueSize": {
        "!type": "fn(queueSize: number)",
        "!span": "7255[228:28]-7267[228:40]",
        "!doc": "set the queue size.\n\nThis is a one time set for the queue size. Any further attempts will be ignored.\nThis should become a configuration parameter at some point.\n\n@private"
      },
      "deferPendingActions": {
        "!type": "fn()",
        "!span": "7848[245:28]-7867[245:47]",
        "!doc": "Mark all currently queued (but not sent) actions as 'deferred'.\n\nThis is intended for use when components are kept 'alive' after they are no longer on the screen for better\nperformance going back and forth between various displays."
      },
      "decode": {
        "!type": "fn(response: string, noStrip?: bool|+Component, timedOut?: bool) -> AuraClientService.prototype.decode.!ret",
        "!span": "9072[280:28]-9078[280:34]",
        "!doc": "Take a json (hopefully) response and decode it. If the input is invalid JSON, we try to handle it gracefully.\n\n@param {XmlHttpRequest} response the XHR object.\n@param {Boolean} [noStrip] true to not strip off the JSON hijacking prevention (while(1) prefix).\n@param {Boolean} [timedOut] true if the XHR timed out; false otherwise.\n@returns {Object} An object with properties 'status', which represents the status of the response, and potentially\n         'message', which contains the decoded server response or an error message."
      },
      "throwExceptionEvent": {
        "!type": "fn(resp: ?)",
        "!span": "15742[452:28]-15761[452:47]",
        "!doc": "Fire an event exception from the wire.\n\nThis is published, but only for use in the case of an event exception serialized as JS,\nnot sure if this is important.\n\n@param {Object} config The data for the exception event\n@memberOf AuraClientService\n@private"
      },
      "fireDoneWaiting": {
        "!type": "fn()",
        "!span": "16555[478:28]-16570[478:43]"
      },
      "tearDown": {
        "!type": "fn()",
        "!span": "16753[487:28]-16761[487:36]",
        "!doc": "This will be called by the unload event\n\n@private"
      },
      "setInCollection": {
        "!type": "fn()",
        "!span": "16922[497:28]-16937[497:43]",
        "!doc": "make the current thread be 'in aura collections'\n\n@private"
      },
      "clearInCollection": {
        "!type": "fn()",
        "!span": "17122[506:28]-17139[506:45]",
        "!doc": "release the current thread from 'in aura collections'\n\n@private"
      },
      "isDisconnectedOrCancelled": {
        "!type": "fn(response: ?) -> bool",
        "!span": "17280[511:28]-17305[511:53]"
      },
      "singleAction": {
        "!type": "fn(action: ?, actionResponse: ?, key: string, store: bool)",
        "!span": "18171[538:28]-18183[538:40]",
        "!doc": "Process a single action/response.\n\nNote that it does this inside an $A.run to provide protection against error returns, and to notify the user if an\nerror occurs.\n\n@param {Action} action the action.\n@param {Object} actionResponse the server response.\n@param {string} key the storage key (may be null).\n@param {Boolean} store should storable action responses get stored? Set to false when\n       for duplicate storable actions are deduped on the client.\n@private"
      },
      "isBB10": {
        "!type": "fn() -> bool",
        "!span": "20632[607:28]-20638[607:34]"
      },
      "getManifestURL": {
        "!type": "fn()",
        "!span": "20790[612:28]-20804[612:42]"
      },
      "isManifestPresent": {
        "!type": "fn() -> bool",
        "!span": "20961[617:28]-20978[617:45]"
      },
      "countAvailableXHRs": {
        "!type": "fn() -> !this.availableXHRs.length",
        "!span": "21099[624:28]-21117[624:46]",
        "!doc": "Count the available XHRs."
      },
      "getAvailableXHR": {
        "!type": "fn(isBackground: bool|string) -> +Aura.Services.AuraClientService$AuraXHR",
        "!span": "21355[635:28]-21370[635:43]",
        "!doc": "Get an available XHR.\n\nUsed for instrumentation\n\n@param {Boolean} isBackground is the XHR for a background action."
      },
      "releaseXHR": {
        "!type": "fn(auraXHR: ?)",
        "!span": "21690[649:28]-21700[649:38]",
        "!doc": "Release an xhr back in to the pool.\n\n@export"
      },
      "hardRefresh": {
        "!type": "fn()",
        "!span": "22193[670:28]-22204[670:39]",
        "!doc": "Perform hard refresh\n\nThis is part of the appcache refresh, forcing a reload while\navoiding the appcache which is important for system such as\nAndroid such doesn't adhere to window.location.reload(true)\nand still uses appcache.\n\n@memberOf AuraClientService\n@export"
      },
      "isDevMode": {
        "!type": "fn() -> bool",
        "!span": "24211[720:28]-24220[720:37]"
      },
      "actualDumpCachesAndReload": {
        "!type": "fn()",
        "!span": "24411[729:28]-24436[729:53]",
        "!doc": "the code to\n@private"
      },
      "dumpCachesAndReload": {
        "!type": "fn()",
        "!span": "24769[741:28]-24788[741:47]",
        "!doc": "Clears actions and ComponentDefStorage stores then reloads the page."
      },
      "handleAppCache": {
        "!type": "fn()",
        "!span": "25031[753:28]-25045[753:42]"
      },
      "setOutdated": {
        "!type": "fn()",
        "!span": "29077[874:28]-29088[874:39]",
        "!doc": "Marks the application as outdated.\n\n@memberOf AuraClientService\n@export"
      },
      "setConnected": {
        "!type": "fn(isConnected: bool)",
        "!span": "30343[904:28]-30355[904:40]",
        "!doc": "Inform Aura that the environment is either online or offline.\n\n@param {Boolean} isConnected Set to true to run Aura in online mode,\nor false to run Aura in offline mode.\n@memberOf AuraClientService\n@export"
      },
      "saveTokenToStorage": {
        "!type": "fn() -> ?",
        "!span": "31354[930:28]-31372[930:46]",
        "!doc": "Saves the CSRF token to the Actions storage. Does not block nor report success or failure.\n\nThis storage operate uses the adapter directly instead of AuraStorage because the specific\ntoken key is used in mobile (hybrid) devices to obtain the token without the isolation and\neven before Aura initialization.\n\n@returns {Promise} Promise that resolves with the current CSRF token value."
      },
      "loadTokenFromStorage": {
        "!type": "fn() -> ?",
        "!span": "32438[955:28]-32458[955:48]",
        "!doc": "Loads the CSRF token from Actions storage.\n@return {Promise} resolves or rejects based on data loading."
      },
      "initHost": {
        "!type": "fn(host: string)",
        "!span": "33043[974:28]-33051[974:36]",
        "!doc": "Init host is used to set the host name for communications.\n\nIt should only be called once during the application life cycle, since it\nwill be deleted in production mode.\n\nNote that in testing, this can be used to make the host appear unreachable.\n\n@param {string} host the host name of the server.\n@export"
      },
      "init": {
        "!type": "fn(config: AuraClientService.prototype.init.!0, token: string, container: ?) -> AuraClientService.prototype.decode.!ret|bool",
        "!span": "33671[996:28]-33675[996:32]",
        "!doc": "Initialize aura.\n\nFIXME: why is this exported\n\nThis should never be called by client code.\n\n@param {Object} config the configuration for aura.\n@param {string} token the XSS token.\n@param {function} callback the callback when init is complete.\n@param {object} container the place to install aura (defaults to document.body).\n@export"
      },
      "inFlightXHRs": {
        "!type": "fn(excludeBackground: ?) -> number",
        "!span": "34982[1041:28]-34994[1041:40]",
        "!doc": "Return the number of inFlightXHRs\n\n@export"
      },
      "idle": {
        "!type": "fn() -> bool",
        "!span": "35468[1058:28]-35472[1058:32]",
        "!doc": "This function is used by the test service to determine if there are outstanding actions.\n\n@private"
      },
      "runWhenXHRIdle": {
        "!type": "fn(f: +Function|fn())",
        "!span": "35778[1067:28]-35792[1067:42]",
        "!doc": "Enqueues a function to run when no XHRs are in-flight.\n@param {Function} f the function to execute."
      },
      "processXHRIdleQueue": {
        "!type": "fn()",
        "!span": "36084[1080:28]-36103[1080:47]",
        "!doc": "Executes the queue of functions to run when no XHRs are in-flight."
      },
      "areActionsWaiting": {
        "!type": "fn() -> bool",
        "!span": "36776[1105:28]-36793[1105:45]",
        "!doc": "This function is used by the test service to determine if there are outstanding actions queued.\n\n@private"
      },
      "initDefs": {
        "!type": "fn(config: ?)",
        "!span": "37169[1121:28]-37177[1121:36]",
        "!doc": "Initialize definitions.\n\nFIXME: why is this exported\n\nThis should never be called by client code. It is exposed, but deleted after\nfirst use.\n\n@param {Object} config the set of definitions to initialize\n@export"
      },
      "runAfterInitDefs": {
        "!type": "fn(callback: fn())",
        "!span": "39183[1183:28]-39199[1183:44]",
        "!doc": "Run a callback after defs are initialized.\n\nThis is for internal use only. The function is called synchronously if definitions have\nalready been initialized.\n\n@param {function} callback the callback that should be invoked after defs are initialized\n@private"
      },
      "loadComponent": {
        "!type": "fn(descriptor: ?, attributes: ?, callback: fn(config: ?, token: string, container: ?, doNotInitializeServices?: bool), defType: string)",
        "!span": "40103[1207:28]-40116[1207:41]",
        "!doc": "Load a component.\n\nThis function does a very complex dance to try to bring up the app as fast as possible. This is really\nimportant in the case of persistent storage.\n\n@param {DefDescriptor} descriptor The key for a definition with a qualified name of the format prefix://namespace:name\n@param {Object} attributes The configuration data to use. If specified, attributes are used as a key value pair.\n@param {function} callback The callback function to run\n@param {String} defType Sets the defType to \"COMPONENT\"\n\n@memberOf AuraClientService\n@private"
      },
      "inAuraLoop": {
        "!type": "fn() -> bool",
        "!span": "47854[1371:28]-47864[1371:38]",
        "!doc": "Check to see if we are inside the aura processing 'loop'.\n\n@private"
      },
      "pushStack": {
        "!type": "fn(name: string)",
        "!span": "48060[1381:28]-48069[1381:37]",
        "!doc": "Push a new name on the stack.\n\n@param {string} name the name of the item to push.\n@private"
      },
      "popStack": {
        "!type": "fn(name: string)",
        "!span": "48428[1395:28]-48436[1395:36]",
        "!doc": "Pop an item off the stack.\n\nThe name of the item must match the previously pushed. If this is the last\nitem on the stack we do post processing, which involves sending actions to\nthe server.\n\n@param name the name of the last item pushed.\n@private"
      },
      "postProcess": {
        "!type": "fn()",
        "!span": "48918[1414:28]-48929[1414:39]",
        "!doc": "@private"
      },
      "process": {
        "!type": "fn()",
        "!span": "49687[1433:28]-49694[1433:35]",
        "!doc": "Run the collection of actions.\n\nEntry point for processing actions. This creates a collector, and parcels out the action handling.\nAfter this, server actions will be either getting values from storage, or will be executed, and the\nclient actions will all be queued up to be executed in order via setTimeout, giving server actions\nentry points to collect."
      },
      "continueProcessing": {
        "!type": "fn()",
        "!span": "50099[1449:28]-50117[1449:46]",
        "!doc": "continuation.\n\nSetp 2: walk actions setting up collections.\n\nWe divide into client actions and server actions. Server actions are further\ndivided into stored vs. non-stored."
      },
      "getStoredResult": {
        "!type": "fn(action: AuraInstance.context.contextGlobals|string, storage: ?, index: number)",
        "!span": "51821[1500:28]-51836[1500:43]",
        "!doc": "Handle a single server action."
      },
      "enqueueStoredAction": {
        "!type": "fn(action: ?, response: ?)",
        "!span": "53312[1537:28]-53331[1537:47]",
        "!doc": "Enqueue a stored action for execution after the XHR send."
      },
      "executeStoredAction": {
        "!type": "fn(action: AuraInstance.context.contextGlobals|string, response: ?, collected: [AuraInstance.context.contextGlobals|string], index: number)",
        "!span": "53702[1547:28]-53721[1547:47]",
        "!doc": "Execute a single stored action.\n\nThis is done in situations when we get a result from the storage service. We also queue up a refresh\naction if we are due a refresh or we have trouble running the action."
      },
      "collectServerAction": {
        "!type": "fn(action: AuraInstance.context.contextGlobals|string, index: number)",
        "!span": "55022[1584:28]-55041[1584:47]",
        "!doc": "Collect a single action into our list."
      },
      "continueClientActions": {
        "!type": "fn()",
        "!span": "55265[1593:28]-55286[1593:49]",
        "!doc": "Run client actions asynchronously."
      },
      "runClientActions": {
        "!type": "fn()",
        "!span": "55876[1613:28]-55892[1613:44]",
        "!doc": "Run client actions synchronously."
      },
      "executeClientAction": {
        "!type": "fn(action: AuraInstance.context.contextGlobals|string)",
        "!span": "56251[1628:28]-56270[1628:47]",
        "!doc": "Execute a client action."
      },
      "finishCollection": {
        "!type": "fn()",
        "!span": "56611[1642:28]-56627[1642:44]",
        "!doc": "Finish the collection process and send XHRs."
      },
      "shouldSendOutForegroundActions": {
        "!type": "fn(foregroundActions: [AuraInstance.context.contextGlobals], cabooseCount: number) -> bool",
        "!span": "57942[1687:28]-57972[1687:58]",
        "!doc": "@private"
      },
      "sendActionXHRs": {
        "!type": "fn()",
        "!span": "58263[1699:28]-58277[1699:42]",
        "!doc": "Send actions."
      },
      "sendAsSingle": {
        "!type": "fn(actions: [?], count: number)",
        "!span": "60181[1765:28]-60193[1765:40]",
        "!doc": "Send a group of actions as single action XHRs or re-enqueue them.\n\nAll actions in the group will either be sent, marked as dupes, or put back in\nthe deferred queue.\n\n@private\n@param {Array} actions the set of actions to send.\n@param {int} count the number of actions to send."
      },
      "continueCompletions": {
        "!type": "fn()",
        "!span": "61222[1801:28]-61241[1801:47]",
        "!doc": "Continue with completions, running all action callbacks.\n\nThis is used when the actions are stored, and we wish to run them after the XHRs\nmight have been sent."
      },
      "finishProcessing": {
        "!type": "fn()",
        "!span": "62072[1827:28]-62088[1827:44]",
        "!doc": "finish up processing, force a rerender."
      },
      "deDupe": {
        "!type": "fn(action: ?, sending: bool) -> bool",
        "!span": "62702[1850:28]-62708[1850:34]",
        "!doc": "Check, and then dedupe actions that are duplicates.\n\n@param {Action} action the action to dedupe.\n@param {Boolean} sending true if we are sending and should create an entry.\n@return true if the action has been deduped."
      },
      "getAndClearDupes": {
        "!type": "fn(key: AuraClientService.actionStoreMap.<i>) -> [string|fn()]",
        "!span": "63956[1895:28]-63972[1895:44]"
      },
      "send": {},
      "xhrSetTimeout": {
        "!type": "fn(f: fn()) -> number",
        "!span": "68646[2056:28]-68659[2056:41]",
        "!doc": "Sets a timeout for use by the XHR timeout mechanism. Hook for testing.\n@private"
      },
      "xhrClearTimeout": {
        "!type": "fn(id: number)",
        "!span": "68844[2064:28]-68859[2064:43]",
        "!doc": "Clears a timeout used by the XHR timeout mechanism. Hook for testing.\n@private"
      },
      "createXHR": {
        "!type": "fn() -> AuraClientService.prototype.createXHR.!ret",
        "!span": "69039[2074:28]-69048[2074:37]",
        "!doc": "@returns {Object} An XHR based on what is available on the current browser.\n@private"
      },
      "buildParams": {
        "!type": "fn(map: AuraClientService.prototype.buildParams.!0) -> string",
        "!span": "70080[2106:28]-70091[2106:39]",
        "!doc": "Create an encoded string of parameters.\n\n@param {Map} map A map of parameter names and values\n@returns {String} The encoded parameters\n@private"
      },
      "receive": {
        "!type": "fn(auraXHR: string, timedOut: bool|+Component) -> AuraClientService.prototype.decode.!ret",
        "!span": "71360[2148:28]-71367[2148:35]",
        "!doc": "Callback for an XHR for a set of actions.\n\nThis function does all of the processing for a set of actions that come back from the server. It correctly deals\nwith the case of interrupted communications, and handles aborts.\n\n@param {AuraXHR} auraXHR the xhr container.\n@param {Boolean} timedOut true if the XHR timed out, false otherwise.\n@private"
      },
      "processErrors": {
        "!type": "fn(auraXHR: ?, errorMessage: string)",
        "!span": "72532[2180:28]-72545[2180:41]",
        "!doc": "Mark actions from an XHR response as being in the error state and set the error on the actions.\n\n@param {AuraXHR} auraXHR The xhr container.\n@param {String} errorMessage The error message to associate with the actions.\n@private"
      },
      "processResponses": {
        "!type": "fn(auraXHR: string, responseMessage: +Component)",
        "!span": "72971[2193:28]-72987[2193:44]"
      },
      "buildStorableServerAction": {
        "!type": "fn(response: ?) -> +Action",
        "!span": "75975[2281:28]-76000[2281:53]"
      },
      "processIncompletes": {
        "!type": "fn(auraXHR: ?)",
        "!span": "76972[2306:28]-76990[2306:46]"
      },
      "parseAndFireEvent": {
        "!type": "fn(evtObj: ?)",
        "!span": "77621[2328:28]-77638[2328:45]",
        "!doc": "A utility to handle events passed back from the server."
      },
      "resetToken": {
        "!type": "fn(newToken: ?)",
        "!span": "78293[2356:28]-78303[2356:38]",
        "!doc": "Reset the token.\n\nUsed by plugins.\n\n@param {Object}\n           newToken Refresh the current token with a new one.\n@memberOf AuraClientService\n@export"
      },
      "runActions": {
        "!type": "fn(actions: ?, scope: ?, callback: ?)",
        "!span": "78988[2378:28]-78998[2378:38]",
        "!doc": "[DEPRECATED] Run the actions.\n\nThis function effectively attempts to submit all pending actions immediately (if\nthere is room in the outgoing request queue). If there is no way to immediately queue\nthe actions, they are submitted via the normal mechanism.\n\n@param {Array.<Action>}\n           actions an array of Action objects\n@param {Object}\n           scope The scope in which the function is executed\n@param {function}\n           callback The callback function to run\n@memberOf AuraClientService\n@deprecated\n@export"
      },
      "injectComponent": {
        "!type": "fn(rawConfig: ?, locatorDomId: string, localId: string)",
        "!span": "79796[2407:28]-79811[2407:43]",
        "!doc": "Inject a component and set up its event handlers. For Integration\nService.\n\nFIXME: this should be private.\n\n@param {Object} rawConfig the config for the component to be injected\n@param {String} locatorDomId the DOM id where we should place our element.\n@param {String} localId the local id for the component to be created.\n@memberOf AuraClientService\n@export"
      },
      "createIntegrationErrorConfig": {
        "!type": "fn(errorText: string|[string]) -> ?",
        "!span": "82580[2497:28]-82608[2497:56]",
        "!doc": "Create error component config to display integration service errors\n\n@param {(String|String[])} errorText\n@returns {Object} error config for ui:message"
      },
      "renderInjection": {
        "!type": "fn(component: ?, locator: string, actionEventHandlers?: ?)",
        "!span": "83681[2533:28]-83696[2533:43]",
        "!doc": "Used within async callback for AIS.\n\n@param {Component} component - component\n@param {String} locator - parent element or the id of the parent element where to inject component\n@param {Object} [actionEventHandlers] - event handlers"
      },
      "injectComponentAsync": {
        "!type": "fn(config: ?, locator: string, eventHandlers?: ?, callback: +Function)",
        "!span": "85075[2570:28]-85095[2570:48]",
        "!doc": "Use async created component for integration service\n\n@param {Object} config - component def config\n@param {String} locator - parent element or the id of the parent element where to inject component\n@param {Object} [eventHandlers] - handlers of registered event\n@param {Function} callback The callback to use once the component is successfully created\n@export"
      },
      "addComponentHandlers": {
        "!type": "fn(component: ?, actionEventHandlers?: ?)",
        "!span": "86109[2603:28]-86129[2603:48]",
        "!doc": "Add handlers of registered events for AIS\n\n@param {Component} component - component\n@param {Object} [actionEventHandlers] - handlers of registered events"
      },
      "isConnected": {
        "!type": "fn() -> bool",
        "!span": "87033[2631:28]-87044[2631:39]",
        "!doc": "Return whether Aura believes it is online.\nImmediate and future communication with the server may fail.\n@memberOf AuraClientService\n@return {Boolean} Returns true if Aura believes it is online; false otherwise.\n@export"
      },
      "enqueueAction": {
        "!type": "fn(action: AuraInstance.context.contextGlobals|string, background: bool|+Component)",
        "!span": "87413[2644:28]-87426[2644:41]",
        "!doc": "This function must be called from within an event loop.\n\n@param {Action} action the action to enqueue\n@param {Boolean} background Set to true to run the action in the background, otherwise the value of action.isBackground() is used.\n@export\n@public\n@platform"
      },
      "deferAction": {
        "!type": "fn(action: ?) -> ?",
        "!span": "88271[2664:28]-88282[2664:39]",
        "!doc": "[DEPRECATED] [DOES NOT WORK] [DO NOT USE] Defer the action by returning a Promise object.\nConfigure your action excluding the callback prior to deferring.\nThe Promise is a thenable, meaning it exposes a 'then' function for consumers to chain updates.\n\n@param {Action} action - target action\n@return {Promise} a promise which is resolved or rejected depending on the state of the action\n@export"
      },
      "hasActionStorage": {
        "!type": "fn() -> bool",
        "!span": "89064[2690:28]-89080[2690:44]",
        "!doc": "Gets whether or not the Aura \"actions\" cache exists.\n@returns {Boolean} true if the Aura \"actions\" cache exists."
      },
      "isActionInStorage": {
        "!type": "fn(descriptor: string, params: ?, callback: +Function)",
        "!span": "89551[2703:28]-89568[2703:45]",
        "!doc": "Determines whether an action is stored.\n\n@param {String} descriptor - action descriptor.\n@param {Object} params - map of keys to parameter values.\n@param {Function} callback - called asynchronously after the action was looked up in the cache. Fired with a\nsingle parameter, isInStorge {Boolean} - representing whether the action was found in the cache.\n@export"
      },
      "revalidateAction": {
        "!type": "fn(descriptor: string, params: ?, callback: +Function)",
        "!span": "90968[2743:28]-90984[2743:44]",
        "!doc": "Resets the cache cleanup timer for an action.\n\n@param {String} descriptor - action descriptor.\n@param {Object} params - map of keys to parameter values.\n@param {Function} callback - called asynchronously after the action was revalidated. Called with a single\nparameter, wasRevalidated {Boolean} - representing whether the action was found in the cache and\nsuccessfully revalidated.\n@export"
      },
      "invalidateAction": {
        "!type": "fn(descriptor: string, params: ?, successCallback: +Function, errorCallback: +Function)",
        "!span": "92510[2787:28]-92526[2787:44]",
        "!doc": "Clears an action out of the action cache.\n\n@param {String} descriptor action descriptor.\n@param {Object} params map of keys to parameter values.\n@param {Function} successCallback called after the action was invalidated. Called with true if the action was\nsuccessfully invalidated and false if the action was invalid or was not found in the cache.\n@param {Function} errorCallback called if an error occurred during execution\n@export"
      },
      "isInternalNamespace": {
        "!type": "fn(namespace: ?) -> bool",
        "!span": "93262[2810:28]-93281[2810:47]"
      },
      "isPrivilegedNamespace": {
        "!type": "fn(namespace: ?) -> bool",
        "!span": "93401[2814:28]-93422[2814:49]"
      },
      "allowAccess": {
        "!type": "fn(definition: +ComponentDef, component: +Component) -> !0.isInstanceOf",
        "!span": "93541[2818:28]-93552[2818:39]"
      },
      "invalidSession": {
        "!type": "fn(token: ?)",
        "!span": "97597[2896:28]-97611[2896:42]",
        "!doc": "Handles invalidSession exception from the server when the csrf token is invalid.\nSaves new token to storage then refreshes page.\n\n@export"
      },
      "setUseBootstrapCache": {
        "!type": "fn(useBootstrapCache: bool)",
        "!span": "98732[2925:28]-98752[2925:48]",
        "!doc": "Sets whether Aura should attempt to load the getApplication action from cache first.\nThis must be called from a template's auraPreInitBlock. By default this is enabled.\n@param {Boolean} useBootstrapCache if true load getApplication action from cache first.\n If false go to the server first (ignoring any existing cache).\n@export"
      },
      "disableBootstrapCacheOnNextLoad": {
        "!type": "fn()",
        "!span": "99142[2938:28]-99173[2938:59]",
        "!doc": "Forces getApplication action to the server, skipping the cache, when the app\nis next loaded.\n\nBootstrap cache is disabled when a valid csrf token is not available because the\ngetApplication action is the only mechanism to get a new token.\n\n@private"
      },
      "clearDisableBootstrapCacheOnNextLoad": {
        "!type": "fn()",
        "!span": "99683[2951:28]-99719[2951:64]",
        "!doc": "Clears disabling of the bootstrap cache. See disableBootstrapCacheOnNextLoad.\n@private"
      },
      "getUseBootstrapCache": {
        "!type": "fn() -> bool",
        "!span": "100022[2959:28]-100042[2959:48]",
        "!doc": "Gets whether to check action cache for getApplication.\n@return {Boolean} true if the cache should be checked; false to skip the cache."
      },
      "setXHRTimeout": {
        "!type": "fn(timeout: number)",
        "!span": "101170[2994:28]-101183[2994:41]",
        "!doc": "This is a temporary API to workaround a broken network stack found on Samsung\nGalaxy S5/S6 devices on Android 5.x.\n\nSets the timeout for all Aura-initiated XHRs.\n\nThe timeout applies to each XHR. The timer starts when XHR.send() is invoked\nand ends when XHR.onreadystatechange (readyState = 4) is fired. If the timeout\nexpires before XHR.onreadystatechange then the actions in the XHR are moved to\nINCOMPLETE state.\n\n@param {Number} timeout The XHR timeout in milliseconds.\n@memberOf AuraClientService\n@export"
      },
      "populatePersistedActionsFilter": {
        "!type": "fn() -> ?",
        "!span": "101512[3003:28]-101542[3003:58]",
        "!doc": "Populates the persisted actions filter if applicable.\n@return {Promise} a promise that resolves when the action keys are loaded."
      },
      "setupPersistedActionsFilter": {
        "!type": "fn()",
        "!span": "102931[3043:28]-102958[3043:55]",
        "!doc": "Setup the persisted actions filter.\n\nActions can depend on defs. And defs can depend on GVPs (particularly $Label).\nDefs are loaded at framework init so the available actions must be determined\nat the same time: framework init. Otherwise in a multi-tab scenario actions from\nother tabs may be visible, and those actions may reference defs this tab doesn't have."
      }
    },
    "!type": "fn()",
    "!span": "4082[132:0]-4099[132:17]",
    "!doc": "@description The Aura Client Service.\n\nThere be dragons here.\n\nManage the queue of actions sent to the server.\n\nQueue Processing Notes:\n * The queue is processed synchronously, but almost all of the interesting functionality occurs asynchronously.\n * client actions are run in a single flow of setTimeout calls.\n * storable server actions get processed in the \"then\" clause of the promise\n * non-storable server actions are processed synchronously.\n\nInput conditions:\nWe have a queue of actions that are inserted vie enqueueAction.\n\nDangers:\n * Race conditions.\n * caboose actions.\n * problems with storage.\n * complexity of code due to asynchronicity.\n\nTradeoffs:\n * number of actions boxcarred.\n * actions in flight\n * sending XHR early vs. late.\n\nProcessing Loop:\n * gather actions into a collector.\n * walk each action, queueing up server actions to retrieve from storage and client actions to execute.\n * execute client actions with setTimeout(0) to allow server actions to complete.\n * As server actions come back from storage, queue up for execution, and queue refresh actions to refresh.\n * After all actions collect, check for further actions in the queue, restart loop if there are some.\n * Once we have finished processing all actions, check for actions to be put in an XHR.\n   + All foreground actions go in a single XHR, and are de-duped on send.\n   + background actions are sent one per XHR, with a de-dupe step during the queue walk.\n   + deferred actions are sent if we are idle, with a de-dupe step during the queue walk.\n\nQueues:\n * actionsQueued - queue of actions that have yet to be processed.\n * actionsDeferred - actions that have been processed through storage, but need to go to the server.\n\n@constructor",
    "_host": {
      "!type": "string",
      "!span": "4143[133:9]-4148[133:14]"
    },
    "_token": {
      "!type": "string",
      "!span": "4164[134:9]-4170[134:15]"
    },
    "_isDisconnected": {
      "!type": "bool",
      "!span": "4188[135:9]-4203[135:24]"
    },
    "_useBootstrapCache": {
      "!type": "bool",
      "!span": "4222[136:9]-4240[136:27]"
    },
    "auraStack": {
      "!type": "[string]",
      "!span": "4258[137:9]-4267[137:18]"
    },
    "appcacheDownloadingEventFired": {
      "!type": "bool",
      "!span": "4283[138:9]-4312[138:38]"
    },
    "isOutdated": {
      "!type": "bool",
      "!span": "4331[139:9]-4341[139:19]"
    },
    "initDefsObservers": {
      "!type": "[fn()]",
      "!span": "4360[140:9]-4377[140:26]"
    },
    "finishedInitDefs": {
      "!type": "bool",
      "!span": "4393[141:9]-4409[141:25]",
      "!doc": "Use the non-existence of initDefs() as the sentinel indicating that defs are good to go"
    },
    "protocols": {
      "layout": {
        "!type": "bool",
        "!span": "4439[142:20]-4447[142:28]"
      },
      "!span": "4428[142:9]-4437[142:18]"
    },
    "namespaces": {
      "!span": "4464[143:9]-4474[143:19]"
    },
    "lastSendTime": {
      "!type": "number",
      "!span": "4513[144:9]-4525[144:21]"
    },
    "_appNotTearingDown": {
      "!type": "bool",
      "!span": "4606[147:9]-4624[147:27]",
      "!doc": "This will be only changed after the unload event"
    },
    "xhrTimeout": {
      "!type": "number",
      "!span": "4677[150:9]-4687[150:19]",
      "!doc": "XHR timeout (milliseconds)"
    },
    "_tokenStorageKey": {
      "!type": "string",
      "!span": "4806[153:9]-4822[153:25]",
      "!doc": "token storage key should not be changed because external client may query independently"
    },
    "_disableBootstrapCacheCookie": {
      "!type": "string",
      "!span": "5012[157:9]-5040[157:37]",
      "!doc": "cookie name to force getApplication to the server (to skip cache). done as a cookie so the server\ncan set this flag if ever required."
    },
    "NOOP": {
      "!type": "fn()",
      "!span": "5082[159:9]-5086[159:13]"
    },
    "availableXHRs": {
      "!type": "[+Aura.Services.AuraClientService$AuraXHR]",
      "!span": "5676[175:9]-5689[175:22]"
    },
    "allXHRs": {
      "!type": "[+Aura.Services.AuraClientService$AuraXHR]",
      "!span": "5714[176:9]-5721[176:16]"
    },
    "actionStoreMap": {
      "<i>": {
        "dupes": {
          "!type": "[string|fn()]",
          "!span": "63566[1879:18]-63571[1879:23]"
        },
        "!span": "63619[1881:28]-63622[1881:31]",
        "!doc": "we have a mapping."
      },
      "!span": "5746[177:9]-5760[177:23]"
    },
    "collector": {
      "!type": "+Aura.Services.AuraClientService$AuraActionCollector",
      "!span": "5776[178:9]-5785[178:18]"
    },
    "actionsQueued": {
      "!type": "[AuraInstance.context.contextGlobals|string]",
      "!span": "5883[182:9]-5896[182:22]"
    },
    "actionsDeferred": {
      "!type": "[AuraInstance.context.contextGlobals]",
      "!span": "5912[183:9]-5927[183:24]"
    },
    "httpType": {
      "!type": "string",
      "!span": "6007[187:13]-6015[187:21]"
    },
    "xhrIdleQueue": {
      "!type": "[+Function|fn()]",
      "!span": "6186[195:9]-6198[195:21]",
      "!doc": "queue of functions to run when no XHRs in flight"
    },
    "optionClientSynchronous": {
      "!type": "bool",
      "!span": "6302[200:9]-6325[200:32]",
      "!doc": "Run client actions synchronously. This is the previous behaviour."
    },
    "reloadPointPassed": {
      "!type": "bool",
      "!span": "6381[203:9]-6398[203:26]"
    },
    "persistedActionFilter": {
      "<i>": {
        "!type": "bool",
        "!span": "19646[579:47]-19649[579:50]"
      },
      "!span": "6963[214:9]-6984[214:30]",
      "!doc": "enable actions filter"
    },
    "appCacheNoUpdate": {
      "!type": "bool",
      "!span": "27935[844:16]-27951[844:32]"
    },
    "enqueueAction": {
      "!type": "fn(auraXHR: string, actions: +Component, method: ?, options: AuraClientService.enqueueAction.!3) -> bool",
      "!span": "4207[135:28]-4220[136:7]",
      "!doc": "Send an xhr with a set of actions.\n\nThe only note here is that if we fail to serialize the actions for any reason, we will log an\nerror and error out the actions. This is because we don't have a way of determining which of the\nactions errored out.\n\nUsed for instrumentation.\n\n@param auraXHR the wrapped XHR.\n@param actions the set of actions to send.\n@param method GET or POST\n@param options extra options for the send, allows callers to set headers.\n@return true if the XHR was sent, otherwise false."
    },
    "state": {
      "!type": "string",
      "!span": "29416[176:23913]-29421[176:23918]"
    },
    "needsCleaning": {
      "!type": "bool",
      "!span": "19844[176:14341]-19857[176:14354]"
    },
    "fired": {
      "!type": "bool",
      "!span": "8367[176:2864]-8372[176:2869]"
    }
  },
  "AuraComponentContext": {
    "prototype": {
      "Frame": {
        "!type": "fn(cmp: AuraComponentContext.prototype.Frame.!0)",
        "!span": "983[30:31]-988[30:36]",
        "!doc": "Inner type for stack frames."
      },
      "push": {
        "!type": "fn(cmp: AuraComponentContext.prototype.Frame.!0) -> AuraComponentContext.prototype.Frame.!0",
        "!span": "1279[41:31]-1283[41:35]",
        "!doc": "Pushes a new context frame onto the stack.\n\n@param {Component} cmp Incoming context component\n@returns old (covered-over) context component, or undefined at top of stack"
      },
      "pop": {
        "!type": "fn(cmp: AuraComponentContext.prototype.Frame.!0) -> AuraComponentContext.prototype.Frame.!0",
        "!span": "2020[60:31]-2023[60:34]",
        "!doc": "Pops an old context frame from the stack.  If the optional argument\nis supplied, verifies that the expected the component matches the\npopped context, causing a crash ($A.assert) if we have a mismatch.\n\nThe severe death-on-mismatch behavior is because we expect the context\nto control e.g. permissions for access, so a mismatch is a data security\nhole.\n\n@param {Component} cmp Either undefined, or the expected current context\n     to verify.\n@returns component context that is no longer in effect"
      },
      "currentContext": {
        "!type": "fn() -> AuraComponentContext.prototype.Frame.!0",
        "!span": "2339[73:31]-2353[73:45]",
        "!doc": "Gets the current context's component.\n\n@return top-of-stack context, or undefined."
      },
      "addNote": {
        "!type": "fn(k: ?, v: ?)",
        "!span": "2703[83:31]-2710[83:38]",
        "!doc": "Sets an annotation for the current context frame.  Since annotations are specific to\nthe uses of the context stack, it is up to those users to ensure name collisions and\nsuch are safely handled."
      },
      "getNote": {
        "!type": "fn(k: ?)",
        "!span": "3010[97:31]-3017[97:38]",
        "!doc": "Gets an annotation from the current context frame."
      },
      "clearNote": {
        "!type": "fn(k: ?)",
        "!span": "3318[111:31]-3327[111:40]",
        "!doc": "Removes an annotation from the current context frame."
      }
    },
    "!type": "fn()",
    "!span": "812[24:9]-832[24:29]",
    "!doc": "A glorified stack to keep track of which component we're working\non behalf of.  Stack frames may have arbitrary annotations attached.\n\n@constructor"
  },
  "AuraComponentService": {
    "prototype": {
      "get": {
        "!type": "fn(globalId: string) -> +Component",
        "!span": "2229[61:31]-2232[61:34]",
        "!doc": "Gets an instance of a component.\n@param {String} globalId The generated globally unique Id of the component that changes across pageloads.\n\n@public\n@deprecated use getComponent instead\n@export"
      },
      "getComponent": {
        "!type": "fn(identifier: ?) -> +Component",
        "!span": "2568[73:31]-2580[73:43]",
        "!doc": "Gets an instance of a component from either a GlobalId or a DOM element that was created via a Component Render.\n@param {Object} identifier that is either a globalId or an element.\n\n@public\n@platform\n@export"
      },
      "getDescriptorFromConfig": {
        "!type": "fn(descriptorConfig: ?) -> !0",
        "!span": "2888[83:31]-2911[83:54]",
        "!doc": "Gets descriptor from the config object (for normalization)\n@param {Object} Controller descriptor config\n@returns {String} Descriptor\n@private"
      },
      "createDescriptorConfig": {
        "!type": "fn(descriptor: string) -> ?|string",
        "!span": "3314[95:31]-3336[95:53]",
        "!doc": "Gets descriptor from the config object (for normalization)\n@param {Object} Controller descriptor config\n@returns {String} Descriptor\n@private"
      },
      "countComponents": {
        "!type": "fn() -> number",
        "!span": "3807[111:31]-3822[111:46]",
        "!doc": "Counts all the components currently created in the application.\n@example\nvar count = $A.componentService.countComponents();\n\n@public\n@platform\n@export"
      },
      "getRenderingComponentForElement": {
        "!type": "fn(element: ?) -> +Component",
        "!span": "4145[122:31]-4176[122:62]",
        "!doc": "Gets the rendering component for the provided element recursively.\n@param {Object} element The element that is used to find the rendering component\n@memberOf AuraComponentService\n@public\n@export"
      },
      "getAttributeProviderForElement": {
        "!type": "fn(element: ?)",
        "!span": "4816[147:31]-4846[147:61]",
        "!doc": "Gets the attribute provider for the provided element.\n@param {Object} element The element whose attribute provider is to be returned\n@memberOf AuraComponentService\n@public\n@export"
      },
      "newComponentArray": {
        "!type": "fn(config: AuraComponentService.prototype.newComponentArray.!0, attributeValueProvider: ?, localCreation: bool, doForce: bool) -> [AuraComponentService.prototype.newComponentArray.!ret|+Aura.Utils.Util.prototype.globalEval.!ret]",
        "!span": "5043[155:31]-5060[155:48]",
        "!doc": "Create a new component array.\n@private"
      },
      "createComponent": {
        "!type": "fn(type: string, attributes: ?, callback: +Function)",
        "!span": "6221[182:31]-6236[182:46]",
        "!doc": "Create a component from a type and a set of attributes.\nIt accepts the name of a type of component, a map of attributes,\nand a callback to notify callers.\n\n@param {String} type The type of component to create, e.g. \"ui:button\".\n@param {Object} attributes A map of attributes to send to the component. These take the same form as on the markup,\nincluding events <code>{\"press\":component.getReference(\"c.handlePress\")}</code>, and id <code>{\"aura:id\":\"myComponentId\"}</code>.\n@param {Function} callback The method to call, to which it returns the newly created component.\n\n@example\n$A.createComponent(\"aura:text\",{value:'Hello World'}, function(auraTextComponent, status, statusMessagesList){\n     // auraTextComponent is an instance of aura:text containing the value Hello World\n});\n\n@public\n@platform\n@export"
      },
      "createInternalConfig": {
        "!type": "fn(config: AuraComponentService.prototype.createInternalConfig.!ret) -> AuraComponentService.prototype.createInternalConfig.!ret",
        "!span": "7367[209:31]-7387[209:51]",
        "!doc": "Creates an internal object config for a component from a public config.\n\nThis is only used by createComponentFromConfig to separate the internal\nrepresentation from the external representation.\nIf we change the component format, we could change this method\nwithout breaking anyone's code.\n\n@function"
      },
      "createComponentFromConfig": {
        "!type": "fn(config: ?) -> +Aura.Utils.Util.prototype.globalEval.!ret",
        "!span": "8946[255:31]-8971[255:56]",
        "!doc": "Creates a component from a config.\n\nIt accepts a config Object generated directly by the framework\nor a custom manually created config (see notes for details).\n\nIMPORTANT NOTES:\n\n- It's key that we separate the internal representation of a component\nfrom the external one (publicly available), so we can always improve\nand change the framework implementation without breaking anything.\n\n- Passing a user generated config is discouraged (instead createComponent\nshould be used). This method will only work for clientCreatable components\nand for very simple use cases.\n\n@param {Object} config A map with the component tree configuration,\nthe configuration can be external (publicly exposed) or internal.\n\n{\n     descriptor    : \"markup://ns:cmpName\",\n     localId       : \"localId\",\n     flavor        : \"flavor\",\n     attributes    : { attr1: value1, ... },\n     valueProvider : myValueProviderComponent\n}\n\n@public\n@function\n@export"
      },
      "createComponents": {
        "!type": "fn(components: [?], callback: +Function)",
        "!span": "10406[293:31]-10422[293:47]",
        "!doc": "Create an array of components from a list of types and attributes.\nIt accepts a list of component names and attribute maps, and a callback\nto notify callers.\n\n@param {Array} components The list of components to create, e.g. <code>[\"ui:button\",{\"press\":component.getReference(\"c.handlePress\")}]</code>\n@param {Function} callback The method to call, to which it returns the newly created components.\n\n@example $A.createComponents([\n     [\"aura:text\",{value:'Hello'}],\n     [\"ui:button\",{label:'Button'}],\n     [\"aura:text\",{value:'World'}]\n ],function(components,status,statusMessagesList){\n     // Components is an array of 3 components\n     // 0 - Text Component containing Hello\n     // 1 - Button Component with label Button\n     // 2 - Text component containing World\n });\n\n@public\n@platform\n@function\n@export"
      },
      "newComponent": {
        "!type": "fn(config: ?, attributeValueProvider: ?, localCreation: ?, doForce: ?) -> [AuraComponentService.prototype.newComponentArray.!ret|+Aura.Utils.Util.prototype.globalEval.!ret]|+Aura.Utils.Util.prototype.globalEval.!ret",
        "!span": "11840[329:31]-11852[329:43]",
        "!doc": "newComponent() calls newComponentDeprecated().\n@param {Object} config Use config to pass in your component definition and attributes. Supports lazy or exclusive loading by passing in \"load\": \"LAZY\" or \"load\": \"EXCLUSIVE\"\n@param {Object} attributeValueProvider The value provider for the attributes\n\n@public\n@deprecated use createComponent instead\n@export"
      },
      "newComponentDeprecated": {
        "!type": "fn(config: AuraComponentService.prototype.newComponentArray.!0, attributeValueProvider: ?, localCreation: bool, doForce: bool) -> [AuraComponentService.prototype.newComponentArray.!ret|+Aura.Utils.Util.prototype.globalEval.!ret]|+Aura.Utils.Util.prototype.globalEval.!ret",
        "!span": "12608[345:31]-12630[345:53]",
        "!doc": "Creates a new component on the client or server and initializes it. For example <code>$A.services.component.newComponentDeprecated(\"ui:inputText\")</code>\ncreates a <code>ui:inputText</code> component.\n@param {Object} config Use config to pass in your component definition and attributes. Supports lazy or exclusive loading by passing in \"load\": \"LAZY\" or \"load\": \"EXCLUSIVE\"\n@param {Object} attributeValueProvider The value provider for the attributes\n\n@platform\n@function\n@deprecated use createComponent instead\n@export"
      },
      "createComponentInstance": {
        "!type": "fn(config: AuraComponentService.prototype.createComponentInstance.!0, localCreation: bool) -> +Aura.Utils.Util.prototype.globalEval.!ret",
        "!span": "15657[423:31]-15680[423:54]",
        "!doc": "Takes a config for a component, and creates an instance of the component using the component class of that component.\n@param {Object} config Config is the same object you would pass to the constructor $A.Component to create a component. This method will use that information to further configure the component class that is created.\n@param {Boolean} localCreation See documentation on Component.js constructor for documentation on the localCreation property."
      },
      "addComponentClass": {
        "!type": "fn(descriptor: string, exporter: +Function)",
        "!span": "19374[504:31]-19391[504:48]",
        "!doc": "Use the specified constructor as the definition of the class descriptor.\nWe store them for execution later so we do not load definitions into memory unless they are utilized in getComponentClass.\n@param {String} descriptor Uses the pattern of namespace:componentName.\n@param {Function} exporter A function that when executed will return the component object litteral.\n@export"
      },
      "getComponentClass": {
        "!type": "fn(descriptor: ?|string) -> fn()|+Function",
        "!span": "19854[514:31]-19871[514:48]",
        "!doc": "Get the class constructor for the specified component.\n@param {String} descriptor use either the fqn markup://prefix:name or just prefix:name of the component to get a constructor for.\n@returns Either the class that defines the component you are requesting, or undefined if not found.\n@export"
      },
      "hasComponentClass": {
        "!type": "fn(descriptor: string) -> bool",
        "!span": "20419[525:31]-20436[525:48]",
        "!doc": "Detects of the component class has been already defined without actually defining it.\nhasComponentClass is more performant that running getComponentClass() since if the class\nhasn't been built yet, we don't want it to be forcably built if not requested.\n\n@param {String} descriptor The qualified name of the component to check in the form prefix:componentname or protocol://prefix:componentname"
      },
      "newComponentAsync": {
        "!type": "fn(callbackScope: ?, callback: +Function, config: [?|?]|?, attributeValueProvider: ?, localCreation?: bool, doForce?: bool, forceServer?: bool)",
        "!span": "21469[545:31]-21486[545:48]",
        "!doc": "Asynchronous version of newComponent(). Creates a new component and\ncalls your provided callback with the completed component regardless of any server-side dependencies.\n\n@param {Object} callbackScope The \"this\" context for the callback (null for global)\n@param {Function} callback The callback to use once the component is successfully created\n@param {Object} config The componentDef descriptor and attributes for the new component\n@param {Object} attributeValueProvider The value provider for the attributes\n@param {Boolean} [localCreation] Whether created client side (passed to Component)\n@param {Boolean} [doForce] Whether to force client side creation\n@param {Boolean} [forceServer] Whether to force server side creation\n\n@deprecated Use <code>$A.createComponent(String type, Object attributes, function callback)</code> instead.\n@platform\n@export"
      },
      "requestComponent": {
        "!type": "fn(callback: fn(component: +Aura.Utils.Util.prototype.globalEval.!ret, status: string, statusMessage: string)|+Function, config: AuraComponentService.prototype.requestComponent.!1, avp: ?, index: number, returnNullOnError: ?) -> PropertyReferenceValue.lastResult",
        "!span": "25268[632:31]-25284[632:47]",
        "!doc": "Request component from server.\n\n@param config\n@param callback\n@private"
      },
      "computeValue": {
        "!type": "fn(valueObj: ?, valueProvider: ?) -> !0",
        "!span": "28579[728:31]-28591[728:43]",
        "!doc": "Evaluates value object into their literal values. Typically used to pass configs to server.\n\n@param {Object} valueObj Value Object\n@param {Object} valueProvider value provider\n\n@returns {*}\n@export"
      },
      "getComponentConfigs": {
        "!type": "fn(config: AuraComponentService.prototype.newComponentArray.!0|[?|?], attributeValueProvider: ?) -> AuraComponentService.prototype.getComponentConfigs.!ret",
        "!span": "28989[739:31]-29008[739:50]",
        "!doc": "Provides processed component config, definition, and descriptor.\n\n@param {Object} config\n@param {Object} attributeValueProvider\n@return {Object} {{configuration: {}, definition: ComponentDef, descriptor: String}}"
      },
      "index": {
        "!type": "fn(component: +Component)",
        "!span": "31203[804:31]-31208[804:36]",
        "!doc": "Indexes the component using its global Id, which is uniquely generated across pageloads.\n@private"
      },
      "hasDefinition": {
        "!type": "fn(descriptor: string) -> bool",
        "!span": "31842[818:31]-31855[818:44]",
        "!doc": "Checks to see if the definition for the component currently reside on the client and the context has access to it.\nCould still exist on the server, we won't know that till we use a getDefinition call to try to retrieve it.\n\nThis method is private, to use it, use $A.hasDefinition(\"prefix:name\");\n\n@private\n@param  {String}  descriptor Component descriptor in the pattern prefix:name or markup://prefix:name.\n@return {Boolean}            True if the definition is present on the client."
      },
      "getUnusedDefinitions": {
        "!type": "fn() -> [string]|[?]",
        "!span": "32103[827:31]-32123[827:51]",
        "!doc": "Return the definition of the components that were not used yet (we have the def config but we haven't build the def instance)\n@export"
      },
      "getDefinition": {
        "!type": "fn(descriptor: string, callback: +Function)",
        "!span": "32814[842:31]-32827[842:44]",
        "!doc": "Get the component definition. If it is not available will go to the server to retrieve it.\n\nThis method is private, to utilize it, you should use $A.getDefinition(\"prefix:markup\");\n\n@private\n\n@param  {String}   descriptor Component descriptor in the pattern prefix:name or markup://prefix:name.\n@param  {Function} callback   Function that is passed the definition. The definition may be NULL if either the definition does not exist, or you do not have access to it.\n@return undefined             Always use the callback to access the returned definition."
      },
      "getComponentDef": {
        "!type": "fn(config: ?) -> +ComponentDef",
        "!span": "34376[890:31]-34391[890:46]",
        "!doc": "Gets the component definition from the registry for internal use, without access checks.\n\n@param {Object} descriptor The descriptor object.\n@returns {ComponentDef} The metadata of the component\n\n@private"
      },
      "getDef": {
        "!type": "fn(descriptor: ?) -> +ComponentDef",
        "!span": "35352[916:31]-35358[916:37]",
        "!doc": "Gets the component definition from the registry.\nDoes not go to the server if the definition is not available.\n\n@param {String|Object} descriptor The descriptor (<code>markup://ui:scroller</code>) or other component attributes that are provided during its initialization.\n@returns {ComponentDef} The metadata of the component\n\n@public\n@export\n@deprecated use getDefinition(descriptor, callback) instead, it will go to the server if the definition is not present on the client."
      },
      "createFromSavedComponentConfigs": {
        "!type": "fn(config: ?) -> +ComponentDef",
        "!span": "36413[945:31]-36444[945:62]",
        "!doc": "Checks for saved component config, creates if available, and deletes the config\n\n@param {String} descriptor component descriptor to check and create\n@return {ComponentDef} component definition if config available\n@private"
      },
      "createComponentDef": {
        "!type": "fn(config: ?) -> +ComponentDef",
        "!span": "36893[959:31]-36911[959:49]",
        "!doc": "Creates ComponentDef from provided config\n@param {Object} config component definition config\n@return {ComponentDef}\n@private"
      },
      "getControllerDef": {
        "!type": "fn(descriptor: string) -> +ControllerDef",
        "!span": "37601[981:31]-37617[981:47]",
        "!doc": "Gets the component's controller definition from the registry.\n@param {String} descriptor controller descriptor\n@returns {ControllerDef} ControllerDef from registry\n@private"
      },
      "getDefFromRelationship": {
        "!type": "fn(descriptor: string, relationshipMap: ?, registry: ?) -> !2.<i>",
        "!span": "38243[995:31]-38265[995:53]",
        "!doc": "ControllerDef and ActionDef are within ComponentDef. ComponentDef(s) are only created when used so\nwe need to create the component def if ControllerDef or ActionDef is requested directly\n\n@param {String} descriptor descriptor for definition\n@param {Object} relationshipMap relationship map referencing ComponentDef descriptor\n@param {Object} registry registry that hold definition type\n@return {*} Def definition\n@private"
      },
      "createControllerDef": {
        "!type": "fn(config: ?) -> +ControllerDef",
        "!span": "38900[1014:31]-38919[1014:50]",
        "!doc": "Creates and returns ControllerDef\n@param {Object} config Configuration for ControllerDef\n@returns {ControllerDef} ControllerDef from registry\n@private"
      },
      "getActionDef": {
        "!type": "fn(descriptor: string) -> +ActionDef",
        "!span": "39449[1031:31]-39461[1031:43]",
        "!doc": "Gets the action definition from the registry.\n@param {String} descriptor actionDef descriptor\n@returns {ActionDef} ActionDef from registry\n@private"
      },
      "createActionDef": {
        "!type": "fn(config: ?) -> +ActionDef",
        "!span": "39785[1041:31]-39800[1041:46]",
        "!doc": "Creates and returns ActionDef\n@param {Object} config Configuration for ActionDef\n@returns {ActionDef} ControllerDef from registry\n@private"
      },
      "getModelDef": {
        "!type": "fn(descriptor: string) -> !this.modelDefRegistry.<i>",
        "!span": "40311[1059:31]-40322[1059:42]",
        "!doc": "Gets the model definition from the registry.\n@param {String} descriptor ModelDef descriptor\n@returns {ModelDef} ModelDef from registry\n@private"
      },
      "createModelDef": {
        "!type": "fn(config: ?) -> +ModelDef",
        "!span": "40580[1069:31]-40594[1069:45]",
        "!doc": "Creates and returns ModelDef\n@param {Object} config Configuration for ModelDef\n@returns {ModelDef} ModelDef from registry\n@private"
      },
      "hasLibrary": {
        "!type": "fn(descriptor: string) -> bool",
        "!span": "41057[1084:31]-41067[1084:41]",
        "!doc": "Detects if the library exists without actually defining it.\n@param {String} descriptor The qualified name of the library in the form markup://namespace:library"
      },
      "saveLibraryConfig": {
        "!type": "fn(config: ?)",
        "!span": "41289[1093:31]-41306[1093:48]",
        "!doc": "Stores a library definition.\n@param {Object} config component definition config\n@export"
      },
      "getLibrary": {
        "!type": "fn(descriptor: string) -> ?",
        "!span": "41811[1109:31]-41821[1109:41]",
        "!doc": "Get a library from the registry.\n@param {String} descriptor library descriptor.\n@returns {Object} library from registry.\n@private"
      },
      "addLibraryInclude": {
        "!type": "fn(descriptor: string, dependencies: [?], exporter: +Function)",
        "!span": "42202[1120:31]-42219[1120:48]",
        "!doc": "Store a library include.\n@param {String} descriptor name of the include.\n@param {Array} dependencies The list of dependencies (other includes).\n@param {Function} exporter A function that when executed will return the include object.\n@export"
      },
      "getLibraryInclude": {
        "!type": "fn(descriptor: string) -> [?]",
        "!span": "42619[1130:31]-42636[1130:48]",
        "!doc": "Get a library include from the registry.\n@param {String} descriptor in the form markup://namespace:include.\n@returns Either the instance of the include you are requesting, or undefined if not found.\n@private"
      },
      "destroy": {
        "!type": "fn(components: [AuraComponentService.prototype.destroy.!0])",
        "!span": "42815[1138:31]-42822[1138:38]",
        "!doc": "Destroys the components.\n@private"
      },
      "deIndex": {
        "!type": "fn(globalId: string)",
        "!span": "43183[1155:31]-43190[1155:38]",
        "!doc": "Removes the index of the component.\n@private"
      },
      "getRegisteredComponentDescriptors": {
        "!type": "fn() -> [+ComponentDef]",
        "!span": "43424[1165:31]-43457[1165:64]",
        "!doc": "Returns the descriptors of all components known to the registry.\n@memberOf AuraComponentService\n@public\n@export"
      },
      "getDynamicNamespaces": {
        "!type": "fn() -> !this.dynamicNamespaces",
        "!span": "43737[1180:31]-43757[1180:51]",
        "!doc": "Get the dynamic namespaces defined by 'layout://name'"
      },
      "getIndex": {
        "!type": "fn() -> string",
        "!span": "43895[1188:31]-43903[1188:39]",
        "!doc": "@memberOf AuraComponentService\n@export"
      },
      "isConfigDescriptor": {
        "!type": "fn(config: ?) -> !0",
        "!span": "44565[1212:31]-44583[1212:49]",
        "!doc": "@memberOf AuraComponentService\n@private"
      },
      "saveComponentConfig": {
        "!type": "fn(config: ?)",
        "!span": "45429[1233:31]-45448[1233:50]",
        "!doc": "Saves component config so it can be use later when component def is actually used.\nAllows Aura to only create ComponentDef when needed\n\nAlso save reference to componentDef for its ControllerDef and ActionDefs in cases\nwhere direct access to the defs are needed\n\n@param {Object} config component definition config"
      },
      "restoreDefsFromStorage": {
        "!type": "fn(context: AuraInstance.context) -> ?",
        "!span": "46738[1268:31]-46760[1268:53]",
        "!doc": "Asynchronously retrieves all definitions from storage and adds to saved component config or library registry.\n@return {Promise} a promise that resolves when definitions are restored."
      },
      "clearDefsFromStorage": {
        "!type": "fn(metricsPayload?: AuraComponentService.prototype.clearDefsFromStorage.!0) -> ?",
        "!span": "47577[1287:31]-47597[1287:51]",
        "!doc": "Clears persisted definitions and all dependent stores and context.\n@param {Object} [metricsPayload] optional payload to send to metrics service.\n@return {Promise} Promise when storage is cleared"
      },
      "saveDefsToStorage": {
        "!type": "fn(config: ?, context: ?) -> ?",
        "!span": "48100[1298:31]-48117[1298:48]",
        "!doc": "Saves component and library defs to persistent storage.\n@param {Object} config the config bag from which defs are to be stored.\n@param {Object} context the context (already merged)\n@return {Promise} promise which resolves when storing is complete. If errors occur during\n the process they are handled (and logged) so the returned promise always resolves."
      },
      "createComponentPrivAsync": {
        "!type": "fn(config: AuraComponentService.prototype.requestComponent.!1, callback: fn(component: +Aura.Utils.Util.prototype.globalEval.!ret, status: string, statusMessage: string)|+Function, forceClientCreation: ?)",
        "!span": "49945[1344:31]-49969[1344:55]"
      },
      "createComponentPriv": {
        "!type": "fn(config: string)",
        "!span": "51534[1381:31]-51553[1381:50]"
      },
      "findDependencies": {
        "!type": "fn(key: string, defConfig: ?, storedDeps: [?]) -> [!1.<i>]",
        "!span": "52990[1420:31]-53006[1420:47]",
        "!doc": "Find dependencies of a component def or action.\n@param {String} key the component def or action id.\n@param {Object} defConfig\n@param {Array} storedDeps\n@return {Array} the list of dependencies"
      },
      "buildDependencyGraph": {
        "!type": "fn() -> ?",
        "!span": "54954[1468:31]-54974[1468:51]",
        "!doc": "Builds the dependency graph for for all persisted component definitions and stored actions (persistent or not).\n\nA component definition depends on components in its superDef chain and its facets.\nA stored action depends on components specified in its return value.\nThis definition is recursive.\n\nFor example:\n- Three components: plant, tree, leaf.\n- Tree's superDef is plant.\n- Tree has leaf in its facet.\n- An action was used to retrieve an instance of tree.\n\nTree's graph node looks like this:\n{ action: false, id: \"markup://ns:tree\", dependencies: [\"markup://ns:plant\", \"markup://ns:leaf\"] }\n\nThe action's graph node looks like this:\n{ action: true, id: \"java://.../ACTION$getTree:{}\", dependencies: [\"markup://ns:tree\", \"markup://ns:plant\", \"markup://ns:leaf\"] }\n\n@return {Promise} promise that resolves to an object (keyed on descriptor) of dependency objects. A dependency object has these keys:\n- action: true if this is an action, false if a component definition.\n- id: the action or def descriptor.\n- dependencies: array of action/def descriptors this item depends on."
      },
      "sortDependencyGraph": {
        "!type": "fn(graph: ?) -> [?]",
        "!span": "57152[1517:31]-57171[1517:50]",
        "!doc": "Sorts the dependency graph by topological order.\n@param {Object} graph a graph of nodes. See #buildDependencyGraph().\n@return {Array} a topologically sorted array of node ids."
      },
      "getUpstreamDependencies": {
        "!type": "fn(rootKey: string, graph: ?, upstream: AuraComponentService.prototype.getUpstreamDependencies.!2) -> AuraComponentService.prototype.getUpstreamDependencies.!ret",
        "!span": "59081[1568:31]-59104[1568:54]",
        "!doc": "Gets the \"upstream\" dependencies for a node in the graph. In other words, gets the nodes from the\ngraph that are dependent, directly or indirectly, on a given node.\n\nThis provides the list of component definitions and actions which must be removed if a given\ncomponent definition is removed.\n\nFor example:\n- Three components: plant, tree, leaf.\n- Tree's superDef is plant.\n- Tree has leaf in its facet.\n- An action was used to retrieve an instance of tree.\n\nIf node is leaf then the upstream dependencies are:\n- tree because it has leaf in a facet\n- action because it depends on tree\n\nNotably plant is not an upstream dependency. It does not depend on leaf, tree or action.\n\n@param {String} rootKey key of the graph node whose upstream dependencies are desired.\n@param {Object} graph a graph of nodes. See #buildDependencyGraph().\n@param {Object} upstream map to populate with upstream dependencies. Key is the graph key; value is always true."
      },
      "splitComponentsAndActions": {
        "!type": "fn(graph: ?, keys: ?, exclude: [?], actions: [bool], defs: [bool])",
        "!span": "59991[1591:31]-60016[1591:56]",
        "!doc": "Separates the keys into actions and defs, pruning those that appear in exclude.\n@param {Object} graph a graph of nodes. See #buildDependencyGraph().\n@param {Object} keys a map whose keys are graph keys.\n@param {Array} exclude the list of keys to exclude.\n@param {Array} actions the array to populate with action keys.\n@param {Array} defs the array to populate with component def keys."
      },
      "evictDefsFromStorage": {
        "!type": "fn(sortedKeys: [?], graph: ?, requiredSpaceKb: number) -> ?",
        "!span": "60818[1612:31]-60838[1612:51]",
        "!doc": "Evicts component definitions and dependent actions from storage until the\ncomponent def storage is under a size threshold.\n\n@param {Array} sortedKeys the ordered list of graph keys to remove under the size threshold is met.\n@param {Object} graph a graph of nodes. See #buildDependencyGraph().\n@param {Number} requiredSpaceKb space required to store incoming defs.\n@return {Promise} a promise that resolves with the list of evicted actions and component defs."
      },
      "pruneDefsFromStorage": {
        "!type": "fn(requiredSpaceKb: number) -> ?",
        "!span": "65814[1724:31]-65834[1724:51]",
        "!doc": "Prunes component definitions and dependent actions from persistent storage.\n\nThis is the entry point for dependency graph generation, analysis, and\neviction. Eviction proceeds until the component def storage is under a threshold\nsize or all component defs are evicted from storage.\n\n@param {Number} requiredSpaceKb space (in KB) required by new configs to be stored.\n@return {Promise} a promise that resolves when pruning is complete."
      }
    },
    "!type": "fn()",
    "!span": "807[22:9]-827[22:29]",
    "!doc": "@description The Aura Component Service, accessible using $A.service.component.  Creates and Manages Components.\n@constructor\n@export",
    "componentDefRegistry": {
      "!span": "864[24:9]-884[24:29]",
      "!doc": "Def registries",
      "<i>": "+ComponentDef"
    },
    "controllerDefRegistry": {
      "<i>": {
        "!type": "+ControllerDef",
        "!span": "39205[1020:35]-39215[1020:45]"
      },
      "!span": "902[25:9]-923[25:30]"
    },
    "actionDefRegistry": {
      "!span": "940[26:9]-957[26:26]",
      "<i>": "+ActionDef"
    },
    "modelDefRegistry": {
      "!span": "978[27:9]-994[27:25]",
      "<i>": "+ModelDef"
    },
    "libraryRegistry": {
      "!type": "+LibraryRegistry",
      "!span": "1016[28:9]-1031[28:24]"
    },
    "libraryIncludeRegistry": {
      "!type": "+LibraryIncludeRegistry",
      "!span": "1086[29:9]-1108[29:31]"
    },
    "componentClassRegistry": {
      "!type": "+ComponentClassRegistry",
      "!span": "1163[30:9]-1185[30:31]"
    },
    "componentDefStorage": {
      "!type": "+ComponentDefStorage",
      "!span": "1242[31:9]-1261[31:28]"
    },
    "savedComponentConfigs": {
      "!span": "1367[34:9]-1388[34:30]",
      "!doc": "holds ComponentDef configs to be created"
    },
    "controllerDefRelationship": {
      "!span": "1479[37:9]-1504[37:34]",
      "!doc": "references ControllerDef descriptor to its ComponentDef descriptor",
      "<i>": "?"
    },
    "actionDefRelationship": {
      "!span": "1591[40:9]-1612[40:30]",
      "!doc": "references ActionDef descriptor to its ComponentDef descriptor",
      "<i>": "?"
    },
    "indexes": {
      "globalId": {
        "!span": "1682[43:21]-1690[43:29]",
        "<i>": "+Component"
      },
      "!span": "1670[43:9]-1677[43:16]",
      "!doc": "Global registry for cmp instances"
    },
    "dynamicNamespaces": {
      "!type": "[?]",
      "!span": "1709[45:9]-1726[45:26]",
      "!doc": "clear dynamic namespaces so that the server can send it back."
    },
    "flavorable": {
      "!type": "string",
      "!span": "1822[48:9]-1832[48:19]",
      "!doc": "Static attr names"
    },
    "renderedBy": {
      "!type": "string",
      "!span": "1865[49:9]-1875[49:19]"
    },
    "_isDisconnected": {
      "!type": "bool",
      "!span": "9649[176:4146]-9664[176:4161]"
    },
    "lastSendTime": {
      "!type": "number",
      "!span": "68475[176:62972]-68487[176:62984]"
    },
    "state": {
      "!type": "string",
      "!span": "29416[176:23913]-29421[176:23918]"
    },
    "needsCleaning": {
      "!type": "bool",
      "!span": "19844[176:14341]-19857[176:14354]"
    },
    "fired": {
      "!type": "bool",
      "!span": "8367[176:2864]-8372[176:2869]"
    }
  },
  "AuraDevToolService": {
    "!type": "fn() -> AuraInstance.devToolService",
    "!span": "809[22:4]-827[22:22]",
    "!doc": "@description The Aura Dev Tool Service, accessible using $A.devToolServices.\nUse mostly in non-production modes.\n@constructor\n@protected"
  },
  "AuraError": {
    "prototype": {
      "toString": {
        "!type": "fn() -> !this.message",
        "!span": "4166[119:20]-4174[119:28]"
      },
      "!proto": "Error.prototype",
      "!span": "4076[117:10]-4085[117:19]",
      "constructor": "AuraError"
    },
    "!type": "fn()",
    "!span": "1008[25:9]-1017[25:18]",
    "!doc": "@description Creates an AuraError instance.\n@constructor\n@param {String} message - the detail message about the error.\n@param {Object} innerError - an Error object whose properties are to be placed into AuraError.\n@param {String} severity - the severity of the error. Aura built-in values are defined in $A.severity.\n@export"
  },
  "AuraEventService": {
    "prototype": {
      "qualifyEventName": {
        "!type": "fn(event: string) -> !0",
        "!span": "1066[32:27]-1082[32:43]",
        "!doc": "Returns qualified event name\n@param {String} event Event name\n@returns {String} qualified event name"
      },
      "newEvent": {
        "!type": "fn(eventDef: string, eventName?: ?, sourceCmp: ?) -> +Event",
        "!span": "1921[53:27]-1929[53:35]",
        "!doc": "Creates a new application event. Set the event parameters using <code>event.setParams()</code> and fire\nit using <code>event.fire()</code>. For example, <code>$A.eventService.newEvent(\"app:navError\")</code>\nfires the <code>app:navError</code> event. Set parameters on the new event\nby using <code>event.setParams()</code>.\n\n@param {String} eventDef The event object in the format namespace:component\n@param {String=} eventName The event name if the event is a \"COMPONENT\" type event\n@param {sourceCmp=} eventName The component source if the event is a \"COMPONENT\" type event\n@return {Event} new Event\n@memberOf AuraEventService\n@public\n@export"
      },
      "getNewEvent": {
        "!type": "fn(eventDefinition: string, eventName?: ?, sourceCmp: ?) -> +Event",
        "!span": "2640[69:27]-2651[69:38]",
        "!doc": "Get a new Event instance, but do not do an access check on the event definition. This method is private to\naura and should only be used within trusted portions of the framework.\n\n@param {String} eventDef The event object in the format namespace:component\n@param {String=} eventName The event name if the event is a \"COMPONENT\" type event\n@param {sourceCmp=} eventName The component source if the event is a \"COMPONENT\" type event\n@return {Event} new Event"
      },
      "dispatchEventHandlers": {
        "!type": "fn(handlers: ?, evt: +Event)",
        "!span": "3391[94:27]-3412[94:48]",
        "!doc": "Dispatch events\n@param {Event} evt The event object\n@memberOf AuraEventService\n@private"
      },
      "bubbleEvent": {
        "!type": "fn(evt: ?)",
        "!span": "3691[106:27]-3702[106:38]",
        "!doc": "Bubbles the event from the source to the root\n@param {Event} evt The event object\n@memberOf AuraEventService\n@private"
      },
      "get": {
        "!type": "fn(name: string, callback?: +Function)",
        "!span": "7845[197:27]-7848[197:30]",
        "!doc": "Returns the new event.\n@param {String} name The event object in the format namespace:component\n@param {Function} [callback] The function that gets executed when the get has succeeded. Since this could download the event def if it is not present you need the callback to get the definition.\n@memberOf AuraEventService"
      },
      "addHandler": {
        "!type": "fn(config: ?|AuraEventService.prototype.addHandler.!0)",
        "!span": "8261[215:27]-8271[215:37]",
        "!doc": "Adds an event handler.\n@param {Object} config The data for the event handler\n@memberOf AuraEventService\n@public\n@export"
      },
      "removeHandler": {
        "!type": "fn(config: AuraEventService.prototype.removeHandler.!0)",
        "!span": "8905[238:27]-8918[238:40]",
        "!doc": "Removes an event handler.\n@param {Object} config The data for the event\n@memberOf AuraEventService\n@public\n@export"
      },
      "getEventDef": {
        "!type": "fn(config: string) -> +EventDef",
        "!span": "9458[256:27]-9469[256:38]",
        "!doc": "Returns the event definition.\nInternal method to the framework. To get an event def from the API, use $A.get(\"e.prefix:name\", function(def){});\n\n@param {String} descriptor name of EventDef\n@return {EventDef} The event definition.\n@memberOf AuraEventService\n@private"
      },
      "getDef": {
        "!type": "fn(descriptor: string) -> +EventDef",
        "!span": "10076[275:27]-10082[275:33]",
        "!doc": "Get the event definition.\nDoes access checks.\nYou cannot fire this though, use newEvent() for that.\n\n@param  {String}  descriptor Event descriptor in the pattern prefix:name or markup://prefix:name."
      },
      "hasDefinition": {
        "!type": "fn(descriptor: string) -> bool",
        "!span": "11485[308:27]-11498[308:40]",
        "!doc": "Checks to see if the definition for the event currently reside on the client.\nCould still exist on the server, we won't know that till we use a getDefinitiion call to try to retrieve it.\nThis method is private, to use it, use $A.hasDefinition(\"e.prefix:name\");\n@private\n@param  {String}  descriptor Event descriptor in the pattern prefix:name or markup://prefix:name.\n@return {Boolean}            True if the definition is present on the client."
      },
      "createDescriptorConfig": {
        "!type": "fn(descriptor: string) -> ?|string",
        "!span": "12508[335:27]-12530[335:49]",
        "!doc": "Gets descriptor from the config object (for normalization)\n@param {Object} Controller descriptor config\n@returns {String} Descriptor\n@private"
      },
      "getDefinition": {
        "!type": "fn(descriptor: string, callback: +Function)",
        "!span": "13344[353:27]-13357[353:40]",
        "!doc": "Get the event definition. If it is not available, contact the server to download it.\n\nThis method is private, to utilize it's functionality you can use $A.getDefinition(\"e.prefix:name\");\n\n@private\n\n@param  {String}  descriptor Event descriptor in the pattern prefix:name or markup://prefix:name.\n@param  {Function} callback  The function callback that gets executed with the definition. May go to the server first.\n@return undefined            Always use the callback to access the definition."
      },
      "getDescriptorFromConfig": {
        "!type": "fn(descriptorConfig: ?|string) -> !0",
        "!span": "14233[385:27]-14256[385:50]",
        "!doc": "Gets descriptor from the config object (for normalization)\n@param {Object} Controller descriptor config\n@returns {String} Descriptor\n@private"
      },
      "createFromSavedConfigs": {
        "!type": "fn(config: ?) -> +EventDef",
        "!span": "14644[397:27]-14666[397:49]",
        "!doc": "Creates and saves EventDef into registry\n@param {Object} config config for EventDef\n@returns {EventDef} instance from registry"
      },
      "createEventDef": {
        "!type": "fn(config: ?) -> +EventDef",
        "!span": "15231[418:27]-15245[418:41]",
        "!doc": "Creates and returns EventDef from config\n@param {Object} config The parameters for the event\n@return {EventDef} The event definition.\n@memberOf AuraEventService\n@private"
      },
      "saveEventConfig": {
        "!type": "fn(config: ?)",
        "!span": "15972[441:27]-15987[441:42]",
        "!doc": "Saves EventDef config so it can be used later when EventDef is actually used.\nAllows Aura to only create EventDef when needed\n\n@param {Object} config event definition config"
      },
      "hasHandlers": {
        "!type": "fn(name: string) -> bool",
        "!span": "16330[453:27]-16341[453:38]",
        "!doc": "Returns true if the event has handlers.\n@param {String} name The event name\n@memberOf AuraEventService\n@public\n@export"
      },
      "getRegisteredEvents": {
        "!type": "fn() -> [string]|[+EventDef]",
        "!span": "16579[462:27]-16598[462:46]",
        "!doc": "Returns the qualified name of all events known to the registry.\n@export"
      },
      "hasPendingEvents": {
        "!type": "fn() -> bool",
        "!span": "16837[472:27]-16853[472:43]",
        "!doc": "Whether there are pending events\nAvailable in DEV mode only.\n@export"
      }
    },
    "!type": "fn()",
    "!span": "797[21:9]-813[21:25]",
    "!doc": "@description The Aura Event Service, accessible using $A.eventService. Creates and Manages Events.\n@constructor AuraEventService\n@export",
    "eventDispatcher": {
      "!type": "[AuraEventService.eventDispatcher.<i>]",
      "!span": "828[22:9]-843[22:24]"
    },
    "eventDefRegistry": {
      "!span": "861[23:9]-877[23:25]",
      "<i>": "+EventDef"
    },
    "savedEventConfigs": {
      "!span": "894[24:9]-911[24:26]"
    }
  },
  "AuraExpressionService": {
    "prototype": {
      "getReference": {
        "!type": "fn(expression: ?, valueProvider: ?) -> +PropertyReferenceValue",
        "!span": "852[26:32]-864[26:44]"
      },
      "clearReferences": {
        "!type": "fn(valueProvider: ?)",
        "!span": "1541[45:32]-1556[45:47]"
      },
      "updateGlobalReference": {
        "!type": "fn(expression: string, oldValue: AuraInstance.context.contextGlobals, value: string)",
        "!span": "3854[106:32]-3875[106:53]",
        "!doc": "JBUCH: TODO: FIXME: HACK"
      },
      "updateGlobalReferences": {
        "!type": "fn(type: ?, newValues: ?)",
        "!span": "4631[123:32]-4653[123:54]"
      },
      "addListener": {
        "!type": "fn(reference: +PropertyReferenceValue, expression: string, valueProvider: +Component)",
        "!span": "5324[143:32]-5335[143:43]"
      },
      "removeListener": {
        "!type": "fn(reference: +PropertyReferenceValue, expression: ?, valueProvider: ?)",
        "!span": "5903[158:32]-5917[158:46]"
      },
      "create": {
        "!type": "fn(valueProvider: ?, config: ?) -> AuraInstance.context.contextGlobals|+PropertyReferenceValue",
        "!span": "6594[177:32]-6600[177:38]",
        "!doc": "@export"
      },
      "createPassthroughValue": {
        "!type": "fn(primaryProviders: ?, cmp: ?) -> +PassthroughValue",
        "!span": "6797[185:32]-6819[185:54]",
        "!doc": "TODO: unify with above create method"
      },
      "normalize": {
        "!type": "fn(expression: ?) -> !0",
        "!span": "7259[200:32]-7268[200:41]",
        "!doc": "Trims markup syntax off a given string expression, removing\nexpression notation, and array notation.\n\n@param {Object}\n           expression The expression to be normalized.\n@returns {Object} The normalized string, or the input parameter, if\n         it was not a string.\n@export"
      },
      "resolve": {
        "!type": "fn(expression: string|[string], container: ?, rawValue: bool) -> !1",
        "!span": "8825[245:32]-8832[245:39]",
        "!doc": "Resolves a hierarchical dot expression in string form against the\nprovided object if possible.\n\n@param {String}\n           expression The string expression to be resolved.\n@param {Object}\n           container The object against which to resolve the\n           expression.\n@param {Boolean}\n           rawValue Whether or not to evaluate expressions.\n@returns {Object} The target of the expression, or undefined.\n@export"
      }
    },
    "!type": "fn()",
    "!span": "767[22:9]-788[22:30]",
    "!doc": "@description The Aura Expression Service, accessible using $A.expressionService.\nProcesses Expressions.\n@constructor\n@export",
    "references": {
      "<i>": {
        "consumers": {
          "<i>": {
            "<i>": {
              "!type": "bool",
              "!span": "5849[155:24]-5859[155:34]"
            },
            "!span": "5805[153:18]-5813[153:26]"
          },
          "!span": "1443[40:108]-1452[40:117]"
        },
        "!span": "1225[35:28]-1227[35:30]",
        "reference": "+PropertyReferenceValue",
        "<i>": "AuraExpressionService.references.<i>"
      },
      "!span": "802[23:9]-812[23:19]"
    }
  },
  "AuraHistoryService": {
    "prototype": {
      "set": {
        "!type": "fn(token: ?)",
        "!span": "1614[40:29]-1617[40:32]",
        "!doc": "Sets the new location. For example, <code>$A.services.history.set(\"search\")</code> sets the location to <code>#search</code>.\nOtherwise, use <code>$A.services.layout.changeLocation()</code> to override existing URL parameters.\n\nNative Android browser doesn't completely support pushState so we force hash method for it\nIOS7 UIWebView also has weirdness when using appcache and history so force onhashchange as well\n\n@param {Object} token The provided token set to the current location hash\n@memberOf AuraHistoryService\n@public\n@export"
      },
      "replace": {
        "!type": "fn(token: ?)",
        "!span": "3772[86:29]-3779[86:36]",
        "!doc": "Replaces the current location with the new location, meaning the current location will not be\nstored in the browser history. Analogous to window.history.replace().\nFor example, if the last location in history was '#first', the current location is '#second',\nthen <code>$A.services.history.replace(\"third\")</code> replaces <code>#second</code> with <code>#third</code>\nas the current location. Pressing the browser back button would result in location <code>#first</code>\n\nNative Android browser doesn't completely support pushState so we force hash method for it\nIOS7 UIWebView also has weirdness when using appcache and history so force onhashchange as well\nOld Native Android and old IE don't support location.replace(), so we fallback to directly\nsetting window.location.hash.\nSo, if the browser doesn't support pushState or location.replace, AuraHistoryService.replace()\nfunctions the same a AuraHistoryService.set().\n\n@param {Object} token The provided token set to the current location hash\n@memberOf AuraHistoryService\n@public\n@export"
      },
      "get": {
        "!type": "fn() -> ?",
        "!span": "5731[134:29]-5734[134:32]",
        "!doc": "Parses the location. A token can be used here.\n<p>Example:</p>\n<code>token == \"newLayout\";<br /> $A.historyService.get().token;</code>\n\n@memberOf AuraHistoryService\n@public\n@export"
      },
      "back": {
        "!type": "fn()",
        "!span": "6223[150:29]-6227[150:33]",
        "!doc": "Loads the previous URL in the history list. Standard JavaScript <code>history.go()</code> method.\n\n@memberOf AuraHistoryService\n@public\n@export"
      },
      "setTitle": {
        "!type": "fn(title: string)",
        "!span": "7065[177:29]-7073[177:37]",
        "!doc": "Sets the title of the document.\n\n@param {String} title The new title\n@memberOf AuraHistoryService\n@public\n@export"
      },
      "forward": {
        "!type": "fn()",
        "!span": "7317[188:29]-7324[188:36]",
        "!doc": "Loads the next URL in the history list. Standard JavaScript <code>history.go()</code> method.\n\n@memberOf AuraHistoryService\n@public\n@export"
      },
      "reset": {
        "!type": "fn()",
        "!span": "7937[209:29]-7942[209:34]",
        "!doc": "Resets history\n\n@public\n@export"
      },
      "usePushState": {
        "!type": "fn() -> !this._usePushState",
        "!span": "8255[221:29]-8267[221:41]",
        "!doc": "Whether to use pushState.\nNative Android browser has issues with pushState\nIOS7 UIWebView has issues with pushState and history\n@returns {boolean} true if pushState should be used\n@private"
      },
      "init": {
        "!type": "fn()",
        "!span": "8849[238:29]-8853[238:33]",
        "!doc": "@private"
      },
      "getEvent": {
        "!type": "fn() -> !this.evt",
        "!span": "10089[280:29]-10097[280:37]",
        "!doc": "@private"
      },
      "changeHandler": {
        "!type": "fn()",
        "!span": "10279[290:29]-10292[290:42]",
        "!doc": "@private"
      },
      "parseLocation": {
        "!type": "fn(location: string) -> ?",
        "!span": "11602[329:29]-11615[329:42]",
        "!doc": "@private\n@param {String} location the hash portion of the URL"
      },
      "parseQueryString": {
        "!type": "fn(querystring: string) -> AuraHistoryService.prototype.parseQueryString.!ret",
        "!span": "12503[357:29]-12519[357:45]",
        "!doc": "Parses a query string into an object. It supports values in query string containing '='.\n@param {String} querystring the query string part of the URL, the portion after '?'.\n@private"
      },
      "getLocationHash": {
        "!type": "fn() -> string",
        "!span": "13148[379:29]-13163[379:44]",
        "!doc": "Firefox unescapes location.hash, so the results are inconsistent browser to browser.\nThis method normalizes accessing the hash portion.\n@private"
      }
    },
    "!type": "fn()",
    "!span": "846[22:9]-864[22:27]",
    "!doc": "@description The Aura History Service, accessible using $A.historyService. Manages Browser History.\nInternet Explorer 7 and 8 are not supported for this service.\n@constructor\n@export",
    "history": {
      "!type": "[?]",
      "!span": "878[23:9]-885[23:16]"
    },
    "currentIndex": {
      "!type": "number",
      "!span": "928[24:9]-940[24:21]"
    },
    "_usePushState": {
      "!type": "bool",
      "!span": "8385[224:13]-8398[224:26]"
    }
  },
  "AuraLocalizationService": {
    "prototype": {
      "formatNumber": {
        "!type": "fn(number: number) -> number",
        "!span": "1623[51:34]-1635[51:46]",
        "!doc": "Formats a number with the default number format.\n@param {Number} number The number to be formatted.\n@return {Number} The formatted number\n@memberOf AuraLocalizationService\n@example\nvar num = 10000;\n// Returns 10,000\nvar formatted = $A.localizationService.formatNumber(num);\n@public\n@export\n@platform"
      },
      "formatPercent": {
        "!type": "fn(number: number) -> number",
        "!span": "2123[68:34]-2136[68:47]",
        "!doc": "Returns a formatted percentage number based on the default percentage format.\n@param {Number} number The number to be formatted.\n@return {Number} The formatted percentage\n@memberOf AuraLocalizationService\n@example\nvar num = 0.54;\n// Returns 54%\nvar formatted = $A.localizationService.formatPercent(num);\n@public\n@export\n@platform"
      },
      "formatCurrency": {
        "!type": "fn(number: number) -> number",
        "!span": "2611[85:34]-2625[85:48]",
        "!doc": "Returns a currency number based on the default currency format.\n@param {Number} number The currency number to be formatted.\n@return {Number} The formatted currency\n@memberOf AuraLocalizationService\n@example\nvar curr = 123.45;\n// Returns $123.45\n$A.localizationService.formatCurrency(curr);\n@public\n@export\n@platform"
      },
      "getNumberFormat": {
        "!type": "fn(format: string, symbols: string) -> number",
        "!span": "3294[107:34]-3309[107:49]",
        "!doc": "Returns a NumberFormat object.\n@param {String} format The number format. <code>format=\".00\"</code> displays the number followed by two decimal places.\n@param {String} symbols\n@return {Number} The number format\n@memberOf AuraLocalizationService\n@example\nvar f = $A.get(\"$Locale.numberFormat\");\nvar num = 10000\nvar nf = $A.localizationService.getNumberFormat(f);\nvar formatted = nf.format(num);\n// Returns 10,000\nvar formatted = $A.localizationService.formatNumber(num);\n@public\n@export\n@platform"
      },
      "getDefaultNumberFormat": {
        "!type": "fn() -> !this.numberFormat",
        "!span": "3751[122:34]-3773[122:56]",
        "!doc": "Returns the default NumberFormat object.\n@return {Number} The number format returned by <code>$Locale.numberFormat</code>.\n@memberOf AuraLocalizationService\n@example\n// Returns 20,000.123\n$A.localizationService.getDefaultNumberFormat().format(20000.123);\n@public\n@export\n@platform"
      },
      "getDefaultPercentFormat": {
        "!type": "fn() -> !this.percentFormat",
        "!span": "4291[141:34]-4314[141:57]",
        "!doc": "Returns the default percentage format.\n@return {Number} The percentage format returned by <code>$Locale.percentFormat</code>.\n@memberOf AuraLocalizationService\n@example\n// Returns 20%\n$A.localizationService.getDefaultPercentFormat().format(0.20);\n@public\n@export\n@platform"
      },
      "getDefaultCurrencyFormat": {
        "!type": "fn() -> !this.currencyFormat",
        "!span": "4842[159:34]-4866[159:58]",
        "!doc": "Returns the default currency format.\n@return {Number} The currency format returned by <code>$Locale.currencyFormat</code>.\n@memberOf AuraLocalizationService\n@example\n// Returns $20,000.00\n$A.localizationService.getDefaultCurrencyFormat().format(20000);\n@public\n@export\n@platform"
      },
      "displayDuration": {
        "!type": "fn(d: ?, noSuffix: bool) -> string",
        "!span": "5557[180:34]-5572[180:49]",
        "!doc": "Displays a length of time.\n@param {Duration} d The duration object returned by localizationService.duration\n@param {Boolean} noSuffix Set to true if the token should be displayed without a suffix\n@return {String} A duration object\n@memberOf AuraLocalizationService\n@public\n@example\nvar dur = $A.localizationService.duration(1, 'day');\n// Returns \"a day\"\nvar length = $A.localizationService.displayDuration(dur);\n@export\n@platform"
      },
      "displayDurationInDays": {
        "!type": "fn(d: ?) -> number",
        "!span": "6076[197:34]-6097[197:55]",
        "!doc": "Displays a length of time in days.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The length of time in days.\n@memberOf AuraLocalizationService\n@public\n@example\nvar dur = $A.localizationService.duration(24, 'hour');\n// Returns 1\nvar length = $A.localizationService.displayDurationInDays(dur);\n@export\n@platform"
      },
      "displayDurationInHours": {
        "!type": "fn(d: ?) -> number",
        "!span": "6584[214:34]-6606[214:56]",
        "!doc": "Displays a length of time in hours.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The length of time in hours.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(2, 'day');\n// Returns 48\nvar length = $A.localizationService.displayDurationInHours(dur);\n@public\n@export\n@platform"
      },
      "displayDurationInMilliseconds": {
        "!type": "fn(d: ?) -> number",
        "!span": "7120[231:34]-7149[231:63]",
        "!doc": "Displays a length of time in milliseconds.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The length of time in milliseconds.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(1, 'hour');\n// Returns 3600000\nvar length = $A.localizationService.displayDurationInMilliseconds(dur);\n@public\n@export\n@platform"
      },
      "displayDurationInMinutes": {
        "!type": "fn(d: ?) -> number",
        "!span": "7650[248:34]-7674[248:58]",
        "!doc": "Displays a length of time in minutes.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The length of time in minutes.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(1, 'hour');\n// Returns 60\nvar length = $A.localizationService.displayDurationInMinutes(dur);\n@public\n@export\n@platform"
      },
      "displayDurationInMonths": {
        "!type": "fn(d: ?) -> number",
        "!span": "8173[265:34]-8196[265:57]",
        "!doc": "Displays a length of time in months.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The length of time in months.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(60, 'day');\n// Returns 1.971293\nvar length = $A.localizationService.displayDurationInMonths(dur);\n@public\n@export\n@platform"
      },
      "displayDurationInSeconds": {
        "!type": "fn(d: ?) -> number",
        "!span": "8697[282:34]-8721[282:58]",
        "!doc": "Displays a length of time in seconds.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The length of time in seconds.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(60, 'minutes');\n// Returns 3600\nvar length = $A.localizationService.displayDurationInSeconds(dur);\n@public\n@export\n@platform"
      },
      "displayDurationInYears": {
        "!type": "fn(d: ?) -> number",
        "!span": "9213[299:34]-9235[299:56]",
        "!doc": "Displays a length of time in years.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The length of time in years.\n@memberOf AuraLocalizationService\nexample\nvar dur = $A.localizationService.duration(6, 'month');\n// Returns 0.5\nvar length = $A.localizationService.displayDurationInYears(dur);\n@public\n@export\n@platform"
      },
      "duration": {
        "!type": "fn(num: number|?, unit: string) -> ?",
        "!span": "9699[316:34]-9707[316:42]",
        "!doc": "Creates an object representing a length of time.\n@param {Number|Object} num The length of milliseconds/unit\n@param {String} unit The unit of measurement of time\n@return {Object} A duration object\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(1, 'day');\n// dur._days returns 1\n@public\n@export\n@platform"
      },
      "endOf": {
        "!type": "fn(date: ?, unit: string) -> +Date",
        "!span": "10415[335:34]-10420[335:39]",
        "!doc": "Converts the passed in Date by setting it to the end of a unit of time.\n@param {String|Number|Date} date A format that the JavaScript Date object can parse\n@param {String} unit The unit of time in year, month, week, day, hour, minute or second\n@return {Date} A JavaScript Date object\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\n// Returns the time at the end of the day\n// in the format \"Fri Oct 09 2015 23:59:59 GMT-0700 (PDT)\"\nvar day = $A.localizationService.endOf(d, 'day')\n@public\n@export\n@platform"
      },
      "formatDate": {
        "!type": "fn(date: ?, formatString: string, locale: string)",
        "!span": "11086[354:34]-11096[354:44]",
        "!doc": "Formats a date.\n@param {String|Number|Date} date The date format that the JavaScript Date object can parse.\n@param {String} formatString A Java format string. The default is from LocaleValueProvider.\n@param {String} locale A Java locale string. The default is from LocaleValueProvider.\n@return A formatted and localized date string\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\n// Returns date in the format \"Oct 9, 2015\"\n$A.localizationService.formatDate(d);\n@public\n@export\n@platform"
      },
      "formatDateUTC": {
        "!type": "fn(date: ?, formatString: string, locale: string)",
        "!span": "12067[382:34]-12080[382:47]",
        "!doc": "Formats a date in UTC.\n@param {String|Number|Date} date The date format that JS Date object can parse.\n@param {String} formatString A Java format string. The default is from LocaleValueProvider.\n@param {String} locale A Java locale string. The default is from LocaleValueProvider.\n@return A formatted and localized date string\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\n// Returns date in UTC in the format \"Oct 9, 2015\"\n$A.localizationService.formatDateUTC(d);\n@public\n@export\n@platform"
      },
      "formatDateTime": {
        "!type": "fn(date: ?, formatString: string, locale: string)",
        "!span": "13084[410:34]-13098[410:48]",
        "!doc": "Formats a datetime.\n@param {String|Number|Date} date The datetime format that the JavaScript Date object can parse.\n@param {String} formatString A Java format string. The default is from LocaleValueProvider.\n@param {String} locale A Java locale string. The default is from LocaleValueProvider.\n@return A formatted and localized datetime string\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\n// Returns datetime in the format \"Oct 9, 2015 9:00:00 AM\"\n$A.localizationService.formatDateTime(d);\n@public\n@export\n@platform"
      },
      "formatDateTimeUTC": {
        "!type": "fn(date: ?, formatString: string, locale: string)",
        "!span": "14084[437:34]-14101[437:51]",
        "!doc": "Formats a datetime in UTC.\n@param {String|Number|Date} date The datetime format that the JavaScript Date object can parse.\n@param {String} formatString A Java format string. The default is from LocaleValueProvider.\n@param {String} locale A Java locale string. The default is from LocaleValueProvider.\n@return A formatted and localized datetime string\n@example\nvar d = new Date();\n// Returns datetime in UTC in the format \"Oct 9, 2015 4:00:00 PM\"\n$A.localizationService.formatDateTimeUTC(d);\n@public\n@export\n@platform"
      },
      "formatTime": {
        "!type": "fn(date: ?, formatString: string, locale: string)",
        "!span": "15089[465:34]-15099[465:44]",
        "!doc": "Formats a time.\n@param {String|Number|Date} date The time format that JavaScript Date object can parse\n@param {String} formatString A Java format string. The default is from LocaleValueProvider.\n@param {String} locale A Java locale string. The default is from LocaleValueProvider.\n@return A formatted and localized time string\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\n// Returns a date in the format \"9:00:00 AM\"\nvar now = $A.localizationService.formatTime(d);\n@public\n@export\n@platform"
      },
      "formatTimeUTC": {
        "!type": "fn(date: ?, formatString: string, locale: string)",
        "!span": "16077[493:34]-16090[493:47]",
        "!doc": "Formats a time in UTC.\n@param {String|Number|Date} date The time format that JavaScript Date object can parse.\n@param {String} formatString A Java format string. The default is from LocaleValueProvider.\n@param {String} locale A Java locale string. The default is from LocaleValueProvider.\n@return a formatted and localized time string\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\n// Returns time in UTC in the format \"4:00:00 PM\"\n$A.localizationService.formatTimeUTC(d);\n@public\n@export\n@platform"
      },
      "getDaysInDuration": {
        "!type": "fn(d: ?) -> number",
        "!span": "16928[519:34]-16945[519:51]",
        "!doc": "Gets the number of days in a duration.\n@param {Duration} d The duration object returned by this.duration\n@return {Number} The number of days in d.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(48, 'hour');\n// Returns 2, the number of days for the given duration\n$A.localizationService.getDaysInDuration(dur);\n@public\n@export\n@platform"
      },
      "getHoursInDuration": {
        "!type": "fn(d: ?) -> number",
        "!span": "17444[536:34]-17462[536:52]",
        "!doc": "Gets the number of hours in a duration.\n@param {Duration} d The duration object returned by this.duration\n@return {Number} The number of hours in d.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(60, 'minute');\n// Returns 1, the number of hours in the given duration\n$A.localizationService.getHoursInDuration(dur);\n@public\n@export\n@platform"
      },
      "getLocalizedDateTimeLabels": {
        "!type": "fn() -> ?",
        "!span": "17743[548:34]-17769[548:60]",
        "!doc": "Get the date time related labels (month name, weekday name, am/pm etc.).\n@return {Object} the localized label set.\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "getToday": {
        "!type": "fn(timezone: string, callback: +Function) -> string",
        "!span": "18353[564:34]-18361[564:42]",
        "!doc": "Get the today's date based on a time zone.\n@param {String} timezone A time zone id based on the java.util.TimeZone class, for example, America/Los_Angeles\n@param {Function} callback A function to be called after the \"today\" value is obtained\n@return {String} the ISO8601 date string (yyyy-MM-dd).\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "getDateStringBasedOnTimezone": {
        "!type": "fn(timezone: string, dateObj: +Date, callback: +Function) -> string",
        "!span": "19194[587:34]-19222[587:62]",
        "!doc": "Get the date's date string based on a time zone.\n@param {String} timezone A time zone id based on the java.util.TimeZone class, for example, America/Los_Angeles\n@param {Date} dateObj a date object\n@param {Function} callback A function to be called after the \"today\" value is obtained\n@return {String} the ISO8601 date string (yyyy-MM-dd).\n@memberOf AuraLocalizationService\n@example\nvar timezone = $A.get(\"$Locale.timezone\");\nvar d = new Date();\n// Returns the date string in the format \"2015-10-9\"\n$A.localizationService.getDateStringBasedOnTimezone(timezone, d, function(today){\n   console.log(today);\n});\n@public\n@export\n@platform"
      },
      "getMillisecondsInDuration": {
        "!type": "fn(d: ?) -> number",
        "!span": "19884[606:34]-19909[606:59]",
        "!doc": "Gets the number of milliseconds in a duration.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The number of milliseconds in d.\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "getMinutesInDuration": {
        "!type": "fn(d: ?) -> number",
        "!span": "20439[623:34]-20459[623:54]",
        "!doc": "Gets the number of minutes in a duration.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The number of minutes in d.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(60, 'second');\n// Returns 1, the number of minutes in the given duration\n$A.localizationService.getMinutesInDuration(dur);\n@public\n@export\n@platform"
      },
      "getMonthsInDuration": {
        "!type": "fn(d: ?) -> number",
        "!span": "20962[640:34]-20981[640:53]",
        "!doc": "Gets the number of months in a duration.\n@param thisration object returned by localizationService.duration\n@return {Number} The number of months in d.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(70, 'day');\n// Returns 2, the number of months in the given duration\n$A.localizationService.getMonthsInDuration(dur);\n@public\n@export\n@platform"
      },
      "getSecondsInDuration": {
        "!type": "fn(d: ?) -> number",
        "!span": "21467[657:34]-21487[657:54]",
        "!doc": "Gets the number of seconds in a duration.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The number of seconds in d.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(3000, 'millisecond');\n// Returns 3\n$A.localizationService.getSecondsInDuration(dur);\n@public\n@export\n@platform"
      },
      "getYearsInDuration": {
        "!type": "fn(d: ?) -> number",
        "!span": "21960[674:34]-21978[674:52]",
        "!doc": "Gets the number of years in a duration.\n@param {Duration} d The duration object returned by localizationService.duration\n@return {Number} The number of years in d.\n@memberOf AuraLocalizationService\n@example\nvar dur = $A.localizationService.duration(24, 'month');\n// Returns 2\n$A.localizationService.getYearsInDuration(dur);\n@public\n@export\n@platform"
      },
      "isPeriodTimeView": {
        "!type": "fn(pattern: ?) -> bool",
        "!span": "22465[691:34]-22481[691:50]",
        "!doc": "An utility function to check if a datetime pattern string uses a 24-hour or period (12 hour with am/pm) time view.\n@param {String} datetime pattern string\n@return {Boolean} Returns true if it uses period time view.\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\n// Returns false\n$A.localizationService.isPeriodTimeView(d);\n@public\n@export\n@platform"
      },
      "isAfter": {
        "!type": "fn(date1: ?, date2: ?, unit: string) -> bool",
        "!span": "23701[727:34]-23708[727:41]",
        "!doc": "Checks if date1 is after date2.\n@param {String|Number|Date} date1 A date format that the JavaScript Date object can parse\n@param {String|Number|Date} date2 A date format that the JavaScript Date object can parse\n@param {String} unit The unit to limit the granularity, that is, year, month, week, day, hour, minute and second.\n                By default, millisecond is used.\n@return {Boolean} Returns true if date1 is after date2, or false otherwise.\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\nvar day = $A.localizationService.endOf(d, 'day');\n// Returns false, since d is before day\n$A.localizationService.isAfter(d, day);\n@public\n@export\n@platform"
      },
      "isBefore": {
        "!type": "fn(date1: ?, date2: ?, unit: string) -> bool",
        "!span": "24555[748:34]-24563[748:42]",
        "!doc": "Checks if date1 is before date2.\n@param {String|Number|Date} date1 A date format that the JavaScript Date object can parse\n@param {String|Number|Date} date2 A date format that the JavaScript Date object can parse\n@param {String} unit The unit to limit the granularity, that is, year, month, week, day, hour, minute and second.\n                By default, millisecond is used.\n@return {Boolean} Returns true if date1 is before date2, or false otherwise.\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\nvar day = $A.localizationService.endOf(d, 'day');\n// Returns true, since d is before day\n$A.localizationService.isBefore(d, day);\n@public\n@export\n@platform"
      },
      "isSame": {
        "!type": "fn(date1: ?, date2: ?, unit: string) -> bool",
        "!span": "25473[771:34]-25479[771:40]",
        "!doc": "Checks if date1 is the same as date2.\n@param {String|Number|Date} date1 A date format that the JavaScript Date object can parse\n@param {String|Number|Date} date2 A date format that the JavaScript Date object can parse\n@param {String} unit The unit to limit the granularity, that is, year, month, week, day, hour, minute and second.\n                By default, millisecond is used.\n@return {Boolean} Returns true if date1 is the same as date2, or false otherwise.\n@memberOf AuraLocalizationService\n@example\nvar d = new date();\nvar day = $A.localizationService.endOf(d, 'day');\n// Returns false\n$A.localizationService.isSame(d, day, 'hour');\n// Returns true\n$A.localizationService.isSame(d, day, 'day');\n@public\n@export\n@platform"
      },
      "parseDateTime": {
        "!type": "fn(dateTimeString: string, targetFormat: string, locale: string, strictParsing: ?) -> +Date",
        "!span": "26168[787:34]-26181[787:47]",
        "!doc": "Parses a string to a JavaScript Date.\n@param {String} dateTimeString The datetime string to be parsed.\n@param {String} targetFormat A Java format string which is used to parse datetime. The default is from LocaleValueProvider.\n@param {String} locale A Java locale string used to parse datetime. The default is from LocaleValueProvider.\n@param {Boolean} set to true to turn off moment's forgiving parsing and use strict validation\n@return {Date} A JavaScript Date object\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "parseDateTimeISO8601": {
        "!type": "fn(dateTimeString: string) -> +Date",
        "!span": "26992[809:34]-27012[809:54]",
        "!doc": "Parses a date time string in an ISO-8601 format.\n@param {String} dateTimeString The datetime string in an ISO-8601 format\n@return {Date} A JavaScript Date object\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "parseDateTimeUTC": {
        "!type": "fn(dateTimeString: string, targetFormat: string, locale: string, strictParsing: ?) -> +Date",
        "!span": "27984[837:34]-28000[837:50]",
        "!doc": "Parses a string to a JavaScript Date in UTC.\n@param {String} dateTimeString The datetime string to be parsed\n@param {String} targetFormat A Java format string which is used to parse datetime. The default is from LocaleValueProvider.\n@param {String} locale A Java locale string used to parse datetime. The default is from LocaleValueProvider.\n@param {Boolean} set to true to turn off moment's forgiving parsing and use strict validation\n@return {Date} A JavaScript Date object\n@memberOf AuraLocalizationService\n@example\nvar d = \"2015-10-9\";\n// Returns \"Thu Oct 08 2015 17:00:00 GMT-0700 (PDT)\"\n$A.localizationService.parseDateTimeUTC(d);\n@public\n@export\n@platform"
      },
      "startOf": {
        "!type": "fn(date: ?, unit: string) -> +Date",
        "!span": "29066[865:34]-29073[865:41]",
        "!doc": "Converts the passed in Date by setting it to the start of a unit of time.\n@param {String|Number|Date} date It could be anything that JS Date object can parse.\n@param {String} unit Year, month, week, day, hour, minute or second\n@return {Date} A JavaScript Date object\n@memberOf AuraLocalizationService\n@example\nvar d = \"2015-10-9\";\n// Returns \"Thu Oct 01 2015 00:00:00 GMT-0700 (PDT)\"\n$A.localizationService.startOf(d, 'month');\n@public\n@export\n@platform"
      },
      "toISOString": {
        "!type": "fn(date: +Date) -> !0",
        "!span": "29607[882:34]-29618[882:45]",
        "!doc": "Most of modern browsers support this method on Date object. But that is not the case for IE8 and older.\n@param {Date} date a Date object\n@return {String} An ISO8601 string to represent passed in Date object.\n@memberOf AuraLocalizationService\n@example\nvar d = new Date();\n// Returns \"2015-10-09T20:47:17.590Z\"\n$A.localizationService.toISOString(d);\n@public\n@export\n@platform"
      },
      "translateFromLocalizedDigits": {
        "!type": "fn(input: string) -> !0",
        "!span": "30522[909:34]-30550[909:62]",
        "!doc": "Translate the localized digit string to a string with Arabic digits if there is any.\n@param {String} input a string with localized digits.\n@return {String} a string with Arabic digits.\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "translateFromOtherCalendar": {
        "!type": "fn(date: +Date) -> !0",
        "!span": "31506[940:34]-31532[940:60]",
        "!doc": "Translate the input date from other calendar system (for example, Buddhist calendar) to Gregorian calendar\nbased on the locale.\n@param {Date} date a Date Object.\n@return {Date} an updated Date object.\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "translateToLocalizedDigits": {
        "!type": "fn(input: string) -> !0",
        "!span": "32162[958:34]-32188[958:60]",
        "!doc": "Translate the input string to a string with localized digits (different from Arabic) if there is any.\n@param {String} input a string with Arabic digits.\n@return {String} a string with localized digits.\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "translateToOtherCalendar": {
        "!type": "fn(date: +Date) -> !0",
        "!span": "33102[988:34]-33126[988:58]",
        "!doc": "Translate the input date to a date in other calendar system, for example, Buddhist calendar based on the locale.\n@param {Date} date a Date Object.\n@return {Date} an updated Date object.\n@memberOf AuraLocalizationService\n@public\n@export\n@platform"
      },
      "UTCToWallTime": {
        "!type": "fn(date: +Date, timezone: PropertyReferenceValue.lastResult|string, callback: fn(date: +Date))",
        "!span": "34345[1018:34]-34358[1018:47]",
        "!doc": "Converts a datetime from UTC to a specified timezone.\n@param {Date} date A JavaScript Date object\n@param {String} timezone A time zone id based on the java.util.TimeZone class, for example, America/Los_Angeles\n@param {Function} callback A function to be called after the conversion is done\n@memberOf AuraLocalizationService\n@example\n// Provides locale information\nvar format = $A.get(\"$Locale.timeFormat\");\nformat = format.replace(\":ss\", \"\");\nvar langLocale = $A.get(\"$Locale.langLocale\");\nvar timezone = $A.get(\"$Locale.timezone\");\nvar d = new Date();\n$A.localizationService.UTCToWallTime(d, timezone, function(walltime) {\n   // Returns the local time without the seconds, for example, 9:00 PM\n   displayValue = $A.localizationService.formatDateTimeUTC(walltime, format, langLocale);\n})\n@public\n@export\n@platform"
      },
      "WallTimeToUTC": {
        "!type": "fn(date: +Date, timezone: string, callback: +Function)",
        "!span": "35627[1055:34]-35640[1055:47]",
        "!doc": "Converts a datetime from a specified timezone to UTC.\n@param {Date} date A JavaScript Date object\n@param {String} timezone A time zone id based on the java.util.TimeZone class, for example, America/Los_Angeles\n@param {Function} callback A function to be called after the conversion is done\n@memberOf AuraLocalizationService\n@example\n$A.localizationService.WallTimeToUTC(d, timezone, function(walltime) {\n    displayDate = $A.localizationService.formatDateTimeUTC(walltime, format, langLocale);\n})\n@public\n@export\n@platform"
      },
      "displayDateTime": {
        "!type": "fn(mDate: ?, format: PropertyReferenceValue.lastResult|string, locale: string)",
        "!span": "36473[1085:34]-36488[1085:49]",
        "!doc": "Display date, datetime or time based on the format string.\n\n@private"
      },
      "getNormalizedFormat": {
        "!type": "fn(format: PropertyReferenceValue.lastResult|string) -> !0",
        "!span": "36828[1097:34]-36847[1097:53]",
        "!doc": "Normalize a Java format string to make it compatible with moment.js\n\n@private"
      },
      "getStrictModeFormat": {
        "!type": "fn(format: string) -> !0",
        "!span": "37456[1118:34]-37475[1118:53]",
        "!doc": "Modifying the format so that moment's strict parsing doesn't break on minor deviations\n\n@private"
      },
      "getStrictModeDateTimeString": {
        "!type": "fn(dateTimeString: string) -> !0",
        "!span": "38493[1147:34]-38520[1147:61]",
        "!doc": "Modifying the date time string so that moment's strict parsing doesn't break on minor deviations\n\n\n@private"
      },
      "getNormalizedLangLocale": {
        "!type": "fn(langLocale: PropertyReferenceValue.lastResult|string) -> !0",
        "!span": "38810[1159:34]-38833[1159:57]",
        "!doc": "Normalize the input Java locale string to moment.js compatible one.\n\n@private"
      },
      "getTimeZoneInfo": {
        "!type": "fn(timezone: PropertyReferenceValue.lastResult|string, callback: fn())",
        "!span": "39954[1201:34]-39969[1201:49]",
        "!doc": "retrieve timezone info from server.\n\n@private"
      },
      "getUTCFromWallTime": {
        "!type": "fn(d: ?, timezone: PropertyReferenceValue.lastResult) -> !0",
        "!span": "40883[1228:34]-40901[1228:52]",
        "!doc": "@private"
      },
      "getWallTimeFromUTC": {
        "!type": "fn(d: +Date, timezone: PropertyReferenceValue.lastResult|string) -> !0",
        "!span": "41497[1249:34]-41515[1249:52]",
        "!doc": "@private"
      },
      "init": {
        "!type": "fn()",
        "!span": "42155[1271:34]-42159[1271:38]",
        "!doc": "Initialize localization service.\n@private"
      },
      "pad": {
        "!type": "fn(n: number) -> !0",
        "!span": "42549[1283:34]-42552[1283:37]",
        "!doc": "Append zero in front if necessary to standardize a number with two digits. For example, \"9\" becomes \"09\".\n@private"
      },
      "doublePad": {
        "!type": "fn(n: number) -> !0",
        "!span": "42773[1291:34]-42782[1291:43]",
        "!doc": "Append zero in front if necessary to standardize a number with three digits. For example, \"99\" becomes \"099\".\n@private"
      }
    },
    "!type": "fn()",
    "!span": "894[23:9]-917[23:32]",
    "!doc": "@description The Aura Localization service Service, accessible using $A.localizationService. Provides utility methods\nfor localizing data or getting formatters for numbers, currencies, dates, etc.\n@constructor\n@export\n@platform",
    "numberFormat": {
      "!type": "+Aura.Utils.NumberFormat",
      "!span": "931[24:9]-943[24:21]"
    },
    "ZERO": {
      "!type": "string",
      "!span": "1129[29:9]-1133[29:13]",
      "!doc": "moment.js and walltime-js must be loaded before we can use date/time related APIs"
    },
    "cache": {
      "format": {
        "<i>": {
          "!type": "string",
          "!span": "37200[1106:30]-37206[1106:36]"
        },
        "!span": "1169[32:8]-1175[32:14]"
      },
      "strictModeFormat": {
        "<i>": {
          "!type": "string",
          "!span": "38199[1132:44]-38205[1132:50]"
        },
        "!span": "1190[33:8]-1206[33:24]"
      },
      "langLocale": {
        "<i>": {
          "!type": "string",
          "!span": "39783[1191:30]-39793[1191:40]"
        },
        "!span": "1221[34:8]-1231[34:18]"
      },
      "!span": "1151[31:9]-1156[31:14]"
    }
  },
  "AuraRenderingService": {
    "prototype": {
      "render": {
        "!type": "fn(components: ?, parent: ?) -> [+Node]",
        "!span": "1730[47:31]-1736[47:37]",
        "!doc": "Renders a component by calling its renderer.\n\n@param {Component}\n           components The component or component array to be rendered\n@param {Component}\n           parent Optional. The component's parent\n@memberOf AuraRenderingService\n@public\n@export"
      },
      "rerender": {
        "!type": "fn(components: ?) -> [?]",
        "!span": "3664[104:31]-3672[104:39]",
        "!doc": "The default rerenderer for components affected by an event. Call\nsuperRerender() from your customized function to chain the\nrerendering to the components in the body attribute.\n\n@param {Component}\n           components The component or component array to be rerendered\n@memberOf AuraRenderingService\n@public\n@export"
      },
      "afterRender": {
        "!type": "fn(components: ?)",
        "!span": "6293[183:31]-6304[183:42]",
        "!doc": "The default behavior after a component is rendered.\n\n@param {component}\n           components The component or component array that has finished rendering\n@memberOf AuraRenderingService\n@public\n@export"
      },
      "unrender": {
        "!type": "fn(components: ?)",
        "!span": "8098[233:31]-8106[233:39]",
        "!doc": "The default unrenderer that deletes all the DOM nodes rendered by a\ncomponent's render() function. Call superUnrender() from your\ncustomized function to modify the default behavior.\n\n@param {Component}\n           components The component or component array to be unrendered\n@memberOf AuraRenderingService\n@public\n@export"
      },
      "storeFacetInfo": {
        "!type": "fn(component: ?, facet: [AuraRenderingService.prototype.storeFacetInfo.!0._facetInfo|?]|?)",
        "!span": "10024[292:31]-10038[292:45]",
        "!doc": "@private\n@memberOf AuraRenderingService\n\n@param {Component} component the component for which we are storing the facet.\n@param {Object} facet the component or array of components to store."
      },
      "getUpdatedFacetInfo": {
        "!type": "fn(component: AuraRenderingService.prototype.storeFacetInfo.!0, facet: [?]) -> AuraRenderingService.prototype.getUpdatedFacetInfo.!ret",
        "!span": "10661[309:31]-10680[309:50]",
        "!doc": "@private\n@memberOf AuraRenderingService"
      },
      "renderFacet": {
        "!type": "fn(component: ?, facet: AuraComponentContext.prototype.Frame.!0, parent: AuraComponentContext.prototype.Frame.!0) -> AuraRenderingService.prototype.renderFacet.!ret",
        "!span": "13337[376:31]-13348[376:42]",
        "!doc": "@public\n@param {Component} component the component for which we are rendering the facet.\n@param {Component} facet the facet to render.\n@param {Component} parent (optional) the parent for the facet.\n@export"
      },
      "rerenderFacet": {
        "!type": "fn(component: AuraRenderingService.prototype.storeFacetInfo.!0, facet: AuraComponentContext.prototype.Frame.!0, referenceNode: +Element) -> [?]",
        "!span": "13928[394:31]-13941[394:44]",
        "!doc": "@public\n@param {Component} component the component for which we are rendering the facet.\n@param {Component} facet the facet to render.\n@param {HTMLElement} referenceNode the reference node for insertion\n@export"
      },
      "unrenderFacet": {
        "!type": "fn(cmp: AuraComponentContext.prototype.Frame.!0, facet: AuraComponentContext.prototype.Frame.!0)",
        "!span": "19039[500:31]-19052[500:44]",
        "!doc": "@public\n@param {Component} cmp the component for which we are unrendering the facet.\n@param {Component} facet the facet to unrender.\n@export"
      },
      "getMarker": {
        "!type": "fn(cmp: AuraComponentContext.prototype.Frame.!0) -> !0",
        "!span": "19586[525:31]-19595[525:40]",
        "!doc": "Get a marker for a component.\n\n@public\n@param {Component} cmp the component for which we want a marker.\n@return the marker.\n@export"
      },
      "addDirtyValue": {
        "!type": "fn(expression: string, cmp: +Component)",
        "!span": "19791[534:31]-19804[534:44]",
        "!doc": "@protected\n@param expression the expression to mark as dirty.\n@param cmp the owning component."
      },
      "hasDirtyValue": {
        "!type": "fn(cmp: ?) -> bool",
        "!span": "20535[558:31]-20548[558:44]",
        "!doc": "Does a component have a dirty value?.\n\nOnly used by component to figure out if it is dirty... Maybe we should move this to component?\n\n@protected\n@param cmp the component to check."
      },
      "isDirtyValue": {
        "!type": "fn(expression: ?, cmp: ?) -> bool",
        "!span": "20689[565:31]-20701[565:43]",
        "!doc": "@protected"
      },
      "rerenderDirty": {
        "!type": "fn(stackName: ?)",
        "!span": "21112[584:31]-21125[584:44]",
        "!doc": "Rerender all dirty components.\n\nCalled from ClientService when we reach the top of stack.\n\n@protected\n@export"
      },
      "removeDirtyValue": {
        "!type": "fn(value: ?, cmp: +Component) -> [string]",
        "!span": "24799[674:31]-24815[674:47]",
        "!doc": "@deprecated\n@protected"
      },
      "statsIndex": {
        "afterRender": {
          "!type": "[AuraRenderingService.prototype.statsIndex.afterRender.<i>]",
          "!span": "25563[697:4]-25576[697:17]"
        },
        "render": {
          "!type": "[AuraRenderingService.prototype.statsIndex.render.<i>]",
          "!span": "25586[698:4]-25594[698:12]"
        },
        "rerender": {
          "!type": "[AuraRenderingService.prototype.statsIndex.rerender.<i>]",
          "!span": "25604[699:4]-25614[699:14]"
        },
        "rerenderDirty": {
          "!type": "[AuraRenderingService.prototype.statsIndex.rerenderDirty.<i>]",
          "!span": "25624[700:4]-25639[700:19]"
        },
        "unrender": {
          "!type": "[AuraRenderingService.prototype.statsIndex.unrender.<i>]",
          "!span": "25649[701:4]-25659[701:14]"
        },
        "!span": "25544[696:31]-25554[696:41]",
        "!doc": "#if {\"modes\" : [\"PTEST\",\"STATS\"]}"
      },
      "cleanComponent": {
        "!type": "fn(id: string)",
        "!span": "25708[705:31]-25722[705:45]",
        "!doc": "#end"
      },
      "getArray": {
        "!type": "fn(things: ?) -> [?]",
        "!span": "25898[714:31]-25906[714:39]",
        "!doc": "@private\n@param things either an array or an item.\n@return an array."
      },
      "evalStrings": {
        "!type": "fn(elements: [?]) -> [?]",
        "!span": "26292[729:31]-26303[729:42]",
        "!doc": "If a renderer returned a string, create html elements from that string.\n\nReturns an elements array, either the original one passed in or a new one\nif \"elements\" passed in was a string, not an array.\n\n@private"
      },
      "finishRender": {
        "!type": "fn(cmp: ?, elements: [?]) -> !1",
        "!span": "26494[736:31]-26506[736:43]"
      },
      "insertElements": {
        "!type": "fn(elements: [+Node], refNode: ?, asSibling: +Element, asFirst: +Element)",
        "!span": "26868[753:31]-26882[753:45]",
        "!doc": "Insert elements to the DOM, relative to a reference node,\nby default as its last child.\n\n@private"
      },
      "getFlavorClass": {
        "!type": "fn(cmp: +Component) -> string",
        "!span": "27505[775:31]-27519[775:45]",
        "!doc": "Calculates the flavor css class name for a component instance and element.\n@private"
      },
      "addAuraClass": {
        "!type": "fn(cmp: ?, element: ?)",
        "!span": "29298[814:31]-29310[814:43]"
      },
      "associateElements": {
        "!type": "fn(cmp: ?, elements: [+Node])",
        "!span": "30706[847:31]-30723[847:48]",
        "!doc": "Associate all of the elements with the component, and return a list of\npure elements - with no association objects wrapped around them.\n\n@private"
      },
      "createMarker": {
        "!type": "fn(target: +Node|+Node, reason: string) -> +Node",
        "!span": "31083[861:31]-31095[861:43]"
      },
      "isMarker": {
        "!type": "fn(node: ?) -> !0",
        "!span": "31315[870:31]-31323[870:39]"
      }
    },
    "!type": "fn()",
    "!span": "861[23:9]-881[23:29]",
    "!doc": "@class The Aura Rendering Service, accessible using $A.renderingService.\n       Renders components. The default behaviors can be customized in a\n       client-side renderer.\n@constructor\n@export",
    "visited": {
      "<i>": {
        "!type": "bool",
        "!span": "5397[148:24]-5399[148:26]"
      },
      "!span": "895[24:9]-902[24:16]",
      "!doc": "#end"
    },
    "afterRenderStack": {
      "!type": "[[?]|?]",
      "!span": "925[25:9]-941[25:25]"
    },
    "dirtyComponents": {
      "<i>": {
        "<i>": {
          "!type": "bool",
          "!span": "20185[544:17]-20195[544:27]"
        },
        "!span": "20060[540:40]-20062[540:42]"
      },
      "!span": "957[26:9]-972[26:24]"
    },
    "dirtyComponentIds": {
      "!type": "[?]",
      "!span": "1354[32:9]-1371[32:26]",
      "!doc": "KRIS: HALO: HACK:\nIE11 is not returning the Object.keys() for dirtyComponents in the order they were added.\nSo we rerender dirty out of order.\nThis array assures we rerender in the order that we add keys to the array.\nIdeally, we shouldn't care what order we rerender in, but that's a more difficult bug to track down in 194/patch"
    },
    "needsCleaning": {
      "!type": "bool",
      "!span": "1387[33:9]-1400[33:22]"
    },
    "_isDisconnected": {
      "!type": "bool",
      "!span": "9649[176:4146]-9664[176:4161]"
    },
    "lastSendTime": {
      "!type": "number",
      "!span": "68475[176:62972]-68487[176:62984]"
    },
    "state": {
      "!type": "string",
      "!span": "29416[176:23913]-29421[176:23918]"
    },
    "fired": {
      "!type": "bool",
      "!span": "8367[176:2864]-8372[176:2869]"
    }
  },
  "AuraStyleService": {
    "prototype": {
      "applyTokens": {
        "!type": "fn(descriptor: string, config?: ?)",
        "!span": "4333[83:27]-4344[83:38]",
        "!doc": "Loads CSS from the server with the given tokens applied.\n<p>\nThe current application's CSS is loaded from the server and only includes\noverrides for the CSS that reference tokens from the specified tokens def.\nThis CSS is then placed into a new style element and attached to the DOM.\n<p>\nIn addition to the application's CSS (as determined by the\napplication's dependency graph), this will also include any client\nloaded StyleDefs (i.e., any dynamically loaded components with\nstyles, that are not in the application's dependency graph). Client\nloaded StyleDefs will be appended after the standard application CSS.\nNote that this may not be adequate with certain usages of providers.\nSee the config options for more details.\n<p>\nExtra StyleDefs to load may be specified through the config object,\nwhich will be appended last.\n<p>\nMultiple calls to this method are cumulative, unless\n<code>config.replaceExisting</code> is specified as true.\n\n@public\n@memberOf AuraStyleService\n\n@param {string} descriptor\n         The TokensDef descriptor, e.g., <code>\"myNamespace:myTokens\"</code>.\n@param {Object=} config\n         The optional configuration object.\n@param {boolean} [config.replaceExisting=true]\n         Specify true to replace all previously applied styles, false to append.\n@param {string[]} [config.extraStyles]\n         Specify any extra StyleDef descriptors to include.\n@param {boolean} [config.storable=true]\n         Specify whether the server action is storable. If true, the results\n         may be retrieved from a cache when given the same parameters. You\n         may want to specify false if applying a <em>MapProvider</em> def.\n@param {function} [config.callback]\n         Callback function to invoke once the style element has been appended to the page.\n@param {function} [config.customHandler]\n         Callback function that will be invoked with the returned CSS. If this function is\n         specified, the CSS will not be automatically appended to the page as usual.\n         Certain other config options may no longer be applicable. If you place the styles\n         into the DOM, be aware that subsequent calls to this method that do not specify this\n         option may not properly override everything depending on where in the DOM you placed\n         the styles. Also note that the <code>replaceExisting</code> param will not handle\n         any styles you attach to the DOM manually.\n@param {boolean} [config.forceClientScan=false]\n         When false (the default), the server will automatically attempt to discover any client-loaded\n         StyleDefs (i.e., defs applied individually via server action). Specify true to force this\n         detection on the client and the data sent to the server manually instead. Note that this option\n         is less performant than the default, however it may be applicable when using providers (and the\n         provided defs cannot be determined from the server). The default option is sufficient to include\n         any defs loaded through the framework directly (e.g., via getComponent) and any inner/dependent\n         components from those.\n@export"
      },
      "applyAllTokens": {
        "!type": "fn(descriptors: [string], config?: ?)",
        "!span": "7906[144:27]-7920[144:41]",
        "!doc": "Loads CSS from the server with the given tokens applied.\n<p>\nThe current application's CSS is loaded from the server and only includes\noverrides for the CSS that reference tokens from the specified tokens defs.\nThis CSS is then placed into a new style element and attached to the DOM.\n<p>\nIn addition to the application's CSS (as determined by the\napplication's dependency graph), this will also include any client\nloaded StyleDefs (i.e., any dynamically loaded components with\nstyles, that are not in the application's dependency graph). Client\nloaded StyleDefs will be appended after the standard application CSS.\nNote that this may not be adequate with certain usages of providers.\nSee the config options for more details.\n<p>\nExtra StyleDefs to load may be specified through the config object,\nwhich will be appended last.\n<p>\nMultiple calls to this method are cumulative, unless\n<code>config.replaceExisting</code> is specified as true.\n\n@public\n@memberOf AuraStyleService\n\n@param {string[]} descriptors\n         The TokensDef descriptors, e.g., <code>[\"myNamespace:myTokens\", \"myNamespace:myTokens2\"]</code>.\n@param {Object=} config\n         The optional configuration object.\n@param {boolean} [config.replaceExisting=true]\n         Specify true to replace all previously applied styles, false to append.\n@param {string[]} [config.extraStyles]\n         Specify any extra StyleDef descriptors to include.\n@param {boolean} [config.storable=true]\n         Specify whether the server action is storable. If true, the results\n         may be retrieved from a cache when given the same parameters. You\n         may want to specify false if applying a <em>MapProvider</em> def.\n@param {function} [config.callback]\n         Callback function to invoke once the style element has been appended to the page.\n@param {function} [config.customHandler]\n         Callback function that will be invoked with the returned CSS. If this function is\n         specified, the CSS will not be automatically appended to the page as usual.\n         Certain other config options may no longer be applicable. If you place the styles\n         into the DOM, be aware that subsequent calls to this method that do not specify this\n         option may not properly override everything depending on where in the DOM you placed\n         the styles. Also note that the <code>replaceExisting</code> param will not handle\n         any styles you attach to the DOM manually.\n@param {boolean} [config.forceClientScan=false]\n         When false (the default), the server will automatically attempt to discover any client-loaded\n         StyleDefs (i.e., defs applied individually via server action). Specify true to force this\n         detection on the client and the data sent to the server manually instead. Note that this option\n         is less performant than the default, however it may be applicable when using providers (and the\n         provided defs cannot be determined from the server). The default option is sufficient to include\n         any defs loaded through the framework directly (e.g., via getComponent) and any inner/dependent\n         components from those.\n@export"
      },
      "removeTokens": {
        "!type": "fn()",
        "!span": "10794[224:27]-10806[224:39]",
        "!doc": "Removes all style elements previously added through this service.\n\n@public\n@memberOf AuraStyleService\n@export"
      }
    },
    "!type": "fn()",
    "!span": "833[22:9]-849[22:25]",
    "!doc": "@description The Aura Style Service, accessible using <b><code>$A.styleService</code></b>.\n             Dynamically loads and applies tokenized CSS.\n@constructor\n@export",
    "style": {
      "!type": "+Aura.Utils.Style",
      "!span": "863[23:9]-868[23:14]"
    },
    "added": {
      "!type": "[+Element]",
      "!span": "953[24:9]-958[24:14]"
    }
  },
  "Component": {
    "currentComponentId": {
      "!type": "number",
      "!span": "6406[180:10]-6424[180:28]"
    },
    "prototype": {
      "nextGlobalId": {
        "!type": "fn(localCreation: ?) -> string",
        "!span": "6451[182:20]-6463[182:32]"
      },
      "setupGlobalId": {
        "!type": "fn(globalId: string, localCreation: ?)",
        "!span": "7072[206:20]-7085[206:33]",
        "!doc": "The globally unique id of this component"
      },
      "getName": {
        "!type": "fn() -> !this.meta.name",
        "!span": "7438[222:20]-7445[222:27]",
        "!doc": "Gets the component class name.\n\n@export"
      },
      "getDef": {
        "!type": "fn() -> !this.componentDef",
        "!span": "7611[232:20]-7617[232:26]",
        "!doc": "Gets the ComponentDef Shorthand: <code>get(\"def\")</code>\n\n@public\n@export"
      },
      "index": {
        "!type": "fn(localId: ?, globalId: ?)",
        "!span": "8111[248:20]-8116[248:25]",
        "!doc": "Indexes the given <code>globalId</code> based on the given\n<code>localId</code>. Allows <code>cmp.find(localId)</code> to look up\nthe given <code>globalId</code>, look up the component, and return it.\n\n@param {String}\n           localId The id set using the aura:id attribute.\n@param {String}\n           globalId The globally unique id which is generated on pageload.\n@protected\n@export"
      },
      "deIndex": {
        "!type": "fn(localId: ?, globalId: ?)",
        "!span": "9102[280:20]-9109[280:27]",
        "!doc": "Removes data from the index. If both <code>globalId</code> and\n<code>localId</code> are provided, only the given pair is removed from the\nindex. If only <code>localId</code> is provided, every mapping for that\n<code>localId</code> is removed from the index.\n\nThis might be called after component destroy in some corner cases, be careful\nto check for destroy before accessing.\n\n@param {String}\n           localId The id set using the aura:id attribute.\n@param {String}\n           globalId The globally unique id which is generated on pageload.\n@protected\n@export"
      },
      "find": {
        "!type": "fn(name: ?) -> [+Component]|+Component",
        "!span": "10516[321:20]-10520[321:24]",
        "!doc": "Locates a component using the localId. Shorthand: <code>get(\"asdf\")</code>,\nwhere \"asdf\" is the <code>aura:id</code> of the component to look for. See\n<a href=\"#help?topic=findById\">Finding Components by ID</a> for more\ninformation. Returns instances of a component using the format\n<code>cmp.find({ instancesOf : \"auradocs:sampleComponent\" })</code>.\n\n@param {String|Object}\n           name If name is an object, return instances of it. Otherwise,\n           finds a component using its index.\n@public\n@platform\n@export"
      },
      "findInstancesOf": {
        "!type": "fn(type: ?, ret: [+Component], cmp: +Component)",
        "!span": "11603[357:20]-11618[357:35]",
        "!doc": "Find instances of a Component type, in this component's hierarchy, and in\nits body, recursively.\n\n@param {Object}\n           type The object type.\n@param {Array}\n           ret The array of instances to add the located Components to.\n@param {Object}\n           cmp The component to search for.\n@private"
      },
      "getSuperest": {
        "!type": "fn() -> !this",
        "!span": "12489[388:20]-12500[388:31]",
        "!doc": "@private"
      },
      "findInstanceOf": {
        "!type": "fn(type: ?) -> !this",
        "!span": "12734[401:20]-12748[401:34]",
        "!doc": "@private"
      },
      "isInstanceOf": {
        "!type": "fn(name: string) -> bool",
        "!span": "13508[426:20]-13520[426:32]",
        "!doc": "Checks whether the component is an instance of the given component name (or\ninterface name).\n\n@param {String}\n           name The name of the component (or interface), with a format of\n           <code>namespace:componentName</code>.\n@returns {Boolean} true if the component is an instance, or false otherwise.\n@platform\n@export"
      },
      "implementsDirectly": {
        "!type": "fn(type: ?)",
        "!span": "13707[435:20]-13725[435:38]",
        "!doc": "@param {Object}\n           type Applies the type to its definition.\n@private"
      },
      "addHandler": {
        "!type": "fn(eventName: ?, valueProvider: +Component|Component.prototype.addHandler.!1, actionExpression: +PropertyReferenceValue|AuraInstance.context.contextGlobals, insert: ?)",
        "!span": "14659[461:20]-14669[461:30]",
        "!doc": "Adds an event handler. Resolving the handler Action happens at Event-handling\ntime, so the Action reference may be altered at runtime, and that change is\nreflected in the handler. See <a\nhref=\"#help?topic=dynamicHandler\">Dynamically Adding Event Handlers</a> for\nmore information.\n\n@param {String}\n           eventName The event name\n@param {Object}\n           valueProvider The value provider to use for resolving the\n           actionExpression.\n@param {Object}\n           actionExpression The expression to use for resolving the handler\n           Action against the given valueProvider.\n@param {boolean}\n           insert The flag to indicate if we should put the handler at the\n           beginning instead of the end of handlers array.\n@public\n@export\n@platform"
      },
      "addValueHandler": {
        "!type": "fn(config: Component.prototype.addValueHandler.!0)",
        "!span": "15379[487:20]-15394[487:35]",
        "!doc": "Adds handlers to Values owned by the Component.\n\n@param {Object}\n           config Passes in the value, event (e.g. \"change\"), and action\n           (e.g. \"c.myAction\").\n@public\n@export\n@platform"
      },
      "removeValueHandler": {
        "!type": "fn(config: ?)",
        "!span": "16677[524:20]-16695[524:38]",
        "!doc": "@export"
      },
      "addDocumentLevelHandler": {
        "!type": "fn(eventName: ?, callback: ?, autoEnable: ?) -> ?",
        "!span": "18086[561:20]-18109[561:43]",
        "!doc": "Add a document level event handler that auto-cleans.\n\nWhen called, this will create and return a handler that can be enabled and\ndisabled at will, and will be cleaned up on destroy.\n\n@public\n@param {String}\n           eventName the event name to attach.\n@param {Function}\n           callback the callback (only called when enabled, and component is\n           valid & rendered)\n@param {Boolean}\n           autoEnable (truthy) enable the handler when created.\n@return {Object} an object with a single visible call of setEnabled(Boolean)\n@export"
      },
      "removeDocumentLevelHandler": {
        "!type": "fn(dlh: ?)",
        "!span": "18775[583:20]-18801[583:46]",
        "!doc": "Remove a document level handler.\n\nYou need only call this if the document level handler should be destroyed, it\nis not generally needed.\n\n@public\n@param {Object}\n           the object returned by addDocumentHandler.\n@export"
      },
      "finishDestroy": {
        "!type": "fn()",
        "!span": "19038[593:20]-19051[593:33]",
        "!doc": "Forces the final destroy of a component (after async)."
      },
      "destroy": {
        "!type": "fn(async: bool) -> !this.globalId",
        "!span": "20118[622:20]-20125[622:27]",
        "!doc": "Destroys the component and cleans up memory.\n\n<code>destroy()</code> destroys the component immediately while\n<code>destroy(true)</code> destroys it asynchronously. See <a\nhref=\"#help?topic=dynamicCmp\"/>Dynamically Creating Components</a> for more\ninformation.\n<p>\nNote that when this is called with async = true, it makes a specific race\ncondition (i.e. calling functions after destroy) harder to trigger. this\nmeans that we really would like to be able to for synchronous behaviour here,\nor do something to make the destroy function appear much more like it is\ndoing a synchronous destroy. Unfortunately, the act\nof doing an asynchronous destroy creates false 'races' because it leaves all\nof the events wired up.\n</p>\n\n@param {Boolean}\n           async Set to true if component should be destroyed asynchronously.\n           The default value is false.\n@public\n@platform\n@export"
      },
      "isRenderedAndValid": {
        "!type": "fn() -> !this.rendered",
        "!span": "25068[788:20]-25086[788:38]",
        "!doc": "Returns true if this component has been rendered and valid.\n\n@protected"
      },
      "superRender": {
        "!type": "fn()",
        "!span": "25286[799:20]-25297[799:31]",
        "!doc": "Execute the super components render method.\n@protected\n@export\n@platform"
      },
      "superAfterRender": {
        "!type": "fn()",
        "!span": "25520[811:20]-25536[811:36]",
        "!doc": "Execute the super components afterRender method.\n@protected\n@export\n@platform"
      },
      "superRerender": {
        "!type": "fn()",
        "!span": "25754[823:20]-25767[823:33]",
        "!doc": "Execute the super components rerender method.\n@protected\n@export\n@platform"
      },
      "superUnrender": {
        "!type": "fn()",
        "!span": "25994[835:20]-26007[835:33]",
        "!doc": "Execute the super components superUnrender method.\n@protected\n@export\n@platform"
      },
      "isRendered": {
        "!type": "fn() -> !this.rendered",
        "!span": "26308[849:20]-26318[849:30]",
        "!doc": "Returns true if this component has been rendered but not unrendered (does not\nnecessarily mean component is in the dom tree).\n\n@protected\n@platform\n@export"
      },
      "setUnrendering": {
        "!type": "fn(unrendering: bool)",
        "!span": "26539[859:20]-26553[859:34]",
        "!doc": "Returns true if this component has been rendered but not unrendered (does not\nnecessarily mean component is in the dom tree).\n\n@private"
      },
      "isUnrendering": {
        "!type": "fn() -> !this.inUnrender",
        "!span": "26794[869:20]-26807[869:33]",
        "!doc": "Returns true if this component has been rendered but not unrendered (does not\nnecessarily mean component is in the dom tree).\n\n@private"
      },
      "setRendered": {
        "!type": "fn(rendered: bool)",
        "!span": "27028[880:20]-27039[880:31]",
        "!doc": "Sets the rendered flag.\n\n@param {Boolean}\n           rendered Set to true if component is rendered, or false otherwise.\n@protected"
      },
      "getRenderer": {
        "!type": "fn() -> !this.renderer",
        "!span": "27206[890:20]-27217[890:31]",
        "!doc": "Returns the renderer instance for this component.\n\n@protected\n@export"
      },
      "getRenderable": {
        "!type": "fn() -> !this.renderer.renderable",
        "!span": "27374[899:20]-27387[899:33]",
        "!doc": "Returns the renderable instance for this component.\n@protected\n@export"
      },
      "getGlobalId": {
        "!type": "fn() -> !this.concreteComponentId",
        "!span": "27679[912:20]-27690[912:31]",
        "!doc": "Gets the globalId. This is the generated globally unique id of the component.\nIt can be used to locate the instance later, but will change across\npageloads.\n\n@public\n@platform\n@export"
      },
      "getLocalId": {
        "!type": "fn() -> !this.localId",
        "!span": "27968[924:20]-27978[924:30]",
        "!doc": "Get the id set using the <code>aura:id</code> attribute. Can be passed into\n<code>find()</code> on the parent to locate this child.\n\n@public\n@platform\n@export"
      },
      "getRendering": {
        "!type": "fn() -> !this.rendering",
        "!span": "28144[934:20]-28156[934:32]",
        "!doc": "If the server provided a rendering of this component, return it.\n\n@public\n@export"
      },
      "getSuper": {
        "!type": "fn() -> !this.superComponent",
        "!span": "28445[951:20]-28453[951:28]",
        "!doc": "Returns the super component.\n\n@protected\n@platform\n@export"
      },
      "associateElement": {
        "!type": "fn(element: ?)",
        "!span": "28842[966:20]-28858[966:36]",
        "!doc": "Associates a rendered element with the component that rendered it for later\nlookup. Also adds the rendering component's global Id as an attribute to the\nrendered element. Primarily called by RenderingService.\n\n@param {Object}\n           config\n@protected\n@export"
      },
      "disassociateElements": {
        "!type": "fn()",
        "!span": "29378[989:20]-29398[989:40]",
        "!doc": "Disassociates a rendered element with the component that rendered it for later\nlookup.\n\n@param {Object}\n           config\n@protected\n@export"
      },
      "getElements": {
        "!type": "fn() -> [?]",
        "!span": "29771[1007:20]-29782[1007:31]",
        "!doc": "Returns a map of the elements previously rendered by this component.\n\n@public\n@platform\n@export"
      },
      "getElement": {
        "!type": "fn()",
        "!span": "30192[1024:20]-30202[1024:30]",
        "!doc": "If the component only rendered a single element, return it. Otherwise, you\nshould use <code>getElements()</code>.\n\n@public\n@platform\n@export"
      },
      "getReference": {
        "!type": "fn(key: ?) -> !this.references.<i>",
        "!span": "30700[1046:20]-30712[1046:32]",
        "!doc": "Returns a live reference to the value indicated using property syntax.\n\n@param {String}\n           key The data key for which to return a reference.\n@return {PropertyReferenceValue}\n@public\n@platform\n@export"
      },
      "clearReference": {
        "!type": "fn(key: ?)",
        "!span": "31158[1063:20]-31172[1063:34]",
        "!doc": "Clears a live reference to the value indicated using property syntax.\n\n@param {String}\n           key The data key for which to clear the reference.\n@public\n@platform\n@export"
      },
      "get": {
        "!type": "fn(key: ?) -> Component.valueProviders.<i>",
        "!span": "32052[1086:20]-32055[1086:23]",
        "!doc": "Returns the value referenced using property syntax.\n\n@param {String}\n           key The data key to look up on the Component.\n@public\n@platform\n@export"
      },
      "getShadowAttribute": {
        "!type": "fn(key: string) -> string",
        "!span": "32919[1113:20]-32937[1113:38]",
        "!doc": "Returns a shadow value. Used for programmatically adding values after FCVs.\nTHIS IS NOT FOR YOU. DO NOT USE.\n\n@param {String}\n           key The data key to look up on the Component.\n@private"
      },
      "set": {
        "!type": "fn(key: string, value: string, ignoreChanges: ?)",
        "!span": "33387[1133:20]-33390[1133:23]",
        "!doc": "Sets the value referenced using property syntax.\n\n@param {String}\n           key The data key to set on the Component. E.g.\n           <code>cmp.set(\"v.key\",\"value\")</code>\n@param {Object}\n           value The value to set\n\n@public\n@platform\n@export"
      },
      "setShadowAttribute": {
        "!type": "fn(key: string, value: string)",
        "!span": "34918[1176:20]-34936[1176:38]",
        "!doc": "Sets a shadow attribute. Used for programmatically adding values after FCVs.\nTHIS IS NOT FOR YOU. DO NOT USE.\n\n@param {String}\n           key The data key to set on the Component.\n@private"
      },
      "markDirty": {
        "!type": "fn(reason: ?)",
        "!span": "35377[1193:20]-35386[1193:29]",
        "!doc": "@export"
      },
      "markClean": {
        "!type": "fn(value: ?)",
        "!span": "35525[1200:20]-35534[1200:29]",
        "!doc": "@export"
      },
      "fireChangeEvent": {
        "!type": "fn(key: string, oldValue: AuraInstance.context.contextGlobals|Component.valueProviders.<i>, newValue: Component.valueProviders.<i>|string, index: string)",
        "!span": "35632[1204:20]-35647[1204:35]"
      },
      "autoDestroy": {
        "!type": "fn(destroy: bool) -> !this.shouldAutoDestroy",
        "!span": "37395[1247:20]-37406[1247:31]",
        "!doc": "Sets a flag to tell the rendering service whether or not to destroy this component when it is removed\nfrom it's rendering facet. Set to false if you plan to keep a reference to a component after it has\nbeen unrendered or removed from a parent facet. Default is true: destroy once orphaned.\n@param {Boolean} destroy The flag to specify whether or not to destroy this component automatically.\n\n@public\n@platform\n@export"
      },
      "getConcreteComponent": {
        "!type": "fn() -> !this",
        "!span": "37856[1264:20]-37876[1264:40]",
        "!doc": "Gets the concrete implementation of a component. If the component is\nconcrete, the method returns the component itself. For example, call this\nmethod to get the concrete component of a super component.\n\n@public\n@platform\n@export"
      },
      "isConcrete": {
        "!type": "fn() -> bool",
        "!span": "38124[1275:20]-38134[1275:30]",
        "!doc": "Returns true if the component is concrete, or false otherwise.\n\n@public\n@platform\n@export"
      },
      "getAttributeValueProvider": {
        "!type": "fn() -> !this.attributeValueProvider",
        "!span": "38311[1286:20]-38336[1286:45]",
        "!doc": "Returns the value provider.\n\n@return {Object} value provider\n@public\n@export"
      },
      "setAttributeValueProvider": {
        "!type": "fn(avp: ?)",
        "!span": "38441[1293:20]-38466[1293:45]",
        "!doc": "@export"
      },
      "getComponentValueProvider": {
        "!type": "fn() -> !this.attributeValueProvider",
        "!span": "38678[1304:20]-38703[1304:45]",
        "!doc": "Returns the value provider of the component.\n\n@return {Object} component or value provider\n@public\n@export"
      },
      "getOwner": {
        "!type": "fn() -> !this.owner",
        "!span": "39252[1320:20]-39260[1320:28]",
        "!doc": "Returns the owner of the component. This should represent the lexical scope for markup components, and the\ncomponent calling the create method for dynamic components.\n\n@return {Object} Owning component\n@public\n@export"
      },
      "addValueProvider": {
        "!type": "fn(key: string, valueProvider: Component.valueProviders.<i>)",
        "!span": "39727[1335:20]-39743[1335:36]",
        "!doc": "Adds Custom ValueProviders to a component\n@param {String} key string by which to identify the valueProvider. Used in expressions in markup, etc.\n@param {Object} valueProvider the object to request data from. Must implement .get(expression), can implement .set(key,value).\n@public\n@platform\n@export"
      },
      "removeValueProvider": {
        "!type": "fn(key: string)",
        "!span": "40387[1347:20]-40406[1347:39]",
        "!doc": "Removes a custom value provider from a component\n@param {String} key string by which to identify the valueProvider to remove.\n@public"
      },
      "getModel": {
        "!type": "fn() -> !this.model",
        "!span": "40913[1360:20]-40921[1360:28]",
        "!doc": "Returns the model for this instance, if one exists. Shorthand :\n<code>get(\"m\")</code>\n\n@public\n@export"
      },
      "getEvent": {
        "!type": "fn(name: string) -> +Aura.Event.Event",
        "!span": "41227[1374:20]-41235[1374:28]",
        "!doc": "Return a new Event instance of the named component event. Shorthand:\n<code>get(\"e.foo\")</code>, where e is the name of the event.\n\n@param {String}\n           name The name of the Event.\n@public\n@platform\n@export"
      },
      "getEventByDescriptor": {
        "!type": "fn(descriptor: ?) -> string",
        "!span": "42369[1411:20]-42389[1411:40]",
        "!doc": "Get an event by descriptor qualified name.\n\nThis is only used by action for firing of component events. It is a bit of a\nhack (reversing the map).\n\n@param {String}\n           descriptor a descriptor qualified name.\n@return {String} null, or the component event.\n@protected"
      },
      "fire": {
        "!type": "fn(name: string)",
        "!span": "42610[1422:20]-42614[1422:24]",
        "!doc": "@private"
      },
      "isDirty": {
        "!type": "fn(expression: ?) -> bool",
        "!span": "43393[1451:20]-43400[1451:27]",
        "!doc": "Looks up the specified value and checks if it is currently dirty.\n\n@returns true if the value is dirty, and false if it is clean or does not\n         exist.\n@public\n@deprecated TEMPORARY WORKAROUND\n@export"
      },
      "isValid": {
        "!type": "fn() -> bool",
        "!span": "43699[1465:20]-43706[1465:27]",
        "!doc": "Returns true if the component has not been destroyed.\n\n@public\n@platform\n@export"
      },
      "toString": {
        "!type": "fn() -> string",
        "!span": "44067[1477:20]-44075[1477:28]",
        "!doc": "Returns a string representation of the component for logging.\n\n@public\n@export"
      },
      "toJSON": {
        "!type": "fn() -> Component.prototype.toJSON.!ret",
        "!span": "44741[1499:20]-44747[1499:26]",
        "!doc": "Returns component serialized as Json string\n\n@private"
      },
      "getHandledEvents": {
        "!type": "fn() -> Component.prototype.getHandledEvents.!ret",
        "!span": "45016[1511:20]-45032[1511:36]",
        "!doc": "Returns an object whose keys are the lower-case names of Aura events for\nwhich this component currently has handlers.\n@export"
      },
      "hasEventHandler": {
        "!type": "fn(eventName: ?) -> bool",
        "!span": "45609[1533:20]-45624[1533:35]",
        "!doc": "Check if we have an event handler attached.\n\n@param {String}\n           eventName The event name associated with this component.\n@export"
      },
      "getFacets": {
        "!type": "fn() -> [Component.valueProviders.<i>]",
        "!span": "45958[1546:20]-45967[1546:29]",
        "!doc": "Returns an array of this component's facets, i.e., attributes of type\n<code>aura://Aura.Component[]</code>\n@export"
      },
      "isFlavorable": {
        "!type": "fn() -> !this.flavorable",
        "!span": "46989[1578:20]-47001[1578:32]",
        "!doc": "Returns true if this is a flavorable html element.\n@export"
      },
      "getFlavor": {
        "!type": "fn() -> !this.flavor",
        "!span": "47378[1590:20]-47387[1590:29]",
        "!doc": "Gets the flavor reference. This is either the flavor explicitly set on the\ncomponent instance (component def ref) or it is the default flavor of the\ncomponent, if a default (or app override) exists.\n\n@returns {String} The flavor, e.g., \"default\" or \"xyz.flavors.default\", etc...\n@export"
      },
      "render": {
        "!type": "fn() -> !this.renderer.!ret",
        "!span": "47557[1598:20]-47563[1598:26]",
        "!doc": "Invoke the render method defined on the component.\n@export"
      },
      "afterRender": {
        "!type": "fn()",
        "!span": "48371[1623:20]-48382[1623:31]",
        "!doc": "Invoke the afterRender method defined on the component.\n@export"
      },
      "rerender": {
        "!type": "fn() -> !this.renderer.!ret",
        "!span": "48840[1642:20]-48848[1642:28]",
        "!doc": "Invoke the rerender method defined on the component.\n@export"
      },
      "unrender": {
        "!type": "fn()",
        "!span": "49660[1666:20]-49668[1666:28]",
        "!doc": "Invoke the unrender method defined on the component.\n@export"
      },
      "getVersion": {
        "!type": "fn() -> Component.valueProviders.<i>",
        "!span": "50930[1701:20]-50940[1701:30]",
        "!doc": "Get the expected version number of a component based on its caller's requiredVersionDefs\nNote that for various rendering methods, we cannot rely on access stack.\nWe use creation version instead.\n@platform\n@export"
      },
      "getVersionInternal": {
        "!type": "fn() -> Component.valueProviders.<i>",
        "!span": "51184[1715:20]-51202[1715:38]",
        "!doc": "get version from context access stack\n\n@private"
      },
      "getValueProvider": {
        "!type": "fn(key: string) -> !this.valueProviders.<i>",
        "!span": "51394[1721:20]-51410[1721:36]"
      },
      "setupValueProviders": {
        "!type": "fn(customValueProviders: ?)",
        "!span": "51643[1729:20]-51662[1729:39]",
        "!doc": "Create the value providers"
      },
      "createActionValueProvider": {
        "!type": "fn() -> Component.valueProviders.c",
        "!span": "52289[1749:20]-52314[1749:45]"
      },
      "createStyleValueProvider": {
        "!type": "fn() -> Component.valueProviders.style",
        "!span": "53580[1782:20]-53604[1782:44]"
      },
      "setupComponentDef": {
        "!type": "fn(config: ?)",
        "!span": "53990[1797:20]-54007[1797:37]",
        "!doc": "A reference to the ComponentDefinition for this instance"
      },
      "createComponentStack": {
        "!type": "fn(facets: [Component.prototype.createComponentStack.!0.<i>], valueProvider: Component.prototype.createComponentStack.!1) -> Component.prototype.createComponentStack.!ret",
        "!span": "54526[1812:20]-54546[1812:40]"
      },
      "setupSuper": {
        "!type": "fn(configAttributes: Component.prototype.createComponentStack.!1)",
        "!span": "56714[1866:20]-56724[1866:30]"
      },
      "setSuperComponent": {
        "!type": "fn(component: AuraClientService.prototype.decode.!ret|bool)",
        "!span": "58825[1916:20]-58842[1916:37]"
      },
      "setupAttributes": {
        "!type": "fn(cmp: +Component, config: Component.prototype.createComponentStack.!1, localCreation: ?)",
        "!span": "58957[1922:20]-58972[1922:35]"
      },
      "validatePartialConfig": {
        "!type": "fn(config: ?, partialConfig: ?)",
        "!span": "67575[2094:20]-67596[2094:41]"
      },
      "getMethodHandler": {
        "!type": "fn(methodDef: +Aura.Method.MethodDef) -> fn()",
        "!span": "69235[2134:20]-69251[2134:36]"
      },
      "getActionCaller": {
        "!type": "fn(valueProvider: ?, actionExpression: ?) -> fn(event: +Aura.Event.Event)",
        "!span": "71366[2184:20]-71381[2184:35]"
      },
      "getEventDispatcher": {
        "!type": "fn(cmp: +Component|+Aura.Utils.Util.prototype.globalEval.!ret) -> !this.eventDispatcher",
        "!span": "72776[2230:20]-72794[2230:38]",
        "!doc": "Gets the event dispatcher.\n\n@public\n@export"
      },
      "setupComponentEvents": {
        "!type": "fn(cmp: +Component, config: Component.prototype.createComponentStack.!1)",
        "!span": "73089[2243:20]-73109[2243:40]"
      },
      "getHandler": {
        "!type": "fn(cmp: +Component, actionExpression: ?) -> fn(event: +Aura.Event.Event)",
        "!span": "74518[2286:20]-74528[2286:30]"
      },
      "setupApplicationEventHandlers": {
        "!type": "fn(cmp: +Component)",
        "!span": "74964[2301:20]-74993[2301:49]"
      },
      "setupValueEventHandlers": {
        "!type": "fn(cmp: +Component)",
        "!span": "75599[2316:20]-75622[2316:43]"
      },
      "setupMethods": {
        "!type": "fn()",
        "!span": "76219[2331:20]-76231[2331:32]"
      },
      "setupModel": {
        "!type": "fn(config: ?, cmp: +Component)",
        "!span": "76540[2342:20]-76550[2342:30]"
      },
      "setupFlavors": {
        "!type": "fn(config: ?, configAttributes: Component.prototype.createComponentStack.!1)",
        "!span": "76831[2352:20]-76843[2352:32]"
      },
      "doIndex": {
        "!type": "fn(cmp: +Component)",
        "!span": "77114[2362:20]-77121[2362:27]"
      },
      "doDeIndex": {
        "!type": "fn()",
        "!span": "77646[2378:20]-77655[2378:29]"
      },
      "replaceComponentClass": {
        "!type": "fn(descriptor: ?)",
        "!span": "77988[2389:20]-78009[2389:41]"
      },
      "injectComponent": {
        "!type": "fn(config: ?, localCreation: ?)",
        "!span": "78711[2404:20]-78726[2404:35]"
      },
      "provide": {
        "!type": "fn(localCreation: bool) -> !this.provider.!ret",
        "!span": "80031[2437:20]-80038[2437:27]",
        "!doc": "Runs the provide method and returns the component definition.\nThrows an error if the provide method is not found.\n@param {Boolean} localCreation"
      },
      "setProvided": {
        "!type": "fn(realComponentDef: ?, attributes: ?)",
        "!span": "80958[2463:20]-80969[2463:31]"
      },
      "associateRenderedBy": {
        "!type": "fn(cmp: +Component, element: ?)",
        "!span": "81857[2480:20]-81876[2480:39]"
      },
      "_$getSelfGlobalId$": {
        "!type": "fn() -> !this.globalId",
        "!span": "8761[270:12]-8781[270:32]"
      },
      "_$getRawValue$": {
        "!type": "fn(key: ?)",
        "!span": "8911[274:17]-8927[274:33]"
      }
    },
    "!type": "fn(config: ?, localCreation: ?)",
    "!span": "881[31:9]-890[31:18]",
    "!doc": "Construct a new Component.\n\n@public\n@class\n@constructor\n\n@param {Object}\n           config - component configuration\n@param {Boolean}\n           [localCreation] - local creation\n@platform\n@export",
    "shouldAutoDestroy": {
      "!type": "bool",
      "!span": "1054[36:9]-1071[36:26]"
    },
    "rendered": {
      "!type": "bool",
      "!span": "1087[37:9]-1095[37:17]"
    },
    "inUnrender": {
      "!type": "bool",
      "!span": "1114[38:9]-1124[38:19]"
    },
    "valueProviders": {
      "<i>": {
        "!span": "40192[1339:24]-40195[1339:27]",
        "!doc": "Debug Info\n#if {\"excludeModes\" : [\"PRODUCTION\", \"PRODUCTIONDEBUG\"]}",
        "<i>": "cancelAnimationFrame"
      },
      "c": {
        "actions": {
          "!span": "52577[1756:12]-52584[1756:19]",
          "<i>": "+ActionDef"
        },
        "get": {
          "!type": "fn(key: ?) -> +Action",
          "!span": "52602[1757:12]-52605[1757:15]"
        },
        "!span": "51793[1734:7]-51796[1734:10]"
      },
      "style": {
        "get": {
          "!type": "fn(key: ?)",
          "!span": "53659[1785:8]-53662[1785:11]"
        },
        "!span": "51975[1739:7]-51982[1739:14]"
      },
      "!span": "1181[40:9]-1195[40:23]",
      "e": {
        "<i>": {
          "<i>": {
            "valueProvider": "+AuraInstance"
          }
        },
        "get": "Component.eventDispatcher.get"
      },
      "version": "Component.valueProviders.<i>",
      "this": "+Component",
      "v": "+AttributeSet"
    },
    "eventDispatcher": {
      "get": {
        "!type": "fn(key: ?) -> +Aura.Event.Event",
        "!span": "72892[2233:12]-72897[2233:17]"
      },
      "<i>": {
        "<i>": {
          "!type": "fn(event: +Aura.Event.Event)",
          "!span": "71576[2189:23]-72497[2215:5]"
        },
        "!type": "[fn(event: +Aura.Event.Event)]",
        "!span": "14893[467:19]-14902[467:28]"
      },
      "!span": "1211[41:9]-1226[41:24]"
    },
    "docLevelHandlers": {
      "<i>": {
        "!type": "+Aura.Utils.DocLevelHandler",
        "!span": "18428[567:26]-18437[567:35]"
      },
      "!span": "1249[42:9]-1265[42:25]"
    },
    "references": {
      "<i>": {
        "!type": "+PropertyReferenceValue",
        "!span": "30848[1049:24]-30851[1049:27]"
      },
      "!span": "1288[43:9]-1298[43:19]"
    },
    "handlers": {
      "<i>": {
        "<i>": {
          "!type": "[fn(event: +Aura.Event.Event)]",
          "!span": "16277[510:17]-16287[510:27]"
        },
        "!span": "16071[502:38]-16076[502:43]"
      },
      "!span": "1312[44:9]-1320[44:17]"
    },
    "localIndex": {
      "<i>": {
        "!type": "[Component.localIndex.<i>, ?]",
        "!span": "8298[254:18]-8305[254:25]"
      },
      "!span": "1336[45:9]-1346[45:19]"
    },
    "destroyed": {
      "!type": "bool",
      "!span": "1362[46:9]-1371[46:18]"
    },
    "creationPath": {
      "!type": "string",
      "!span": "2233[66:17]-2245[66:29]",
      "!doc": "skip creation path if the current top path is not in server returned\ncomponentConfigs and localCreation"
    },
    "isRootComponent": {
      "!type": "bool",
      "!span": "3891[110:9]-3906[110:24]",
      "!doc": "Saves a flag to indicate whether the component implements the root marker interface."
    },
    "facetValueProvider": {
      "!type": "+Component",
      "!span": "5019[132:9]-5037[132:27]",
      "!doc": "Expose the information for inspecting purposes."
    },
    "_destroying": {
      "!type": "bool",
      "!span": "6349[176:9]-6360[176:20]"
    },
    "globalId": {
      "!type": "string",
      "!span": "7336[213:9]-7344[213:17]"
    },
    "_scheduledForAsyncDestruction": {
      "!type": "bool",
      "!span": "19076[594:9]-19105[594:38]"
    },
    "_globalId": {
      "!type": "string",
      "!span": "21883[677:13]-21892[677:22]",
      "!doc": "Track some useful debugging information for InvalidComponent's use\n#if {\"excludeModes\" : [\"PRODUCTION\"]}"
    },
    "elements": {
      "!type": "[?]",
      "!span": "22250[688:13]-22258[688:21]"
    },
    "attributeSet": {
      "!type": "+AttributeSet",
      "!span": "24587[765:13]-24599[765:25]"
    },
    "_description": {
      "!type": "string",
      "!span": "44132[1479:13]-44144[1479:25]"
    },
    "_cachedFacetNames": {
      "!type": "[?]",
      "!span": "46614[1560:13]-46631[1560:30]",
      "!doc": "cache the names--they're not going to change"
    },
    "<i>": {
      "!type": "fn()",
      "!span": "76440[2337:17]-76467[2337:44]"
    },
    "flavorable": {
      "!type": "bool",
      "!span": "76928[2354:13]-76938[2354:23]"
    },
    "length": {
      "!type": "number",
      "!span": "66402[176:60899]-66408[176:60905]"
    },
    "request": {
      "!type": "+XMLHttpRequest",
      "!span": "66434[176:60931]-66441[176:60938]"
    },
    "marker": {
      "!type": "number",
      "!span": "66474[176:60971]-66480[176:60977]"
    },
    "className": {
      "!type": "string",
      "!span": "21228[659:24]-21239[659:35]"
    }
  },
  "ComponentClassRegistry": {
    "prototype": {
      "hasComponentClass": {
        "!type": "fn(descriptor: string) -> bool",
        "!span": "1301[35:33]-1318[35:50]",
        "!doc": "Detects if the component class exists without actually defining it.\n@param {String} descriptor The qualified name of the component in the form markup://namespace:component"
      },
      "addComponentClass": {
        "!type": "fn(descriptor: string, exporter: +Function)",
        "!span": "1722[45:33]-1739[45:50]",
        "!doc": "The function that handles definitions of component classes.\n@param {String} descriptor in the form markup://namespace:component\n@param {Function} exporter A function that when executed will return the component object litteral.\n@export"
      },
      "getComponentClass": {
        "!type": "fn(descriptor: string) -> fn()|+Function",
        "!span": "2382[59:33]-2399[59:50]",
        "!doc": "Get or build the class constructor for the specified component.\n@param {String} descriptor in the form markup://namespace:component\n@returns Either the class that defines the component you are requesting, or undefined if not found.\n@export"
      },
      "buildComponentClass": {
        "!type": "fn(componentProperties: ?) -> +Function",
        "!span": "3305[83:33]-3324[83:52]",
        "!doc": "Build the class for the specified component.\nThis process is broken into subroutines for clarity and maintainabiity,\nand those are all combined into one single scope by the compiler.\n@param {Object} componentProperties The pre-built component properties.\n@returns {Function} The component class."
      },
      "buildInheritance": {
        "!type": "fn(componentProperties: ?)",
        "!span": "3850[98:33]-3866[98:49]",
        "!doc": "Augment the component class properties with their respective inheritance. The\ninner classes are \"static\" classes, and currenltly, only the helper is inherited.\n@param {Object} componentProperties The pre-built component properties."
      },
      "buildLibraries": {
        "!type": "fn(componentProperties: ?)",
        "!span": "5352[132:33]-5366[132:47]",
        "!doc": "Augment the component class properties with the component libraries. This method\nattached the component imports (a.k.a. \"libraries\") on the properties.\n@param {Object} componentProperties The pre-built component properties."
      },
      "buildConstructor": {
        "!type": "fn(componentProperties: ?) -> fn()",
        "!span": "5977[149:33]-5993[149:49]",
        "!doc": "Build the class constructor for the specified component.\n@param {Object} componentProperties The pre-built component properties.\n@returns {Function} The component class."
      }
    },
    "!type": "fn()",
    "!span": "703[21:9]-725[21:31]",
    "!doc": "A registry of Component classes.\n@constructor",
    "classExporter": {
      "!span": "892[24:9]-905[24:22]",
      "!doc": "We delay the creation of the definition of a class till it's requested.\nThe function that creates the component class is a classExporter.",
      "<i>": "+Function"
    },
    "classConstructors": {
      "!span": "1055[28:9]-1072[28:26]",
      "!doc": "Collection of all the component classes we generate for\nproper stack traces and proper use of prototypical inheritance"
    }
  },
  "ComponentDef": {
    "prototype": {
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "6075[165:23]-6088[165:36]",
        "!doc": "Returns a DefDescriptor object.\n\n@returns {DefDescriptor} A DefDescriptor object contains a prefix, namespace,\n         and name.\n@export"
      },
      "isAbstract": {
        "!type": "fn() -> !this.isAbs",
        "!span": "6345[176:23]-6355[176:33]",
        "!doc": "Checks whether the Component is abstract. Returns true if the component is\nabstract.\n\n@returns {Boolean} True if component is abstract, or false otherwise.\n@export"
      },
      "getSuperDef": {
        "!type": "fn() -> !this.superDef",
        "!span": "6648[187:23]-6659[187:34]",
        "!doc": "Returns the component definition for the immediate super type or null if none\nexists (should only be null for aura:component).\n\n@return {ComponentDef} The ComponentDef for the immediate super type\n@export"
      },
      "getHelper": {
        "!type": "fn() -> ?",
        "!span": "6905[198:23]-6914[198:32]",
        "!doc": "Gets the Helper instance. This method is for backward compatibility,\nthe helper is now an integral part of the component class.\n\n@returns {Helper}\n@export"
      },
      "getRequiredVersionDefs": {
        "!type": "fn() -> !this.requiredVersionDefs",
        "!span": "7243[209:23]-7265[209:45]",
        "!doc": "Returns RequiredVersionDef objects.\n\n@returns {RequiredVersionDefs}"
      },
      "hasRemoteDependencies": {
        "!type": "fn() -> !this.hasRemoteDeps",
        "!span": "7540[219:23]-7561[219:44]",
        "!doc": "Checks whether the component has remote dependencies. Returns true if remote\ndependencies are found.\n\n@returns {Boolean} True if remote dependencies exist, or false otherwise."
      },
      "getAllStyleDefs": {
        "!type": "fn() -> !this.allStyleDefs",
        "!span": "7755[229:23]-7770[229:38]",
        "!doc": "Gets all the StyleDef objects, including inherited ones, for this\nComponentDef.\n\n@returns {StyleDef}"
      },
      "getAllFlavoredStyleDefs": {
        "!type": "fn() -> !this.allFlavoredStyleDefs",
        "!span": "7971[239:23]-7994[239:46]",
        "!doc": "Gets all the FlavoredStyleDef objects, including inherited ones, for this\nComponentDef.\n\n@returns {StyleDef}"
      },
      "getStyleClassName": {
        "!type": "fn() -> !this.styleClassName",
        "!span": "8503[253:23]-8520[253:40]",
        "!doc": "Gets the CSS class name to use for Components of this type. Includes the\nclass names from all StyleDefs, including inherited ones, associated with\nthis ComponentDef. If multiple class names are found, the return value is a\nspace-separated list of class names. This string can be applied directly to\nDOM elements rendered by Components of this type.\n\n@returns {String} The style class name\n@export"
      },
      "getStyleDef": {
        "!type": "fn() -> !this.styleDef",
        "!span": "9670[291:23]-9681[291:34]",
        "!doc": "Gets the style definition. Returns a StyleDef object.\n\n@returns {StyleDef}\n@export"
      },
      "getDefaultFlavor": {
        "!type": "fn() -> !this.flavorOverride",
        "!span": "9973[302:23]-9989[302:39]",
        "!doc": "Gets the default flavor name, either from app-specified overrides or the\ndefault specified on the component def.\n\n@returns {String} The flavor, e.g., \"default\" or \"xyz.flavors.default\", etc...\n@export"
      },
      "getExplicitDefaultFlavor": {
        "!type": "fn() -> !this.defaultFlavor",
        "!span": "10976[331:23]-11000[331:47]",
        "!doc": "Gets the default flavor explicitly set on the component def (or one of its supers).\n\n@returns {String}"
      },
      "hasFlavorableChild": {
        "!type": "fn() -> bool",
        "!span": "11359[347:23]-11377[347:41]",
        "!doc": "Gets whether this def has at least one flavorable child element.\n\n@returns {Boolean}\n@export"
      },
      "getFlavorOverrides": {
        "!type": "fn() -> !this.flavorOverrides",
        "!span": "11547[357:23]-11565[357:41]",
        "!doc": "Gets the set of default flavor overrides.\n\n@returns {FlavorsDef}\n@export"
      },
      "isDynamicallyFlavorable": {
        "!type": "fn() -> !this.dynamicallyFlavorable",
        "!span": "11814[367:23]-11837[367:46]",
        "!doc": "Returns true if this or a super component is dynamically flavorable.\nPerforms a faster check than #getDynamicallyFlavorable.\n@returns {Boolean}\n@private"
      },
      "getDynamicallyFlavorable": {
        "!type": "fn() -> [!this]",
        "!span": "12244[379:23]-12268[379:47]",
        "!doc": "Returns a list of component defs from the inheritance hierarchy that are\nmarked dynamically flavorable, including this one if applicable.\n\nTo simply perform a boolean check, use #isDynamicallyFlavorable instead.\n@returns {Array}\n@private"
      },
      "getAttributeDefs": {
        "!type": "fn() -> !this.attributeDefs",
        "!span": "12635[396:23]-12651[396:39]",
        "!doc": "Gets all the attribute definitions. Returns an AttributeDef object.\n\n@returns {AttributeDefSet}\n@export"
      },
      "getFacets": {
        "!type": "fn() -> !this.facets",
        "!span": "12849[406:23]-12858[406:32]",
        "!doc": "Gets the component facets. A facet is any attribute of type Aura.Component[].\n\n@returns {Object}\n@export"
      },
      "getControllerDef": {
        "!type": "fn() -> !this.controllerDef",
        "!span": "13042[416:23]-13058[416:39]",
        "!doc": "Gets the controller definition. Returns a ControllerDef object.\n\n@returns {ControllerDef}\n@export"
      },
      "getModelDef": {
        "!type": "fn() -> !this.modelDef",
        "!span": "13234[426:23]-13245[426:34]",
        "!doc": "Gets the model definition. Returns a ModelDef object.\n\n@returns {ModelDef}\n@export"
      },
      "getEventDef": {
        "!type": "fn(name: ?, includeValueEvents: ?) -> ?",
        "!span": "13740[451:23]-13751[451:34]",
        "!doc": "Returns the event definitions.\n\n@param {String}\n           The name of the event definition.\n@param {Boolean}\n           includeValueEvents Set to true to include the value events.\n@returns{Object}\n@export"
      },
      "getEventNameByDescriptor": {
        "!type": "fn(descriptor: ?) -> string",
        "!span": "14473[474:23]-14497[474:47]",
        "!doc": "Get an event name by descriptor qualified name.\n\nThis is only used in the case of an action firing a component event. It is a\nbit of a hack, but will give back the name of the event that corresponds to\nthe descriptor.\n\n@param {String}\n           descriptor a descriptor qualified name.\n@return {String} null, or the component fired event name.\n@protected"
      },
      "getAllEvents": {
        "!type": "fn() -> !this.allEvents",
        "!span": "14907[489:23]-14919[489:35]",
        "!doc": "Gets all events associated with the Component.\n\n@returns {Object}\n@export"
      },
      "getAppHandlerDefs": {
        "!type": "fn() -> !this.appHandlerDefs",
        "!span": "15077[499:23]-15094[499:40]",
        "!doc": "Gets the application handler definitions.\n\n@returns {Object}\n@export"
      },
      "getCmpHandlerDefs": {
        "!type": "fn() -> !this.cmpHandlerDefs",
        "!span": "15255[509:23]-15272[509:40]",
        "!doc": "Gets the component handler definitions.\n\n@returns {Object}\n@export"
      },
      "getValueHandlerDefs": {
        "!type": "fn() -> !this.valueHandlerDefs",
        "!span": "15425[518:23]-15444[518:42]",
        "!doc": "Gets the value of the handler definitions.\n\n@returns {Object}"
      },
      "toString": {
        "!type": "fn() -> string",
        "!span": "15614[528:23]-15622[528:31]",
        "!doc": "Converts a ComponentDef object to type String.\n\n@returns {String}\n@export"
      },
      "isInstanceOf": {
        "!type": "fn(name: string) -> bool",
        "!span": "16112[543:23]-16124[543:35]",
        "!doc": "Checks whether the Component is an instance of the given component name (or\ninterface name).\n\n@param {String}\n           name The name of the component (or interface), with a format of\n           <code>namespace:componentName</code> (e.g.,\n           <code>ui:button</code>).\n@returns {Boolean} True if the Component is an instance, or false otherwise.\n@export"
      },
      "implementsDirectly": {
        "!type": "fn(type: string) -> bool",
        "!span": "16503[559:23]-16521[559:41]",
        "!doc": "Primarily used by isInstanceOf().\n\n@private"
      },
      "getLocationChangeEvent": {
        "!type": "fn() -> string",
        "!span": "16778[568:23]-16800[568:45]",
        "!doc": "Gets the location change event. Returns the qualified name of the event in\nthe format <code>markup://aura:locationChange</code>.\n@export"
      },
      "getLayouts": {
        "!type": "fn() -> !this.layouts",
        "!span": "17024[579:23]-17034[579:33]",
        "!doc": "@export"
      },
      "initSuperDef": {
        "!type": "fn(config: ?) -> +ComponentDef",
        "!span": "17122[586:23]-17134[586:35]",
        "!doc": "@private"
      },
      "initStyleDefs": {
        "!type": "fn()",
        "!span": "17575[604:23]-17588[604:36]",
        "!doc": "Setup the style defs details.\n\nNote that the style defs are in reverse order so that they get applied in\nforward order.\n\n@private"
      }
    },
    "valueEvents": {
      "change": {
        "!type": "string",
        "!span": "13378[436:4]-13386[436:12]"
      },
      "init": {
        "!type": "string",
        "!span": "13413[437:4]-13419[437:10]"
      },
      "destroy": {
        "!type": "string",
        "!span": "13444[438:4]-13453[438:13]"
      },
      "!span": "13358[435:13]-13369[435:24]",
      "!doc": "Value Event Enum\n\n@returns {ModelDef}"
    },
    "!type": "fn(config: ?)",
    "!span": "866[27:9]-878[27:21]",
    "!doc": "@class ComponentDef\n\nConstructs a new ComponentDef object, which is a component definition.\nA ComponentDef instance is created as part of Aura initialization.\n\n@constructor\n@protected\n@export",
    "hasRemoteDeps": {
      "!type": "bool",
      "!span": "994[30:9]-1007[30:22]"
    },
    "superDef": {
      "!type": "+ComponentDef",
      "!span": "1155[34:9]-1163[34:17]"
    },
    "styleDef": {
      "!type": "+StyleDef",
      "!span": "1214[35:9]-1222[35:17]"
    },
    "interfaces": {
      "<i>": {
        "!type": "bool",
        "!span": "2089[49:28]-2097[49:36]"
      },
      "!span": "1797[43:9]-1807[43:19]"
    },
    "isAbs": {
      "!type": "bool",
      "!span": "2454[64:9]-2459[64:14]"
    },
    "registerEventDefs": {
      "!span": "2740[73:9]-2757[73:26]",
      "<i>": "?"
    },
    "allEvents": {
      "!type": "[?]",
      "!span": "2812[75:9]-2821[75:18]"
    },
    "appHandlerDefs": {
      "!type": "[ComponentDef.appHandlerDefs.<i>]",
      "!span": "5004[133:9]-5018[133:23]"
    },
    "cmpHandlerDefs": {
      "!type": "[ComponentDef.cmpHandlerDefs.<i>]",
      "!span": "5054[134:9]-5068[134:23]"
    },
    "valueHandlerDefs": {
      "!type": "[?]",
      "!span": "5104[135:9]-5120[135:25]"
    },
    "isCSSPreloaded": {
      "!type": "bool",
      "!span": "5158[136:9]-5172[136:23]"
    },
    "flavorableChild": {
      "!type": "bool",
      "!span": "5359[142:13]-5374[142:28]"
    },
    "flavorOverrides": {
      "!type": "+FlavorsDef",
      "!span": "5604[150:13]-5619[150:28]"
    },
    "attributeDefs": {
      "!type": "+AttributeDefSet",
      "!span": "5681[153:9]-5694[153:22]"
    },
    "requiredVersionDefs": {
      "!type": "+RequiredVersionDefSet",
      "!span": "5783[154:9]-5802[154:28]"
    },
    "styleClassName": {
      "!type": "string",
      "!span": "9121[270:13]-9135[270:27]"
    },
    "flavorOverride": {
      "!type": "string",
      "!span": "10635[320:13]-10649[320:27]"
    },
    "allStyleDefs": {
      "!type": "[+StyleDef]",
      "!span": "17613[605:9]-17625[605:21]"
    },
    "allFlavoredStyleDefs": {
      "!type": "[+StyleDef]",
      "!span": "17641[606:9]-17661[606:29]"
    }
  },
  "ComponentDefStorage": {
    "prototype": {
      "EVICTION_TARGET_LOAD": {
        "!type": "number",
        "!span": "954[27:30]-974[27:50]",
        "!doc": "Target size, as a percent of max size, for component def storage during eviction."
      },
      "MUTEX_KEY": {
        "!type": "string",
        "!span": "1098[32:30]-1107[32:39]",
        "!doc": "Key to use of the MutexLocker to guarantee atomic execution across tabs."
      },
      "EVICTION_HEADROOM": {
        "!type": "number",
        "!span": "1402[42:30]-1419[42:47]",
        "!doc": "Minimum head room, as a percent of max size, to allocate after eviction and adding new definitions."
      },
      "TRANSACTION_SENTINEL_KEY": {
        "!type": "string",
        "!span": "1573[48:30]-1597[48:54]",
        "!doc": "Storage key used to track transactional bounds.\nTODO W-2365447 - replace this with bulk remove + put"
      },
      "useDefinitionStorage": {
        "!type": "fn() -> !this.useDefStore",
        "!span": "2074[61:30]-2094[61:50]",
        "!doc": "Whether to use storage for component definitions.\n@returns {Boolean} whether to use storage for component definitions."
      },
      "setupDefinitionStorage": {
        "!type": "fn()",
        "!span": "2468[73:30]-2490[73:52]",
        "!doc": "Creates storage to determine whether available storage mechanism is persistent\nto store component definitions. Uses storage if persistent. Otherwise, don't use\nstorage to backup definitions."
      },
      "getStorage": {
        "!type": "fn() -> !this.definitionStorage",
        "!span": "4500[119:30]-4510[119:40]",
        "!doc": "Gets the storage for component definitions.\n@return {AuraStorage|null} the component def storage or null if it's disabled."
      },
      "storeDefs": {
        "!type": "fn(cmpConfigs: [?], libConfigs: [?], evtConfigs: ?, context: ?) -> ?",
        "!span": "4960[131:30]-4969[131:39]",
        "!doc": "Stores component and library definitions into storage. Should always be called from within a call to #enqueue().\n@param {Array} cmpConfigs the component definitions to store\n@param {Array} libConfigs the lib definitions to store\n@return {Promise} promise that resolves when storing is complete."
      },
      "removeDefs": {
        "!type": "fn(descriptors: [string]) -> ?",
        "!span": "8010[191:30]-8020[191:40]",
        "!doc": "Removes definitions from storage. Should always be called from within a call to #enqueue().\n@param {String[]} descriptors the descriptors identifying the definitions to remove.\n@return {Promise} a promise that resolves when the definitions are removed."
      },
      "getAll": {
        "!type": "fn() -> ?",
        "!span": "10180[236:30]-10186[236:36]",
        "!doc": "Gets all definitions from storage. Should always be called from within a call to #enqueue().\n@return {Promise} a promise that resolves with an array of the configs from storage. If decoding\n the configs fails the promise rejects. If the underlying storage fails or is disabled the promise\n resolves to an empty array."
      },
      "restoreAll": {
        "!type": "fn(context: AuraInstance.context) -> ?",
        "!span": "12049[288:30]-12059[288:40]",
        "!doc": "Asynchronously retrieves all definitions from storage and adds to component service.\n@return {Promise} a promise that resolves when definitions are restored."
      },
      "enqueue": {
        "!type": "fn(execute: fn(resolve: ?, reject: ?)) -> ?",
        "!span": "14446[345:30]-14453[345:37]",
        "!doc": "Enqueues a function that requires isolated access to def storage.\n@param {function} execute the function to execute.\n@return {Promise} a promise that resolves when the provided function executes."
      },
      "clear": {
        "!type": "fn(metricsPayload?: ComponentDefStorage.prototype.clear.!0) -> ?",
        "!span": "16424[402:30]-16429[402:35]",
        "!doc": "Clears persisted definitions and all dependent stores and context.\n@param {Object} [metricsPayload] optional payload to send to metrics service.\n@return {Promise} a promise that resolves when all stores are cleared."
      }
    },
    "!type": "fn()",
    "!span": "806[22:9]-825[22:28]",
    "!doc": "@description Storage for component definitions. If persistent storage\nis not available then most operations are noops.\n@constructor\n@protected",
    "useDefStore": {
      "!type": "bool",
      "!span": "2561[75:13]-2572[75:24]"
    },
    "definitionStorage": {
      "!type": "+AuraStorage",
      "!span": "3970[104:21]-3987[104:38]"
    },
    "queue": {
      "!type": "[?]",
      "!span": "15303[366:17]-15308[366:22]",
      "!doc": "else run it immediately"
    }
  },
  "InvalidComponent": {
    "prototype": {
      "getDef": {
        "!type": "fn()",
        "!span": "897[32:27]-903[32:33]",
        "!doc": "@public\n@export"
      },
      "index": {
        "!type": "fn()",
        "!span": "1000[40:27]-1005[40:32]",
        "!doc": "@protected\n@export"
      },
      "deIndex": {
        "!type": "fn()",
        "!span": "1141[48:27]-1148[48:34]",
        "!doc": "@protected\n@export"
      },
      "find": {
        "!type": "fn()",
        "!span": "1477[59:27]-1481[59:31]",
        "!doc": "@public\n@export"
      },
      "findInstancesOf": {
        "!type": "fn()",
        "!span": "1603[66:27]-1618[66:42]",
        "!doc": "@private"
      },
      "getSuperest": {
        "!type": "fn()",
        "!span": "1751[73:27]-1762[73:38]",
        "!doc": "@private"
      },
      "findInstanceOf": {
        "!type": "fn()",
        "!span": "1894[81:27]-1908[81:41]",
        "!doc": "@private"
      },
      "isInstanceOf": {
        "!type": "fn()",
        "!span": "2039[88:27]-2051[88:39]",
        "!doc": "@export"
      },
      "implementsDirectly": {
        "!type": "fn()",
        "!span": "2241[96:27]-2259[96:45]",
        "!doc": "@param {Object} type Applies the type to its definition.\n@private"
      },
      "addHandler": {
        "!type": "fn()",
        "!span": "2405[104:27]-2415[104:37]",
        "!doc": "@public\n@export"
      },
      "addValueHandler": {
        "!type": "fn()",
        "!span": "2553[112:27]-2568[112:42]",
        "!doc": "@public\n@export"
      },
      "removeValueHandler": {
        "!type": "fn()",
        "!span": "2681[116:27]-2699[116:45]"
      },
      "finishDestroy": {
        "!type": "fn()",
        "!span": "2999[125:27]-3012[125:40]",
        "!doc": "Forces the final destroy of a component (after async)."
      },
      "destroy": {
        "!type": "fn()",
        "!span": "3088[132:27]-3095[132:34]",
        "!doc": "@public\n@export"
      },
      "isRendered": {
        "!type": "fn()",
        "!span": "3174[139:27]-3184[139:37]",
        "!doc": "@protected\n@export"
      },
      "setUnrendering": {
        "!type": "fn()",
        "!span": "3313[146:27]-3327[146:41]",
        "!doc": "@private"
      },
      "isUnrendering": {
        "!type": "fn()",
        "!span": "3461[154:27]-3474[154:40]",
        "!doc": "@private"
      },
      "setRendered": {
        "!type": "fn()",
        "!span": "3608[161:27]-3619[161:38]",
        "!doc": "@protected"
      },
      "getRenderer": {
        "!type": "fn()",
        "!span": "3751[168:27]-3762[168:38]",
        "!doc": "@protected"
      },
      "getGlobalId": {
        "!type": "fn()",
        "!span": "3839[175:27]-3850[175:38]",
        "!doc": "@public\n@export"
      },
      "getLocalId": {
        "!type": "fn()",
        "!span": "3927[182:27]-3937[182:37]",
        "!doc": "@public\n@export"
      },
      "getRendering": {
        "!type": "fn()",
        "!span": "4076[190:27]-4088[190:39]",
        "!doc": "@public\n@export"
      },
      "getSuper": {
        "!type": "fn()",
        "!span": "4231[198:27]-4239[198:35]",
        "!doc": "@protected\n@export"
      },
      "associateElement": {
        "!type": "fn()",
        "!span": "4378[206:27]-4394[206:43]",
        "!doc": "@protected\n@export"
      },
      "getElements": {
        "!type": "fn()",
        "!span": "4538[214:27]-4549[214:38]",
        "!doc": "@public\n@export"
      },
      "getElement": {
        "!type": "fn()",
        "!span": "4688[222:27]-4698[222:37]",
        "!doc": "@public\n@export"
      },
      "get": {
        "!type": "fn()",
        "!span": "4836[230:27]-4839[230:30]",
        "!doc": "@public\n@export"
      },
      "set": {
        "!type": "fn()",
        "!span": "4970[238:27]-4973[238:30]",
        "!doc": "@public\n@export"
      },
      "getConcreteComponent": {
        "!type": "fn()",
        "!span": "5106[246:27]-5126[246:47]",
        "!doc": "@public\n@export"
      },
      "isConcrete": {
        "!type": "fn()",
        "!span": "5274[254:27]-5284[254:37]",
        "!doc": "@public\n@export"
      },
      "getEventDispatcher": {
        "!type": "fn()",
        "!span": "5423[262:27]-5441[262:45]",
        "!doc": "@public\n@export"
      },
      "getModel": {
        "!type": "fn()",
        "!span": "5587[270:27]-5595[270:35]",
        "!doc": "@public\n@export"
      },
      "getEvent": {
        "!type": "fn()",
        "!span": "5731[278:27]-5739[278:35]",
        "!doc": "@public\n@export"
      },
      "getEventByDescriptor": {
        "!type": "fn()",
        "!span": "5868[285:27]-5888[285:47]",
        "!doc": "@protected"
      },
      "fire": {
        "!type": "fn()",
        "!span": "6027[292:27]-6031[292:31]",
        "!doc": "@private"
      },
      "isValid": {
        "!type": "fn() -> bool",
        "!span": "6165[301:27]-6172[301:34]",
        "!doc": "@public\n@export"
      },
      "toString": {
        "!type": "fn() -> string",
        "!span": "6266[309:27]-6274[309:35]",
        "!doc": "@public\n@export"
      },
      "getFacets": {
        "!type": "fn()",
        "!span": "6423[316:27]-6432[316:36]",
        "!doc": "@export"
      },
      "raiseInvalidComponentError": {
        "!type": "fn(func: string, args: [?])",
        "!span": "6560[323:27]-6586[323:53]",
        "!doc": "@private"
      }
    },
    "!type": "fn()",
    "!span": "717[23:9]-733[23:25]",
    "!doc": "@class InvalidComponent\n@constructor\n@private\n@export"
  },
  "Action": {
    "prototype": {
      "nextActionId": {
        "!type": "number",
        "!span": "3241[100:17]-3253[100:29]",
        "!doc": "Instance methods:"
      },
      "getId": {
        "!type": "fn() -> !this.id",
        "!span": "3355[109:17]-3360[109:22]",
        "!doc": "Gets the Action Id.\n\n@returns {string}\n@private\n@export"
      },
      "getNextGlobalId": {
        "!type": "fn() -> number|string",
        "!span": "3496[119:17]-3511[119:32]",
        "!doc": "Gets the next action scoped Id.\n\n@returns {string}\n@private"
      },
      "reactivatePath": {
        "!type": "fn()",
        "!span": "3886[133:17]-3900[133:31]",
        "!doc": "If a component is replacing the same-named component at the same level (e.g. provider),\nthis reactivates the path's error detection, so that is can request its location again without\nreporting an error.\n\n@private"
      },
      "forceCreationPath": {
        "!type": "fn(path: string) -> string",
        "!span": "4265[147:17]-4282[147:34]",
        "!doc": "Forces the creation path to match a given value.\n\nThis checks to see if the path matches, otherwise, it forces the path\nto the one supplied. A warning is emitted if the path mismatches but only\nif it is not the top level.\n\n@param {string} path the path to force\n@private"
      },
      "setDeferred": {
        "!type": "fn()",
        "!span": "5727[184:17]-5738[184:28]",
        "!doc": "Mark an action as deferred if it is abortable.\n\nThis is used to side-track actions that are queued when the primary display is refreshed. Since it\nis a heuristic, it has a few problems in that it may defer actions that should really not be.\n\n@private"
      },
      "isDeferred": {
        "!type": "fn() -> !this.deferred",
        "!span": "5944[194:17]-5954[194:27]",
        "!doc": "Check to see if an action has been deferred.\n\n@private\n@returns {Boolean} true if the action was marked deferred."
      },
      "releaseCreationPath": {
        "!type": "fn(path: string)",
        "!span": "6316[208:17]-6335[208:36]",
        "!doc": "Releases a creation path that was previously forced.\n\nThis is the mirrored call to 'forceCreationPath' that releases the 'force'.\nThe path must match the call to forceCreationPath, and the path must have\nbeen forced.\n\n@param {string} path the path to release.\n@private"
      },
      "pushCreationPath": {
        "!type": "fn(pathPart: string)",
        "!span": "6962[229:17]-6978[229:33]",
        "!doc": "Pushes a new part on the creation path.\n\n@param {string} pathPart the new path part to insert.\n@private"
      },
      "popCreationPath": {
        "!type": "fn(pathPart: string) -> ?",
        "!span": "7527[249:17]-7542[249:32]",
        "!doc": "Pops off the path part that was previously pushed.\n\n@param {string} pathPart the path part previously pushed.\n@private"
      },
      "topPath": {
        "!type": "fn() -> string",
        "!span": "8196[271:17]-8203[271:24]",
        "!doc": "Gets the path for the top entry of the path stack.\n\n@return {string} the top level path.\n@private"
      },
      "setCreationPathIndex": {
        "!type": "fn(idx: number)",
        "!span": "8538[285:17]-8558[285:37]",
        "!doc": "Sets the path index.\n\n@param {number} the index to set.\n@private"
      },
      "setCompletion": {
        "!type": "fn(fn: ?)",
        "!span": "9220[309:17]-9233[309:30]",
        "!doc": "Sets the completion function.\n\n@private"
      },
      "complete": {
        "!type": "fn()",
        "!span": "9454[319:17]-9462[319:25]",
        "!doc": "Calls the completion function if any.\n\n@private"
      },
      "getCurrentPath": {
        "!type": "fn() -> string",
        "!span": "9897[339:17]-9911[339:31]",
        "!doc": "Gets the current creatorPath from the top of the pathStack\n\n@returns {String}\n@private"
      },
      "getDef": {
        "!type": "fn() -> !this.def",
        "!span": "10460[357:17]-10466[357:23]",
        "!doc": "Gets the <code>ActionDef</code> object. Shorthand: <code>get(\"def\")</code>\n<p>\nSee Also: <a href=\"#reference?topic=api:ActionDef\">ActionDef</a>\n</p>\n\n@public\n@returns {ActionDef} The action definition, including its name, origin, and descriptor.\n@export"
      },
      "setParams": {
        "!type": "fn(config: Action.params)",
        "!span": "10868[371:17]-10877[371:26]",
        "!doc": "Sets parameters for the Action.\n\n@public\n@param {Object}\n           config The key/value pairs that specify the Action. The key is an attribute on the given component.\n            For example, <code>serverAction.setParams({ \"record\": id });</code> sets a parameter on <code>serverAction</code>.\n@platform\n@export"
      },
      "setParam": {
        "!type": "fn(key: ?, value: ?)",
        "!span": "11336[390:17]-11344[390:25]",
        "!doc": "Sets a single parameter for the Action.\n\n@public\n@param {!string}\n           key the name of the parameter to set.\n@param {Object}\n           value the value to set.\n@platform\n@export"
      },
      "getParam": {
        "!type": "fn(name: ?) -> !this.params.<i>",
        "!span": "11671[408:17]-11679[408:25]",
        "!doc": "Gets an Action parameter.\n\n@public\n@param {!string}\n           name The name of the Action.\n@returns {Object} The parameter value\n@platform\n@export"
      },
      "getParams": {
        "!type": "fn() -> !this.params",
        "!span": "11916[420:17]-11925[420:26]",
        "!doc": "Gets the collection of parameters for this Action.\n\n@public\n@returns {Object} The key/value pairs that specify the Action.\n@platform\n@export"
      },
      "getComponent": {
        "!type": "fn() -> !this.cmp",
        "!span": "12095[430:17]-12107[430:29]",
        "!doc": "Gets the component for this Action.\n\n@returns {Component} the component, if any.\n@private"
      },
      "setCallback": {
        "!type": "fn(scope: +Action, callback: fn(), name: ?)",
        "!span": "13424[459:17]-13435[459:28]",
        "!doc": "Sets the callback function that is executed after the server-side Action returns. Call a server-side Action from a\nclient-side controller using <code>callback</code>.\n\nNote that you can register a callback for an explicit state, or you can use 'ALL' which registers callbacks for\n\"SUCCESS\", \"ERROR\", and \"INCOMPLETE\" (but not \"ABORTED\" for historical compatibility). It is recommended that you\nuse an explicit name, and not the default 'undefined' to signify 'ALL'.\n\nThe valid names are:\n * SUCCESS: if the action successfully completes.\n * ERROR: if the action has an error (including javascript errors for client side actions)\n * INCOMPLETE: if a server side action failed to complete because there is no connection\n * ABORTED: if the action is aborted via abort()\n * REFRESH: for server side storable actions, this will be called instead of the SUCCESS action when the storage is refreshed.\n\n@public\n@param {Object}\n           scope The scope in which the function is executed.\n@param {function}\n           callback The callback function to run for each controller.\n@param {String}\n           name The action state for which the callback is to be associated with.\n@platform\n@export"
      },
      "getCallback": {
        "!type": "fn(type: ?) -> !this.callbacks.<i>",
        "!span": "14756[500:18]-14767[500:29]",
        "!doc": "Gets current callback for a give action Type\n\n@private\n@returns {Object} the callback scope and function that was set for this action.\n@platform\n@export"
      },
      "setAllAboardCallback": {
        "!type": "fn(scope: ?, callback: ?)",
        "!span": "15311[519:17]-15331[519:37]",
        "!doc": "Set an 'all aboard' callback, called just before the action is sent.\n\nThis can be used in conjunction with 'caboose' to implement a log+flush pattern.\nIntended to be called as the 'train' leaves the 'station'. Note that setParam should\nbe used to set additional parameters at this point.\n\n@public\n@param {Object}\n     scope The scope for the callback function.\n@param {Function}\n     callback the function to call.\n\n@export"
      },
      "callAllAboardCallback": {
        "!type": "fn(context: ?) -> bool",
        "!span": "15796[537:17]-15817[537:38]",
        "!doc": "Call the 'all aboard' callback.\n\nThis should only be called internally just before an action is sent to the server.\n\n@private\n@return false if the callback failed."
      },
      "wrapCallback": {
        "!type": "fn(scope: ?, callback: ?)",
        "!span": "16763[566:17]-16775[566:29]",
        "!doc": "Wrap the current action callbacks to ensure that they get called before a given function.\n\nThis can be used to add additional functionality to the already existing callbacks, allowing the user to effectively\n'append' a function to the current one.\n\n@param {Object}\n           scope the scope in which the new function should be called.\n@param {Function}\n           callback the callback to call after the current callback is executed.\n@private"
      },
      "run": {
        "!type": "fn(evt: ?)",
        "!span": "17751[596:17]-17754[596:20]",
        "!doc": "Deprecated. Note: This method is deprecated and should not be used. Instead, use the <code>enqueueAction</code>\nmethod on the Aura type. For example, <code>$A.enqueueAction(action)</code>.\n\nThe deprecated run method runs client-side actions. Do not use it for running server-side actions.\n\nIf you must have synchronous execution, you can temporarily use runDeprecated.\n\n@deprecated\n@public\n@param {Event}\n           evt The event that calls the Action.\n@export"
      },
      "runDeprecated": {
        "!type": "fn(evt: string)",
        "!span": "18213[612:17]-18226[612:30]",
        "!doc": "Deprecated. Run an action immediately.\n\nThis function should only be used for old code that requires inline execution of actions. Note that the code then\nmust know if the action is client side or server side, since server side actions cannot be executed inline.\n\n@deprecated\n@public\n@param {Event}\n           evt The event that calls the Action.\n@export"
      },
      "getState": {
        "!type": "fn() -> !this.state",
        "!span": "19548[644:17]-19556[644:25]",
        "!doc": "Gets the current state of the Action.\n\n@public\n@returns {string} The possible action states are:\n  \"NEW\": The action was created but is not in progress yet\n  \"RUNNING\": The action is in progress\n  \"SUCCESS\": The action executed successfully\n  \"FAILURE\": Deprecated. ERROR is returned instead. The action failed. This state is only valid for client-side actions.\n  \"ERROR\": The server returned an error\n  \"INCOMPLETE\": The server didn't return a response. The server might be down or the client might be offline.\n  \"ABORTED\": The action was aborted. You can register a callback for this explicitly\n@platform\n@export"
      },
      "getReturnValue": {
        "!type": "fn() -> !this.returnValue",
        "!span": "19785[655:17]-19799[655:31]",
        "!doc": "Gets the return value of the Action. A server-side Action can return any object containing serializable JSON data.<br/>\n\n@public\n@platform\n@export"
      },
      "getError": {
        "!type": "fn() -> !this.error",
        "!span": "20164[669:17]-20172[669:25]",
        "!doc": "Returns an array of error objects only for server-side actions.\nEach error object has a message field.\nIn any mode except PROD mode, each object also has a stack field, which is a list\ndescribing the execution stack when the error occurred.\n\n@public\n@platform\n@export"
      },
      "isBackground": {
        "!type": "fn() -> bool",
        "!span": "20392[680:17]-20404[680:29]",
        "!doc": "Returns true if the actions should be enqueued in the background, false if it should be run in the foreground.\n\n@public\n@platform\n@export"
      },
      "setBackground": {
        "!type": "fn()",
        "!span": "20671[692:17]-20684[692:30]",
        "!doc": "Sets the action to run as a background action. This cannot be unset. Background actions are usually long running and\nlower priority actions.\n\n@public\n@platform\n@export"
      },
      "runAfter": {
        "!type": "fn(action: ?)",
        "!span": "21374[710:17]-21382[710:25]",
        "!doc": "Deprecated. Note: This method is deprecated and should not be used. Instead, use the <code>enqueueAction</code>\nmethod on the Aura type. For example, <code>$A.enqueueAction(action)</code>.\n\nThe deprecated <code>runAfter</code> method adds a specified server-side action to the action queue. It is for\nserver-side actions only. For example, <code>this.runAfter(serverAction);</code> sends the action to the server and\nruns the callback when the server action completes (if the action was not aborted).\n\n@deprecated\n@public\n@param {Action}\n           action The action to run.\n@export"
      },
      "updateFromResponse": {
        "!type": "fn(response: ?) -> bool",
        "!span": "21688[722:17]-21706[722:35]",
        "!doc": "Updates the fields from a response.\n\n@param {Object}\n           response The response from the server.\n@return {Boolean} Returns true if the response differs from the original response\n@private"
      },
      "getStored": {
        "!type": "fn() -> Action.prototype.getStored.!ret",
        "!span": "25328[806:17]-25337[806:26]",
        "!doc": "Gets a storable response from this action.\n\nWARNING: must use after finishAction() which updates <code>this.components</code>.\n\n@private"
      },
      "getStorageErrorHandler": {
        "!type": "fn() -> !this.storableConfig",
        "!span": "25772[824:17]-25794[824:39]",
        "!doc": "Gets the configured storage error handler callback."
      },
      "prepareToSend": {
        "!type": "fn() -> Action.prototype.prepareToSend.!ret",
        "!span": "25971[832:17]-25984[832:30]",
        "!doc": "Returns the json representation of the action\n@private"
      },
      "finishAction": {
        "!type": "fn(context: string)",
        "!span": "26225[842:17]-26237[842:29]",
        "!doc": "Calls callbacks and fires events upon completion of the action.\n\n@param {AuraContext} context the context for pushing and popping the current action.\n@private"
      },
      "abortIfComponentInvalid": {
        "!type": "fn(beforeSend: bool) -> bool",
        "!span": "29102[925:17]-29125[925:40]",
        "!doc": "Abort an action if the component is not valid.\n\n@param {Boolean} beforeSend Have we sent the action to the server yet?\n@return {Boolean} true if the action was aborted.\n@private"
      },
      "abort": {
        "!type": "fn()",
        "!span": "29386[938:17]-29391[938:22]",
        "!doc": "Mark this action as aborted.\n\n@private"
      },
      "setAbortable": {
        "!type": "fn()",
        "!span": "30306[969:17]-30318[969:29]",
        "!doc": "Set the action as abortable. Abortable actions are not sent to the server if the component is not valid.\n\nActions not marked abortable are always sent to the server regardless of the validity of the component.\nFor example, a save/modify action should not be set abortable to cause it to go to the server even if\nthe component is deleted.\n\nSetting an action as abortable can not be undone\n\n@platform\n@export"
      },
      "getAbortableId": {
        "!type": "fn() -> string",
        "!span": "30497[981:17]-30511[981:31]",
        "!doc": "[Deprecated] [Returns undefined]\n\n@public\n@returns {string} undefined\n@export\n@deprecated"
      },
      "isRefreshAction": {
        "!type": "fn() -> bool",
        "!span": "30628[989:17]-30643[989:32]",
        "!doc": "Checks if this action is a refresh.\n@export"
      },
      "isAbortable": {
        "!type": "fn() -> !this.abortable",
        "!span": "30854[1000:17]-30865[1000:28]",
        "!doc": "Returns the current state of the abortable flag.\n\n@public\n@returns {Boolean} tha abortable flag\n@export"
      },
      "setExclusive": {
        "!type": "fn() -> bool",
        "!span": "31035[1012:17]-31047[1012:29]",
        "!doc": "[Deprecated] Does nothing.\n\n@public\n@returns {Boolean} false\n@export\n@deprecated"
      },
      "isExclusive": {
        "!type": "fn() -> bool",
        "!span": "31209[1024:17]-31220[1024:28]",
        "!doc": "[Deprecated] Returns false.\n\n@public\n@returns {Boolean} false\n@export\n@deprecated"
      },
      "setStorable": {
        "!type": "fn(config: Action.storableConfig)",
        "!span": "31781[1040:17]-31792[1040:28]",
        "!doc": "Marks the Action as storable. For server-side Actions only.\n\n@public\n@param {Object}\n           config Optional. A set of key/value pairs that specify the storage options to set. You can set the\n           following option:\n           <code>ignoreExisting</code>: Set to <code>true</code> to refresh the stored item with a newly retrieved value,\n             regardless of whether the item has expired or not. The default value is <code>false</code>.\n@platform\n@export"
      },
      "isStorable": {
        "!type": "fn() -> bool",
        "!span": "32195[1056:17]-32205[1056:27]",
        "!doc": "Returns true if the function is storable, or false otherwise. For server-side Actions only.\n\n@public\n@returns {Boolean}\n@export"
      },
      "setCaboose": {
        "!type": "fn()",
        "!span": "32650[1071:17]-32660[1071:27]",
        "!doc": "Sets this action as a 'caboose'.\n\nThis is only relevant for server side actions.\nThis action will not be sent to the server until there is some other action\nthat would cause a server round-trip or after 60s since last send.\n\n@public\n@export"
      },
      "isCaboose": {
        "!type": "fn() -> !this.caboose",
        "!span": "32844[1083:17]-32853[1083:26]",
        "!doc": "Returns true if the function should not create an XHR request.\n\n@public\n@returns {boolean}\n@export"
      },
      "_isStorable": {
        "!type": "fn() -> !this.storable",
        "!span": "32935[1090:17]-32946[1090:28]",
        "!doc": "@private"
      },
      "getStorageKey": {
        "!type": "fn() -> string",
        "!span": "33097[1100:17]-33110[1100:30]",
        "!doc": "Gets the storage key in name-value pairs.\n\n@private\n@export"
      },
      "isFromStorage": {
        "!type": "fn() -> bool",
        "!span": "33408[1114:17]-33421[1114:30]",
        "!doc": "Returns true if a given function is from the current storage, or false otherwise.\n\n@public\n@returns {Boolean}\n@export"
      },
      "setChained": {
        "!type": "fn()",
        "!span": "33628[1124:17]-33638[1124:27]",
        "!doc": "Chains a function to run after the current Action. For server-side Actions only.\n\n@public\n@export"
      },
      "isChained": {
        "!type": "fn() -> !this.chained",
        "!span": "33871[1135:17]-33880[1135:26]",
        "!doc": "Returns true if a given function is chained, or false otherwise. For server-side Actions only.\n\n@returns {Boolean}\n@private"
      },
      "toJSON": {
        "!type": "fn() -> Action.prototype.prepareToSend.!ret",
        "!span": "34076[1145:17]-34082[1145:23]",
        "!doc": "Returns the key/value pairs of the Action id, descriptor, and parameters in JSON format.\n\n@public\n@export"
      },
      "markException": {
        "!type": "fn(e: AuraInstance.lastKnownError)",
        "!span": "34989[1166:17]-35002[1166:30]",
        "!doc": "Mark an action as having an error.\n\n@param e the exception with which we want to mark the action."
      },
      "markError": {
        "!type": "fn(context: ?, e: ?)",
        "!span": "35826[1193:17]-35835[1193:26]",
        "!doc": "Mark the current action as having an error and finish the Action.\n\n@param context The current context.\n@param e The error with which we want to mark the action.\n@private"
      },
      "incomplete": {
        "!type": "fn(context: ?)",
        "!span": "36025[1204:17]-36035[1204:27]",
        "!doc": "Mark the current action as incomplete.\n\n@private"
      },
      "copyToRefresh": {
        "!type": "fn() -> Action.prototype.copyToRefresh.!ret",
        "!span": "36476[1218:17]-36489[1218:30]",
        "!doc": "Internal routine to do the basic copy to a new refresh action."
      },
      "getRefreshAction": {
        "!type": "fn(originalResponse: ?) -> Action.prototype.getRefreshAction.!ret",
        "!span": "36981[1239:17]-36997[1239:33]",
        "!doc": "Refreshes the Action. Used with storage.\n\n@private"
      },
      "getRetryFromStorageAction": {
        "!type": "fn() -> ?|+Action",
        "!span": "38514[1276:17]-38539[1276:42]",
        "!doc": "Returns an action that retries this action from storage with the server or null if the action wasn't from storage\n\n@private\n@returns {Action}"
      },
      "getStorage": {
        "!type": "fn() -> +AuraStorage",
        "!span": "38838[1292:17]-38848[1292:27]",
        "!doc": "Gets the Action storage.\n\n@returns {Storage}\n@private\n@export"
      },
      "parseAndFireEvent": {
        "!type": "fn(evtObj: ?)",
        "!span": "39011[1301:17]-39028[1301:34]",
        "!doc": "Uses the event object in the action's response and fires the event.\n\n@private"
      },
      "fireRefreshEvent": {
        "!type": "fn(event: string, responseUpdated: bool)",
        "!span": "39944[1328:17]-39960[1328:33]",
        "!doc": "Fire off a refresh event if there is a valid component listener.\n\n@private"
      }
    },
    "getStorageKey": {
      "!type": "fn(descriptor: string, params: Action.params) -> string",
      "!span": "2993[90:7]-3006[90:20]",
      "!doc": "Static methods:"
    },
    "getStorage": {
      "!type": "fn() -> +AuraStorage",
      "!span": "3120[94:7]-3130[94:17]"
    },
    "!type": "fn(def: +ActionDef, suffix: string, method: +ActionDef, paramDefs: ActionDef.paramDefs, background: bool, cmp: +Component, caboose: bool)",
    "!span": "1665[41:9]-1671[41:15]",
    "!doc": "A base class for an Aura Action to be passed to an associated component. An Action is created in a client-side or\nserver-side controller. Invoke an Action in a controller by declaring cmp.get(\"c.actionName\"). Call a server-side\nAction from a client-side controller.\n\n@constructor\n@class\n@param {Object}\n           def The definition of the Action.\n@param {string}\n           suffix A suffix to distinguish components.\n@param {function}\n           method The method for the Action. For client-side Action only. A function to serialize the Action as a\n           String in the JSON representation.\n@param {Object}\n           paramDefs The parameter definitions for the Action.\n@param {boolean}\n           background is the action defined as a background action?\n@param {Component}\n           cmp The component associated with the Action.\n@param {boolean}\n           caboose should this action wait for the next non boxcar action?\n@platform\n@export",
    "params": {
      "!span": "1871[47:9]-1877[47:15]"
    },
    "state": {
      "!type": "string",
      "!span": "1924[49:9]-1929[49:14]"
    },
    "callbacks": {
      "SUCCESS": {
        "!span": "14155[471:23]-14164[471:32]",
        "fn": "XMLHttpRequest.onreadystatechange",
        "s": "+Action"
      },
      "ERROR": {
        "!span": "14257[475:23]-14264[475:30]",
        "fn": "XMLHttpRequest.onreadystatechange",
        "s": "+Action"
      },
      "INCOMPLETE": {
        "!span": "14357[479:23]-14369[479:35]",
        "fn": "XMLHttpRequest.onreadystatechange",
        "s": "+Action"
      },
      "<i>": {
        "!span": "14475[484:23]-14479[484:27]",
        "!doc": "If there is a callback for the action's current state, invoke that too",
        "fn": "XMLHttpRequest.onreadystatechange",
        "s": "+Action"
      },
      "!span": "1948[50:9]-1957[50:18]"
    },
    "events": {
      "!type": "[?]",
      "!span": "1973[51:9]-1979[51:15]"
    },
    "actionId": {
      "!type": "number",
      "!span": "2023[53:9]-2031[53:17]"
    },
    "id": {
      "!type": "string",
      "!span": "2076[54:9]-2078[54:11]"
    },
    "storable": {
      "!type": "bool",
      "!span": "2159[56:9]-2167[56:17]"
    },
    "caboose": {
      "!type": "bool",
      "!span": "2186[57:9]-2193[57:16]"
    },
    "allAboardCallback": {
      "!type": "fn()",
      "!span": "2214[58:9]-2231[58:26]",
      "!doc": "@private"
    },
    "abortable": {
      "!type": "bool",
      "!span": "2254[59:9]-2263[59:18]"
    },
    "deferred": {
      "!type": "bool",
      "!span": "2282[60:9]-2290[60:17]"
    },
    "pathStack": {
      "!type": "[?]",
      "!span": "2498[69:9]-2507[69:18]",
      "!doc": "FIXME: creation path"
    },
    "canCreate": {
      "!type": "bool",
      "!span": "2523[70:9]-2532[70:18]"
    },
    "refreshAction": {
      "!type": "+Action",
      "!span": "2686[76:9]-2699[76:22]",
      "!doc": "FIXME: need to expose for plugins"
    },
    "nextGlobalId": {
      "!type": "number",
      "!span": "3570[121:13]-3582[121:25]"
    },
    "storableConfig": {
      "ignoreExisting": {
        "!type": "bool",
        "!span": "36643[1222:8]-36659[1222:24]"
      },
      "!span": "31971[1044:9]-31985[1044:23]",
      "errorHandler": "Action.storableConfig"
    },
    "chained": {
      "!type": "bool",
      "!span": "33663[1125:9]-33670[1125:16]"
    },
    "length": {
      "!type": "number",
      "!span": "66402[176:60899]-66408[176:60905]"
    },
    "marker": {
      "!type": "number",
      "!span": "66474[176:60971]-66480[176:60977]"
    }
  },
  "ActionDef": {
    "prototype": {
      "getName": {
        "!type": "fn() -> !this.name",
        "!span": "2115[66:20]-2122[66:27]",
        "!doc": "Gets the name of this Action. The name is the unique identifier that the component can use to call this Action.\n\n@returns {String}\n@export"
      },
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "2283[76:20]-2296[76:33]",
        "!doc": "Gets the Action Descriptor.\n\n@returns {String} descriptor of ActionDef\n@private"
      },
      "getActionType": {
        "!type": "fn() -> !this.actionType",
        "!span": "2517[86:20]-2530[86:33]",
        "!doc": "Gets the Action type, which can either be \"CLIENT\" or \"SERVER\".\n\n@returns {String} Possible values are \"CLIENT\" or \"SERVER\".\n@private"
      },
      "isClientAction": {
        "!type": "fn() -> bool",
        "!span": "2725[97:20]-2739[97:34]",
        "!doc": "Returns true if the Action type is client-side, or false otherwise.\n\n@public\n@returns {!boolean}\n@export"
      },
      "isServerAction": {
        "!type": "fn() -> bool",
        "!span": "2947[108:20]-2961[108:34]",
        "!doc": "Returns true if the Action type is server-side, or false otherwise.\n\n@public\n@returns {!boolean}\n@export"
      },
      "isBackground": {
        "!type": "fn() -> bool",
        "!span": "3185[117:20]-3197[117:32]",
        "!doc": "Returns true if the action is defined as background (i.e. @BackgroundAction on the java class)\n@protected\n@returns {!boolean}"
      },
      "isCaboose": {
        "!type": "fn() -> bool",
        "!span": "3418[126:20]-3427[126:29]",
        "!doc": "Returns true if the action is defined as 'force boxcar' (i.e. @CabooseAction on the java class)\n@protected\n@returns {!boolean}"
      },
      "newInstance": {
        "!type": "fn(cmp: +Component) -> +Action",
        "!span": "3658[138:20]-3669[138:31]",
        "!doc": "Returns a new Action instance.\n\n@param {Object}\n           cmp The component associated with the Action.\n@returns {Action}\n@private"
      },
      "toString": {
        "!type": "fn() -> string",
        "!span": "3871[145:20]-3879[145:28]",
        "!doc": "Get a reasonable string representation of the def."
      }
    },
    "!type": "fn(config: ?)",
    "!span": "934[25:9]-943[25:18]",
    "!doc": "@description The Action Definition including the name, descriptor, action type, method, and parameter definitions. An\n           ActionDef instance is created as part of the ControllerDef initialization.\n\n@constructor\n@param {Object}\n           config\n@export",
    "descriptor": {
      "!type": "string",
      "!span": "995[27:9]-1005[27:19]"
    },
    "actionType": {
      "!type": "string",
      "!span": "1039[28:9]-1049[28:19]"
    },
    "meth": {
      "!type": "+ActionDef",
      "!span": "1083[29:9]-1087[29:13]"
    },
    "paramDefs": {
      "!span": "1105[30:9]-1114[30:18]"
    },
    "background": {
      "!type": "bool",
      "!span": "1134[31:13]-1144[31:23]"
    },
    "caboose": {
      "!type": "bool",
      "!span": "1167[32:13]-1174[32:20]"
    }
  },
  "ControllerDef": {
    "prototype": {
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "1416[39:24]-1429[39:37]",
        "!doc": "Gets the Controller Descriptor with the format <code>markup://aura:component</code>.\n@returns {String} ControllerDef descriptor"
      },
      "getActionDef": {
        "!type": "fn(key: string) -> ?",
        "!span": "1634[49:24]-1646[49:36]",
        "!doc": "Gets the Action Definition.\n@param {String} key The data key to look up on the element.\n@returns {Object}\n@export"
      },
      "get": {
        "!type": "fn(key: string) -> ?",
        "!span": "2093[63:24]-2096[63:27]",
        "!doc": "Gets the value of the Controller Definition based on the given key.\n@param {String} key The data key to look up on the element.\n@returns {Object} A new Action Definition instance\n@export"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "881[23:9]-894[23:22]",
    "!doc": "@description Creates a new ControllerDef, including the descriptor and action definitions.\nA ControllerDef instance is created as part of the ComponentDef initialization.\n@constructor\n@param {Object} config\n@export",
    "actionDefs": {
      "!span": "957[25:9]-967[25:19]",
      "<i>": "+ActionDef"
    }
  },
  "EventDef": {
    "prototype": {
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "1274[36:19]-1287[36:32]",
        "!doc": "Gets the event descriptor. (e.g. markup://foo:bar)\n@returns {Object}\n@export"
      },
      "getEventType": {
        "!type": "fn() -> !this.type",
        "!span": "1417[45:19]-1429[45:31]",
        "!doc": "Gets the event type.\n@returns {Object}\n@export"
      },
      "getAttributeDefs": {
        "!type": "fn() -> !this.attributeDefs",
        "!span": "1571[54:19]-1587[54:35]",
        "!doc": "Gets the attribute definitions.\n@returns {AttributeDef}\n@export"
      },
      "getSuperDef": {
        "!type": "fn() -> !this.superDef",
        "!span": "1861[63:19]-1872[63:30]",
        "!doc": "Gets the event definition for the immediate super type.\n@returns {EventDef} The EventDef for the immediate super type, or null if none exists (should only be null for aura:event)\n@export"
      },
      "initSuperDef": {
        "!type": "fn(config: ?) -> +EventDef",
        "!span": "2122[72:19]-2134[72:31]",
        "!doc": "Initializes the event definition for the immediate super type.\n@param {Object} config The argument that contains the super definition, or null if none exists.\n@private"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "830[22:9]-838[22:17]",
    "!doc": "@description The Event Definition including the descriptor, type, and attributes.\nAn EventDef instance is created as part of Aura initialization.\n@constructor\n@export",
    "superDef": {
      "!type": "+EventDef",
      "!span": "921[24:9]-929[24:17]"
    }
  },
  "FlavorDefaultDef": {
    "prototype": {
      "getFlavor": {
        "!type": "fn(componentDescriptor: +DefDescriptor) -> string",
        "!span": "1463[46:27]-1472[46:36]",
        "!doc": "Returns a flavor for the given component descriptor.\n@param {DefDescriptor} componentDescriptor The component descriptor, e.g., \"ui:button\".\n@returns {String} The flavor.\n@private"
      },
      "isContextual": {
        "!type": "fn(context: string) -> bool|AuraInstance.context.contextGlobals",
        "!span": "2257[72:27]-2269[72:39]",
        "!doc": "Returns true if the given expression string evaluates to true.\n@param {String} context The expression.\n@returns {Boolean} the evaluation result.\n@private"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "760[22:9]-776[22:25]",
    "!doc": "@description Creates a FlavorDefaultDef instance.\n@param {Object} config\n@constructor\n@protected"
  },
  "FlavorsDef": {
    "prototype": {
      "getFlavor": {
        "!type": "fn(componentDescriptor: +DefDescriptor) -> !this.cache.<i>",
        "!span": "1334[36:21]-1343[36:30]",
        "!doc": "Returns a flavor for the given component descriptor.\n@param {DefDescriptor} componentDescriptor The component descriptor."
      }
    },
    "!type": "fn(config: ?)",
    "!span": "827[22:9]-837[22:19]",
    "!doc": "@description Creates a FlavorsDef instance with a collection of flavor overrides for specific component descriptors.\n@param {Object} config\n@constructor\n@protected",
    "flavors": {
      "!type": "[+FlavorDefaultDef]",
      "!span": "857[23:9]-864[23:16]"
    },
    "cache": {
      "<i>": {
        "!type": "string",
        "!span": "1674[46:19]-1676[46:21]"
      },
      "!span": "929[24:9]-934[24:14]"
    }
  },
  "AuraLocalizationContext": {
    "!type": "fn(config: ?)",
    "!span": "782[21:9]-805[21:32]",
    "!doc": "FIXME: AuraLocalizationContext should become a global value provider and be accessed via the expression service."
  },
  "LibraryIncludeRegistry": {
    "prototype": {
      "hasLibraryInclude": {
        "!type": "fn(descriptor: string) -> bool",
        "!span": "1862[48:33]-1879[48:50]",
        "!doc": "Detects if the library include exists without actually defining it.\n@param {String} descriptor The qualified name of the library include in the form markup://namespace:include"
      },
      "addLibraryInclude": {
        "!type": "fn(descriptor: string, dependencies: [?], exporter: +Function)",
        "!span": "2404[59:34]-2421[59:51]",
        "!doc": "The function that handles definitions of library includes. This works like a simplfied version of\nRequireJS's \"define\" function with a fixed set of arguments.\n@param {String} descriptor name of the include.\n@param {Array} dependencies The list of dependencies (other includes).\n@param {Function} exporter A function that when executed will return the include object."
      },
      "getLibraryInclude": {
        "!type": "fn(descriptor: string) -> [?]",
        "!span": "3245[76:33]-3262[76:50]",
        "!doc": "Get or build the instance for the specified library include. his works like a simplfied version of\nRequireJS's \"require\" function, without a callback.\n@param {String} descriptor in the form markup://namespace:include.\n@returns Either the instance of the include you are requesting, or undefined if not found.\n@export"
      },
      "buildLibraryInclude": {
        "!type": "fn(descriptor: string) -> [?]",
        "!span": "4460[115:33]-4479[115:52]",
        "!doc": "Try to build an instance for the specified library include.\n@param {Array} dependencies The list of descriptors markup://namespace:include.\n@returns {Array} the list of instances or undefined."
      },
      "clearDependencyQueue": {
        "!type": "fn()",
        "!span": "6013[163:33]-6033[163:53]",
        "!doc": "Reset the queue."
      },
      "enqueueDependency": {
        "!type": "fn(descriptor: string)",
        "!span": "6279[171:33]-6296[171:50]",
        "!doc": "Add a dependcy to the processing queue.\n@param {String} descriptor The qualified name of the library include in the form markup://namespace:include"
      },
      "dequeueDependency": {
        "!type": "fn(descriptor: string)",
        "!span": "6705[183:33]-6722[183:50]",
        "!doc": "Remove a dependcy from the processing queue.\n@param {String} descriptor The qualified name of the library include in the form markup://namespace:include"
      },
      "cloneDependencyQueue": {
        "!type": "fn() -> [?]",
        "!span": "7085[195:33]-7105[195:53]",
        "!doc": "Clone the array of dependencies and reset the changed flag.\n@return {Array} The cloned array of dependecies."
      },
      "hasDependencyQueue": {
        "!type": "fn() -> bool",
        "!span": "7390[205:33]-7408[205:51]",
        "!doc": "Return the modified status of the dependency queue.\n@return {Boolean} True if the dependency queue has changed."
      },
      "hasDependencyQueueChanged": {
        "!type": "fn() -> !this.dependencyQueueChanged",
        "!span": "7631[213:33]-7656[213:58]",
        "!doc": "Return the modified status of the dependency queue.\n@return {Boolean} True if the dependency queue has changed."
      }
    },
    "!type": "fn()",
    "!span": "964[24:9]-986[24:31]",
    "!doc": "A registry of library includes.\nIncludes are similar to RequireJS's modules. The difference is their comsumption:\nin Aura, those are exported as items on library s instead of inside a require callback.\nWe delay the creation of the instance of a library include untill it's requested.\n@constructor",
    "exporter": {
      "!span": "1072[26:9]-1080[26:17]",
      "!doc": "A map of Function[] that each return a library include instance.",
      "<i>": "+Function"
    },
    "dependencies": {
      "<i>": {
        "!type": "[?]",
        "!span": "2781[64:26]-2791[64:36]"
      },
      "!span": "1168[29:9]-1180[29:21]",
      "!doc": "A map of String[] that define the library include dependencies."
    },
    "dependenciesInstances": {
      "<i>": {
        "!type": "[?]",
        "!span": "2844[65:35]-2854[65:45]"
      },
      "!span": "1296[32:9]-1317[32:30]",
      "!doc": "A map of Object[] that define the library include dependencies (the resolved dependencies)."
    },
    "instance": {
      "!span": "1402[35:9]-1410[35:17]",
      "!doc": "A maps of Object that contain the library include instances."
    },
    "dependencyQueue": {
      "!type": "[string]",
      "!span": "1499[38:9]-1514[38:24]",
      "!doc": "A String[] that contains dependencied currently being processed."
    },
    "dependencyQueueChanged": {
      "!type": "bool",
      "!span": "1604[41:9]-1626[41:31]",
      "!doc": "Boolean to indicate if the queue has changed during an iteration."
    }
  },
  "LibraryRegistry": {
    "prototype": {
      "initLibraries": {
        "!type": "fn(libraries: ?)",
        "!span": "1072[34:26]-1085[34:39]",
        "!doc": "Init library definitions.\n@param {Array} Library definitions.\n@export"
      },
      "hasLibrary": {
        "!type": "fn(descriptor: string) -> bool",
        "!span": "1533[44:26]-1543[44:36]",
        "!doc": "Detects if the library exists without actually defining it.\n@param {String} descriptor The qualified name of the library in the form markup://namespace:library"
      },
      "addLibrary": {
        "!type": "fn(descriptor: string, includes: ?)",
        "!span": "1931[53:26]-1941[53:36]",
        "!doc": "Register a library defintion. A library is a collection of includes.\n@param {String} descriptor The qualified name of the library in the form markup://namespace:library\n@param {Object} includes Pairs of library export and include definitions."
      },
      "getLibrary": {
        "!type": "fn(descriptor: string) -> ?",
        "!span": "2552[67:26]-2562[67:36]",
        "!doc": "Returns a library from the registry. If the library is missing,\nbuild the library before returning it.\n@param {String} descriptor The qualified name of the library in the form markup://namespace:library\n@returns {Object} library from registry."
      },
      "buildLibrary": {
        "!type": "fn(includes: ?|[?]) -> ?",
        "!span": "3096[87:27]-3108[87:39]",
        "!doc": "Returns a library instance which is a map of library include instances.\n@param {Array} includes The map of incudes, export and descriptor pairs.\n@returns {Object} new library."
      }
    },
    "!type": "fn()",
    "!span": "735[21:9]-750[21:24]",
    "!doc": "A registry to combine library definitions and library instance.\n@constructor",
    "libraries": {
      "!span": "877[23:9]-886[23:18]",
      "!doc": "The map of incudes define each library. A single item is itself a map of exports and include definitions."
    },
    "instance": {
      "!span": "941[26:9]-949[26:17]",
      "!doc": "The maps of library instances."
    }
  },
  "getLockerSecret": {
    "!type": "fn(st: ?, type: string) -> !0.<i>.!ret",
    "!span": "639[17:4]-654[17:19]",
    "!doc": "jslint sub: true"
  },
  "setLockerSecret": {
    "!type": "fn(st: ?, type: string, secret: ?)",
    "!span": "656[17:21]-671[17:36]"
  },
  "lazyInitInlinedSafeEvalWorkaround": {
    "!type": "fn()",
    "!span": "781[20:9]-814[20:42]",
    "!doc": "DCHASMAN TODO Revert this after we clear issues with CKEditor and unsafe inline from W-3028925"
  },
  "LockerService": {
    "!type": "fn() -> AuraInstance.lockerService",
    "!span": "683[19:9]-696[19:22]",
    "!doc": "#include aura.locker.InlineSafeEval"
  },
  "SecureAction": {
    "!type": "fn(action: ?, key: ?)",
    "!span": "622[16:9]-634[16:21]",
    "!doc": "Copyright (C) 2013 salesforce.com, inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
  },
  "SecureAura": {
    "!type": "fn(AuraInstance: ?|+AuraInstance, key: SecureAura.!1) -> ?",
    "!span": "845[25:9]-855[25:19]",
    "!doc": "Factory for SecureAura objects.\n\n@param {Object}\n           AuraInstance - the Aura Instance to be secured\n@param {Object}\n           key - the key to apply to the secure aura"
  },
  "SecureAuraEvent": {
    "!type": "fn(event: ?, key: ?)",
    "!span": "622[16:9]-637[16:24]",
    "!doc": "Copyright (C) 2013 salesforce.com, inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
  },
  "SecureComponent": {
    "!type": "fn(component: ?, key: ?) -> !0.<i>.!ret",
    "!span": "643[17:9]-658[17:24]",
    "!doc": "jslint sub: true"
  },
  "SecureComponentRef": {
    "!type": "fn(component: ?, key: ?)",
    "!span": "643[17:9]-661[17:27]",
    "!doc": "jslint sub: true"
  },
  "SecureDocument": {
    "!type": "fn(doc: +Document, key: SecureAura.!1) -> SecureDocument.!ret",
    "!span": "821[26:9]-835[26:23]",
    "!doc": "Factory for SecureDocument objects.\n\n@public\n\n@param {Object}\n           doc - the DOM document\n@param {Object}\n           key - the key to apply to the secure document"
  },
  "SecureDOMEvent": {
    "filterTouchesDescriptor": {
      "!type": "fn(se: SecureDOMEvent.!ret, event: ?, propName: string) -> SecureDOMEvent.filterTouchesDescriptor.!ret",
      "!span": "2698[71:15]-2721[71:38]"
    },
    "!type": "fn(event: ?, key: SecureAura.!1) -> SecureDOMEvent.!ret",
    "!span": "622[16:9]-636[16:23]",
    "!doc": "Copyright (C) 2013 salesforce.com, inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
  },
  "SecureElement": {
    "addSecureProperties": {
      "!type": "fn(se: SecureIFrameElement.!ret, raw: ?)",
      "!span": "7095[265:14]-7114[265:33]"
    },
    "addSecureGlobalEventHandlers": {
      "!type": "fn(se: ?, raw: ?, key: SecureAura.!1)",
      "!span": "8318[293:14]-8346[293:42]"
    },
    "addEventTargetMethods": {
      "!type": "fn(se: ?, raw: ?, key: SecureAura.!1)",
      "!span": "9001[310:14]-9022[310:35]"
    },
    "createAddEventListenerDescriptor": {
      "!type": "fn(st: ?, el: ?, key: SecureAura.!1) -> SecureElement.createAddEventListenerDescriptor.!ret",
      "!span": "9635[327:14]-9667[327:46]"
    },
    "createAddEventListener": {
      "!type": "fn(st: ?, el: ?, key: ?) -> fn(event: ?, callback: ?, useCapture: ?)",
      "!span": "10389[357:14]-10411[357:36]"
    },
    "addElementSpecificProperties": {
      "!type": "fn(se: SecureIFrameElement.!ret, el: ?)",
      "!span": "10773[373:14]-10801[373:42]"
    },
    "addElementSpecificMethods": {
      "!type": "fn(se: SecureIFrameElement.!ret, el: ?)",
      "!span": "11336[392:14]-11361[392:39]"
    },
    "secureQuerySelector": {
      "!type": "fn(st: SecureIFrameElement.!ret|SecureDocument.!ret, el: ?, key: SecureAura.!1, selector: ?) -> SecureIFrameElement.!ret",
      "!span": "11704[406:14]-11723[406:33]"
    },
    "elementSpecificAttributeAllowlists": {
      "A": {
        "!type": "[string]",
        "!span": "12389[428:1]-12392[428:4]"
      },
      "AREA": {
        "!type": "[string]",
        "!span": "12488[429:1]-12494[429:7]"
      },
      "AUDIO": {
        "!type": "[string]",
        "!span": "12594[430:1]-12601[430:8]"
      },
      "BASE": {
        "!type": "[string]",
        "!span": "12700[431:1]-12706[431:7]"
      },
      "BDO": {
        "!type": "[string]",
        "!span": "12732[432:1]-12737[432:6]"
      },
      "BUTTON": {
        "!type": "[string]",
        "!span": "12752[433:1]-12760[433:9]"
      },
      "CANVAS": {
        "!type": "[string]",
        "!span": "12892[434:1]-12900[434:9]"
      },
      "COL": {
        "!type": "[string]",
        "!span": "12927[435:1]-12932[435:6]"
      },
      "COLGROUP": {
        "!type": "[string]",
        "!span": "12948[436:1]-12958[436:11]"
      },
      "DATA": {
        "!type": "[string]",
        "!span": "12983[437:1]-12989[437:7]"
      },
      "DEL": {
        "!type": "[string]",
        "!span": "13006[438:1]-13011[438:6]"
      },
      "DETAILS": {
        "!type": "[string]",
        "!span": "13039[439:1]-13048[439:10]"
      },
      "EMBED": {
        "!type": "[string]",
        "!span": "13064[440:1]-13071[440:8]"
      },
      "FIELDSET": {
        "!type": "[string]",
        "!span": "13113[441:1]-13123[441:11]"
      },
      "FORM": {
        "!type": "[string]",
        "!span": "13159[442:1]-13165[442:7]"
      },
      "IMG": {
        "!type": "[string]",
        "!span": "13269[443:1]-13274[443:6]"
      },
      "INPUT": {
        "!type": "[string]",
        "!span": "13390[444:1]-13397[444:8]"
      },
      "INS": {
        "!type": "[string]",
        "!span": "13792[447:1]-13797[447:6]"
      },
      "LABEL": {
        "!type": "[string]",
        "!span": "13825[448:1]-13832[448:8]"
      },
      "LI": {
        "!type": "[string]",
        "!span": "13868[449:1]-13872[449:5]"
      },
      "LINK": {
        "!type": "[string]",
        "!span": "13889[450:1]-13895[450:7]"
      },
      "MAP": {
        "!type": "[string]",
        "!span": "13980[451:1]-13985[451:6]"
      },
      "META": {
        "!type": "[string]",
        "!span": "14108[455:1]-14114[455:7]",
        "!doc": "DCHASMAN TODO Fix SecureElement.setAttribute() hole and allowlist values\nfor http-equiv/httpEquiv"
      },
      "METER": {
        "!type": "[string]",
        "!span": "14142[457:1]-14149[457:8]"
      },
      "OBJECT": {
        "!type": "[string]",
        "!span": "14214[458:1]-14222[458:9]"
      },
      "OL": {
        "!type": "[string]",
        "!span": "14310[459:1]-14314[459:5]"
      },
      "OPTGROUP": {
        "!type": "[string]",
        "!span": "14351[460:1]-14361[460:11]"
      },
      "OPTION": {
        "!type": "[string]",
        "!span": "14390[461:1]-14398[461:9]"
      },
      "OUTPUT": {
        "!type": "[string]",
        "!span": "14448[462:1]-14456[462:9]"
      },
      "PARAM": {
        "!type": "[string]",
        "!span": "14487[463:1]-14494[463:8]"
      },
      "PROGRESS": {
        "!type": "[string]",
        "!span": "14519[464:1]-14529[464:11]"
      },
      "Q": {
        "!type": "[string]",
        "!span": "14553[465:1]-14556[465:4]"
      },
      "SELECT": {
        "!type": "[string]",
        "!span": "14572[466:1]-14580[466:9]"
      },
      "SOURCE": {
        "!type": "[string]",
        "!span": "14661[467:1]-14669[467:9]"
      },
      "TD": {
        "!type": "[string]",
        "!span": "14692[468:1]-14696[468:5]"
      },
      "TEMPLATE": {
        "!type": "[string]",
        "!span": "14737[469:1]-14747[469:11]"
      },
      "TEXTAREA": {
        "!type": "[string]",
        "!span": "14766[470:1]-14776[470:11]"
      },
      "TH": {
        "!type": "[string]",
        "!span": "14989[472:1]-14993[472:5]"
      },
      "TIME": {
        "!type": "[string]",
        "!span": "15043[473:1]-15049[473:7]"
      },
      "TRACK": {
        "!type": "[string]",
        "!span": "15069[474:1]-15076[474:8]"
      },
      "VIDEO": {
        "!type": "[string]",
        "!span": "15130[475:1]-15137[475:8]"
      },
      "!span": "12349[427:14]-12383[427:48]"
    },
    "elementSpecificMethodAllowlists": {
      "AUDIO": {
        "!type": "[string]",
        "!span": "15323[479:1]-15330[479:8]"
      },
      "CANVAS": {
        "!type": "[string]",
        "!span": "15422[480:1]-15430[480:9]"
      },
      "SVG": {
        "!type": "[string]",
        "!span": "15475[481:1]-15480[481:6]"
      },
      "VIDEO": {
        "!type": "[string]",
        "!span": "15505[482:1]-15512[482:8]"
      },
      "!span": "15286[478:14]-15317[478:45]"
    },
    "!type": "fn(el: ?, key: SecureAura.!1) -> SecureIFrameElement.!ret",
    "!span": "644[18:9]-657[18:22]",
    "!doc": "jslint sub: true"
  },
  "SecureIFrameElement": {
    "!type": "fn(el: ?, key: SecureAura.!1) -> SecureIFrameElement.!ret",
    "!span": "622[16:9]-641[16:28]",
    "!doc": "Copyright (C) 2013 salesforce.com, inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
  },
  "SecureNavigator": {
    "!type": "fn(navigator: navigator, key: SecureAura.!1) -> ?",
    "!span": "881[30:9]-896[30:24]",
    "!doc": "Construct a SecureNavigator.\n\n@public\n@class\n@constructor\n\n@param {Object}\n           navigator - the global navigator object\n@param {Object}\n           key - the key to apply to the secure navigator"
  },
  "SecureObject": {
    "isDOMElementOrNode": {
      "!type": "fn(el: ?) -> bool",
      "!span": "991[36:13]-1009[36:31]"
    },
    "addToCache": {
      "!type": "fn(raw: ?, so: ?, key: ?)",
      "!span": "1520[57:13]-1530[57:23]"
    },
    "getCached": {
      "!type": "fn(raw: ?, key: ?)",
      "!span": "1917[69:13]-1926[69:22]"
    },
    "filterEverything": {
      "!type": "fn(st: ?, raw: ?, options: ?) -> !1",
      "!span": "2161[75:13]-2177[75:29]"
    },
    "unfilterEverything": {
      "!type": "fn(st: ?, value: [?], visited: rawToSecureObjectCaches.<i>) -> !1",
      "!span": "5804[194:13]-5822[194:31]"
    },
    "createFilteredMethod": {
      "!type": "fn(st: ?, raw: ?, methodName: string, options: ?) -> SecureObject.createFilteredMethod.!ret",
      "!span": "7879[271:13]-7899[271:33]"
    },
    "createFilteredProperty": {
      "!type": "fn(st: ?, raw: ?, propertyName: ?, options: ?) -> SecureObject.createFilteredProperty.!ret",
      "!span": "8809[304:13]-8831[304:35]"
    },
    "addIfSupported": {
      "!type": "fn(behavior: fn(st: ?, raw: ?, propertyName: ?, options: ?) -> SecureObject.createFilteredProperty.!ret|fn(st: ?, raw: ?, methodName: string, options: ?) -> SecureObject.createFilteredMethod.!ret, st: ?, element: ?, name: string, options: ?)",
      "!span": "9902[348:13]-9916[348:27]"
    },
    "addPropertyIfSupported": {
      "!type": "fn(st: ?, raw: ?, name: string, options: ?)",
      "!span": "10154[358:13]-10176[358:35]"
    },
    "addMethodIfSupported": {
      "!type": "fn(st: ?, raw: ?, name: string, options: ?)",
      "!span": "10322[362:13]-10342[362:33]"
    },
    "FunctionPrototypeBind": {
      "!type": "fn(scope: ?) -> fn() -> number|?|+Function",
      "!span": "10486[366:13]-10507[366:34]",
      "!doc": "Add the Function.bind method for JS engines that don't support it (e.g. IE)\n\n@param {Object} scope - callback scope\n@returns {Function}"
    },
    "ArrayPrototypeSlice": {
      "!type": "fn(from?: number, to?: number) -> !this",
      "!span": "10548[367:13]-10567[367:32]"
    },
    "!type": "fn(thing: ?, key: ?)",
    "!span": "643[17:9]-655[17:21]",
    "!doc": "jslint sub: true"
  },
  "newWeakMap": {
    "!type": "fn() -> rawToSecureObjectCaches.<i>",
    "!span": "1286[45:9]-1296[45:19]"
  },
  "rawToSecureObjectCaches": {
    "<i>": {
      "get": {
        "!type": "fn()",
        "!span": "1394[48:2]-1399[48:7]",
        "!doc": "WeakMap dummy polyfill"
      },
      "set": {
        "!type": "fn()",
        "!span": "1443[51:2]-1448[51:7]"
      },
      "!span": "1815[63:26]-1830[63:41]"
    },
    "!span": "1476[55:4]-1499[55:27]"
  },
  "SecureScriptElement": {
    "!type": "fn(key: SecureAura.!1, el: ?) -> SecureElement.!ret",
    "!span": "645[18:9]-664[18:28]",
    "!doc": "jslint sub: true"
  },
  "SecureWindow": {
    "!type": "fn(win: <top>, key: SecureAura.!1, globalAttributeAllowlist: [string]) -> SecureWindow.!ret",
    "!span": "856[30:9]-868[30:21]",
    "!doc": "Construct a SecureWindow.\n\n@public\n@class\n@constructor\n\n@param {Object}\n           win - the DOM window\n@param {Object}\n           key - the key to apply to the secure window"
  },
  "SecureXMLHttpRequest": {
    "!type": "fn(key: SecureAura.!1) -> fn() -> SecureElement.createAddEventListenerDescriptor.!0",
    "!span": "861[30:9]-881[30:29]",
    "!doc": "Construct a SecureXMLHttpRequest.\n\n@public\n@class\n@constructor\n\n@param {Object}\n           xhr - the xhr object\n@param {Object}\n           key - the key to apply to the secure xhr"
  },
  "Logger": {
    "prototype": {
      "info": {
        "!type": "fn(info: string, error?: +Error)",
        "!span": "1307[49:17]-1311[49:21]",
        "!doc": "Info log\n\n@param {String} info message\n@param {Error} [error] error\n@export"
      },
      "warning": {
        "!type": "fn(warning: string, error?: +Error)",
        "!span": "1501[60:17]-1508[60:24]",
        "!doc": "Warning log\n\n@param {String} warning message\n@param {Error} [error] error\n@export"
      },
      "assert": {
        "!type": "fn(condition: bool, assertMessage: string)",
        "!span": "1784[71:17]-1790[71:23]",
        "!doc": "Checks condition and logs message when condition is falsy\n\n@param {Boolean} condition check\n@param {String} assertMessage message when assertion fails\n@export"
      },
      "error": {
        "!type": "fn(msg: string, e?: string|+Error)",
        "!span": "2200[86:17]-2205[86:22]",
        "!doc": "Error log and shows dialog window with error message. Also displays stack unless in production\n\n@param {String} msg error message\n@param {Error} [e] error\n@deprecated\n@export"
      },
      "reportError": {
        "!type": "fn(e: ?, action: ?)",
        "!span": "4272[153:17]-4283[153:28]"
      },
      "log": {
        "!type": "fn(level: string, message: string, error?: +Error)",
        "!span": "5826[194:17]-5829[194:20]",
        "!doc": "Checks for subscribers and notifies\n\n@param {String} level log level\n@param {String} message log message\n@param {Error} [error]"
      },
      "notify": {
        "!type": "fn(level: string, msg: string|?, error?: +Error)",
        "!span": "6160[207:17]-6166[207:23]",
        "!doc": "Loops through subscribers and applies arguments to provider callback\n\n@param {String} level log level\n@param {String} message log message\n@param {Error} [error]"
      },
      "getStackTrace": {
        "!type": "fn(e: +Error, remove?: number) -> string",
        "!span": "6708[226:17]-6721[226:30]",
        "!doc": "Returns the stack trace, including the functions on the stack if available (Error object varies across browsers).\nValues are not logged.\n\n@param {Error} e error\n@param {Number} [remove]\n@returns {String|null} stack\n@export"
      },
      "stringVersion": {
        "!type": "fn(logMsg: string, error: +Error, trace: [?]) -> !0",
        "!span": "7791[270:17]-7804[270:30]",
        "!doc": "Stringify a log message.\n\n@param {String} logMsg message\n@param {Error} error\n@param {Array} trace\n@returns {String} string log\n@export"
      },
      "subscribe": {
        "!type": "fn(level: string, callback: +Function)",
        "!span": "8438[289:17]-8447[289:26]",
        "!doc": "Adds subscriber. Callback function will be called when log of level specified occurs.\nEach level requires a subscription.\n\n@param {String} level log level\n@param {Function} callback function\n@export"
      },
      "unsubscribe": {
        "!type": "fn(level: string, callback: +Function)",
        "!span": "8896[307:17]-8907[307:28]",
        "!doc": "Removes subscription. Each level needs to be unsubscribed separately\n\n@param {String} level log level\n@param {Function} callback function\n@export"
      },
      "adjustSubscriptions": {
        "!type": "fn(level: string, adjustment: number)",
        "!span": "9533[327:17]-9552[327:36]",
        "!doc": "Adjust log level subscription numbers\n\n@param {String} level level to adjust\n@param {Number} adjustment Number to adjust subscription"
      },
      "isValidSubscriber": {
        "!type": "fn(level: string, callback: +Function) -> bool",
        "!span": "9826[338:17]-9843[338:34]",
        "!doc": "Checks and throws Error if not valid subscriber\n\n@param {String} level log level\n@param {Function} callback function\n@returns {boolean} Valid subscriber"
      },
      "isValidLevel": {
        "!type": "fn(level: string) -> bool",
        "!span": "10150[350:17]-10162[350:29]",
        "!doc": "Checks whether level is valid\n@param {String} level log level\n@returns {boolean}"
      },
      "hasSubscriptions": {
        "!type": "fn(level: string) -> bool",
        "!span": "10621[367:17]-10637[367:33]",
        "!doc": "Returns number of subscriptions for given level\n\n@param {String} level\n@returns {boolean} Whether there are subscriptions to given level\n@export"
      },
      "devDebugConsoleLog": {
        "!type": "fn(level: ?, message: ?, error: ?)",
        "!span": "10961[379:17]-10979[379:35]",
        "!doc": "Prints log to both the console (if available), and to the aura debug component\n@private"
      }
    },
    "!type": "fn()",
    "!span": "851[28:9]-857[28:15]",
    "!doc": "Logger implementation providing log messages to subscribers\n\nSubscriptions are made individually to each log level\n\n@namespace\n@constructor\n@export",
    "subscribers": {
      "!type": "[Logger.subscribers.<i>]",
      "!span": "871[29:9]-882[29:20]"
    },
    "INFO": {
      "!type": "string",
      "!span": "898[30:9]-902[30:13]"
    },
    "WARNING": {
      "!type": "string",
      "!span": "922[31:9]-929[31:16]"
    },
    "ASSERT": {
      "!type": "string",
      "!span": "952[32:9]-958[32:15]"
    },
    "ERROR": {
      "!type": "string",
      "!span": "980[33:9]-985[33:14]"
    },
    "subscriptions": {
      "<i>": {
        "!type": "number",
        "!span": "1050[36:23]-1059[36:32]"
      },
      "!span": "1007[35:9]-1020[35:22]"
    }
  },
  "AttributeDefSet": {
    "prototype": {
      "each": {
        "!type": "fn(f: +Function)",
        "!span": "1618[46:26]-1622[46:30]",
        "!doc": "For each AttributeDef value, pass it into the given function.\n@param {Function} f The function to pass the values into.\n@export"
      },
      "getDef": {
        "!type": "fn(name: string) -> !this.values",
        "!span": "2167[62:26]-2173[62:32]",
        "!doc": "Returns the AttributeDef object.\n@param {String} name The name of the AttributeDef instance, which matches the qualified name of the attributeDef descriptor.\n@returns {AttributeDef} An AttributeDef object is stored in a parent definition, such as a ComponentDef object.\n@export"
      },
      "getNames": {
        "!type": "fn() -> !this.valuesOrder",
        "!span": "2463[73:26]-2471[73:34]",
        "!doc": "Get the set of names in the attribute def set.\n\nThis provides access to an array, instead of having to walk the map.\n\n@return {Array} the array of names."
      },
      "getValues": {
        "!type": "fn() -> !this.values",
        "!span": "2614[81:26]-2623[81:35]",
        "!doc": "Returns map of AttributeDefs\n@returns {Object} values"
      }
    },
    "!type": "fn(configs: ?, defaultNamespace: string)",
    "!span": "846[23:9]-861[23:24]",
    "!doc": "@description Creates a new AttributeDefSet instance.\n@param {Object} configs For each configs object provided, a new AttributeDef instance is added\n@constructor\n@protected\n@export",
    "values": {
      "<i>": {
        "!type": "+AttributeDef",
        "!span": "1365[35:24]-1369[35:28]"
      },
      "!span": "922[25:13]-928[25:19]"
    },
    "valuesOrder": {
      "!type": "[?]",
      "!span": "984[27:13]-995[27:24]",
      "!doc": "maintain attribute order"
    }
  },
  "AuraContextPlugin": {
    "NAME": {
      "!type": "string",
      "!span": "1089[32:18]-1093[32:22]"
    },
    "prototype": {
      "initialize": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "1155[35:28]-1165[35:38]",
        "!doc": "@export"
      },
      "enable": {
        "!type": "fn()",
        "!span": "1349[44:28]-1355[44:34]",
        "!doc": "@export"
      },
      "disable": {
        "!type": "fn()",
        "!span": "1520[52:28]-1527[52:35]",
        "!doc": "@export"
      },
      "bind": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "1679[59:28]-1683[59:32]"
      },
      "postProcess": {
        "!type": "fn(transportMarks: ?) -> !0",
        "!span": "2908[106:28]-2919[106:39]",
        "!doc": "@export"
      },
      "unbind": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "3016[111:28]-3022[111:34]",
        "!doc": "#end"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "922[27:4]-939[27:21]",
    "!doc": "AuraContextPlugin\n=================\nThis plugin hooks into the Aura Context object.\nIn particular the following methods:\nmerge(): Tracks the component defs that are sent dynamically to the client.\n\n@description AuraContextPlugin\n@constructor\n@export"
  },
  "ComponentServiceMetricsPlugin": {
    "NAME": {
      "!type": "string",
      "!span": "1148[32:30]-1152[32:34]"
    },
    "prototype": {
      "initialize": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "1231[35:40]-1241[35:50]",
        "!doc": "@export"
      },
      "enable": {
        "!type": "fn()",
        "!span": "1442[44:40]-1448[44:46]",
        "!doc": "@export"
      },
      "disable": {
        "!type": "fn()",
        "!span": "1630[52:40]-1637[52:47]",
        "!doc": "@export"
      },
      "createComponentOverride": {
        "!type": "fn()",
        "!span": "1806[59:40]-1829[59:63]"
      },
      "bind": {
        "!type": "fn()",
        "!span": "2473[71:40]-2477[71:44]"
      },
      "postProcess": {
        "!type": "fn(componentMarks: ?) -> [ComponentServiceMetricsPlugin.prototype.postProcess.!ret.<i>]",
        "!span": "2693[77:40]-2704[77:51]",
        "!doc": "@export"
      },
      "unbind": {
        "!type": "fn()",
        "!span": "3502[97:40]-3508[97:46]",
        "!doc": "#end"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "944[27:4]-973[27:33]",
    "!doc": "ComponentServiceMetricsPlugin\n=================\nThis plugin hooks into the ComponentService.\nIn particular the following methods:\ncreateComponentPriv(): Tracks the component creation time for all components\n\n@description ComponentServiceMetricsPlugin\n@constructor\n@export"
  },
  "DomHandlersPlugin": {
    "NAME": {
      "!type": "string",
      "!span": "1109[33:18]-1113[33:22]"
    },
    "ALLOWLISTEVENTS": {
      "click": {
        "!type": "bool",
        "!span": "1174[35:4]-1181[35:11]"
      },
      "!span": "1149[34:18]-1164[34:33]"
    },
    "prototype": {
      "initialize": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "1258[39:28]-1268[39:38]",
        "!doc": "@export"
      },
      "enable": {
        "!type": "fn()",
        "!span": "1457[48:28]-1463[48:34]",
        "!doc": "@export"
      },
      "disable": {
        "!type": "fn()",
        "!span": "1633[56:28]-1640[56:35]",
        "!doc": "@export"
      },
      "dispatchActionHook": {
        "!type": "fn(action: ?, event: ?, cmp: ?)",
        "!span": "1797[63:28]-1815[63:46]"
      },
      "dispatchVirtualActionHook": {
        "!type": "fn(action: ?, event: ?, virtualCmp: ?)",
        "!span": "3010[94:28]-3035[94:53]"
      },
      "bind": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "3274[101:28]-3278[101:32]"
      },
      "postProcess": {
        "!type": "fn(transportMarks: ?) -> !0",
        "!span": "5849[172:28]-5860[172:39]",
        "!doc": "@export"
      },
      "unbind": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "5957[177:28]-5963[177:34]",
        "!doc": "#end"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "976[28:4]-993[28:21]",
    "!doc": "DomHandlersPlugin\n=================\nThis plugin hooks into the definition of aura:html component.\nIn particular the following methods:\ndispatchAction(): Tracks all interactions (click, mouseovers, any DOM handlers)\nhandled by any active component\n\n@description DomHandlersPlugin\n@constructor\n@export"
  },
  "PerfMetricsPlugin": {
    "NAME": {
      "!type": "string",
      "!span": "1111[32:18]-1115[32:22]"
    },
    "prototype": {
      "initialize": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "1164[34:4]-1174[34:14]",
        "!doc": "Exposing symbols/methods for Google Closure"
      },
      "enable": {
        "!type": "fn()",
        "!span": "1336[40:4]-1342[40:10]"
      },
      "enabled": {
        "!type": "bool",
        "!span": "1407[42:17]-1416[42:26]"
      },
      "disable": {
        "!type": "fn()",
        "!span": "1486[46:4]-1493[46:11]"
      },
      "processResponsesOverride": {
        "!type": "fn()",
        "!span": "1639[52:4]-1663[52:28]"
      },
      "bind": {
        "!type": "fn()",
        "!span": "2318[69:4]-2322[69:8]"
      },
      "postProcess": {
        "!type": "fn(markList: ?) -> !0",
        "!span": "2492[73:4]-2503[73:15]",
        "!doc": "#if {\"excludeModes\" : [\"PRODUCTION\"]}"
      },
      "unbind": {
        "!type": "fn()",
        "!span": "2575[77:4]-2581[77:10]",
        "!doc": "#end"
      },
      "!span": "1146[33:18]-1155[33:27]",
      "collector": "+Aura.Services.MetricsService"
    },
    "!type": "fn(config: ?)",
    "!span": "978[27:4]-995[27:21]",
    "!doc": "PerfMetricsPlugin\n=================\nThis plugin hooks into the ClientService.\nIn particular the following methods:\nprocessResponses(): Gets the performance metrics sent from the server\nand creates a mark so transactions can leverage all this information\n\n@description Transport metrics plugin\n@constructor"
  },
  "QueuedActionsMetricsPlugin": {
    "NAME": {
      "!type": "string",
      "!span": "1006[29:27]-1010[29:31]"
    },
    "prototype": {
      "initialize": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "1077[32:37]-1087[32:47]",
        "!doc": "@export"
      },
      "enable": {
        "!type": "fn()",
        "!span": "1284[40:37]-1290[40:43]",
        "!doc": "@export"
      },
      "disable": {
        "!type": "fn()",
        "!span": "1469[48:37]-1476[48:44]",
        "!doc": "@export"
      },
      "enqueueActionOverride": {
        "!type": "fn()",
        "!span": "1642[55:37]-1663[55:58]"
      },
      "actionSendOverride": {
        "!type": "fn()",
        "!span": "2377[75:37]-2395[75:55]"
      },
      "actionFinishOverride": {
        "!type": "fn()",
        "!span": "2892[89:37]-2912[89:57]"
      },
      "markStart": {
        "!type": "fn(action: ?)",
        "!span": "3282[100:37]-3291[100:46]"
      },
      "markEnd": {
        "!type": "fn(action: ?)",
        "!span": "3847[114:37]-3854[114:44]"
      },
      "bind": {
        "!type": "fn()",
        "!span": "4180[123:37]-4184[123:41]"
      },
      "postProcess": {
        "!type": "fn(actionMarks: ?, trxConfig: ?) -> [QueuedActionsMetricsPlugin.prototype.postProcess.!ret.<i>]",
        "!span": "4589[135:37]-4600[135:48]",
        "!doc": "@export"
      },
      "unbind": {
        "!type": "fn()",
        "!span": "5738[166:37]-5744[166:43]"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "846[24:4]-872[24:30]",
    "!doc": "QueuedActionsMetricsPlugin\n=================\nThis plugin tracks the state and result of all actions from the framework\n@description Queued Action metrics plugin\n@constructor\n@export"
  },
  "TransportMetricsPlugin": {
    "NAME": {
      "!type": "string",
      "!span": "983[29:23]-987[29:27]"
    },
    "AURA_URL": {
      "!type": "string",
      "!span": "1101[31:23]-1109[31:31]"
    },
    "prototype": {
      "initialize": {
        "!type": "fn(metricsService: +Aura.Services.MetricsService)",
        "!span": "1202[34:33]-1212[34:43]",
        "!doc": "@export"
      },
      "enable": {
        "!type": "fn()",
        "!span": "1405[42:33]-1411[42:39]",
        "!doc": "@export"
      },
      "disable": {
        "!type": "fn()",
        "!span": "1586[50:33]-1593[50:40]",
        "!doc": "@export"
      },
      "sendOverride": {
        "!type": "fn()",
        "!span": "1755[57:33]-1767[57:45]"
      },
      "receiveOverride": {
        "!type": "fn()",
        "!span": "2727[83:33]-2742[83:48]"
      },
      "bind": {
        "!type": "fn()",
        "!span": "3790[106:33]-3794[106:37]"
      },
      "postProcess": {
        "!type": "fn(transportMarks: ?) -> [TransportMetricsPlugin.prototype.postProcess.!ret.<i>]",
        "!span": "4011[112:33]-4022[112:44]",
        "!doc": "@export"
      },
      "unbind": {
        "!type": "fn()",
        "!span": "4834[133:33]-4840[133:39]"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "835[24:4]-857[24:26]",
    "!doc": "TransportMetricsPlugin\n=================\nThis plugin tracks information about all XHRs done to the aura servlet\n@description Transport metrics plugin\n@constructor\n@export"
  },
  "Model": {
    "prototype": {
      "get": {
        "!type": "fn(key: ?) -> Model.data",
        "!span": "1212[39:16]-1215[39:19]"
      },
      "set": {
        "!type": "fn(key: ?, value: ?)",
        "!span": "1524[52:16]-1527[52:19]"
      },
      "destroy": {
        "!type": "fn()",
        "!span": "2056[70:16]-2063[70:23]"
      }
    },
    "!type": "fn(def: +ModelDef, data: ?, component: +Component) -> +Function",
    "!span": "811[24:9]-816[24:14]",
    "!doc": "@description Creates a Model instance.\n@constructor\n@param {Object} def\n@param {Object} data\n@param {Component} component\n@returns {Function}",
    "def": {
      "!type": "+ModelDef",
      "!span": "849[25:9]-852[25:12]"
    },
    "data": {
      "!span": "867[26:9]-871[26:13]"
    }
  },
  "ModelDef": {
    "prototype": {
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "1138[36:19]-1151[36:32]",
        "!doc": "Gets the descriptor. (e.g. markup://foo:bar)\n@returns {DefDescriptor}"
      },
      "newInstance": {
        "!type": "fn(config: ?, component: +Component) -> +Function|+Model",
        "!span": "1355[46:19]-1366[46:30]",
        "!doc": "Returns a new Model instance for this component.\n@param {Object} config\n@param {Component} component\n@returns {Model}"
      },
      "getMembers": {
        "!type": "fn() -> !this.members",
        "!span": "1556[54:19]-1566[54:29]",
        "!doc": "Gets member value defs containing ValueDef and TypeDef.\n@returns {Object}"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "727[21:9]-735[21:17]",
    "!doc": "@description Creates a new ModelDef instance.\n@constructor\n@export",
    "members": {
      "!type": "[+ValueDef]",
      "!span": "817[23:9]-824[23:16]"
    }
  },
  "ValueDef": {
    "prototype": {
      "getName": {
        "!type": "fn() -> !this.name",
        "!span": "922[28:19]-929[28:26]",
        "!doc": "Returns the name of the ValueDef instance."
      }
    },
    "!type": "fn(config: ?)",
    "!span": "796[21:9]-804[21:17]",
    "!doc": "@description Creates a ValueDef instance.\n@constructor\n@param config used to create the value definition.  Only config[\"name\"] is used."
  },
  "Json": {
    "prototype": {
      "decode": {
        "!type": "fn(json: string, refSupport: ?)",
        "!span": "1333[40:15]-1339[40:21]",
        "!doc": "Decode a JSON string into an object, optionally using ref support to resolve\nduplicate object references.\n\nIMPORTANT: this function should NEVER be exported, as the eval()\nimplementation provides a public API for executing arbitrary code inside our\ndomain security context. If we decide we need to supply a JSON utility\nfunction to consumers in the future, it should use the new window.JSON\nsupport provided by newer browsers.\n\n@param {String} json\n@param {Object} refSupport"
      },
      "decodeString": {
        "!type": "fn(value: string) -> !0",
        "!span": "2035[62:15]-2047[62:27]",
        "!doc": "After the JSON data is decoded by Browser native JSON object, the resulted\nobject (or sub-object) property's value could be a function/array/object/ and\nso on in string format. We need to convert them to the desired type.\n\n@param {String} value The string to be decoded\n@returns {Function|Array|Object} The converted value"
      },
      "resolveRefsObject": {
        "!type": "fn(obj: Json.prototype.resolveRefsObject.!0) -> !0",
        "!span": "2679[80:15]-2696[80:32]",
        "!doc": "Convert a serialized state blob, which is returned from a server action, which\ncontains internal serId and serRefId markers, into a new data structure that\nhas internal JavaScript pointers to the same object. Component definitions are\nextracted and placed into <code>context.componentDefs</code>.\n\n@param {Object} obj The object to resolve. It is modified in-place."
      },
      "resolveRefsArray": {
        "!type": "fn(arr: [Json.prototype._resolveRefs.!1.<i>]) -> !0",
        "!span": "3812[112:15]-3828[112:31]",
        "!doc": "Convert a serialized state blob, with its internal serId and serRefId\nmarkers, into a new data structure that has internal JavaScript pointers\nto the same object. Component definitions are extracted and placed at\nthe front of the array.\n\n@param {Array} arr The array to resolve. It is modified in-place."
      },
      "_resolveRefs": {
        "!type": "fn(config: Json.prototype._resolveRefs.!1.<i>|[Json.prototype._resolveRefs.!1.<i>], cache: ?, parent: Json.prototype._resolveRefs.!1.<i>|[Json.prototype._resolveRefs.!1.<i>], property: number|Json.prototype._resolveRefs.!1.<i>, collector: [Json.prototype._resolveRefs.!1.<i>])",
        "!span": "4083[120:15]-4095[120:27]"
      },
      "encode": {
        "!type": "fn(obj: ?, replacer: ?, whiteSpace: string) -> string",
        "!span": "7822[208:15]-7828[208:21]",
        "!doc": "Encodes an object into a JSON representation.\n\n@param {Object} obj The object to pass in the encoder.\n@param {Object} replacer Optional function which passes key and value bound to the\n           object, and returns a stringified value.\n@param {String} whiteSpace Adds spaces or tabs to the resulting string. E.g. '\\t'\n           for tab"
      },
      "encodeFunction": {
        "!type": "fn(value: +Function) -> !0",
        "!span": "10129[277:15]-10143[277:29]",
        "!doc": "Encode function to String.\n\n@param {Function} value The function to be encoded."
      },
      "orderedEncode": {
        "!type": "fn(value: Action.params) -> string",
        "!span": "10448[289:15]-10461[289:28]",
        "!doc": "Serializes object in alphabetical ascending order. Sorts object keys during serialization.\n@param {Object} object to sort\n@returns {String} serialized object"
      }
    },
    "!type": "fn()",
    "!span": "737[20:9]-741[20:13]",
    "!doc": "@description A base class to enable JSON manipulation\n@constructor"
  },
  "lastTime": {
    "!type": "number",
    "!span": "731[22:4]-739[22:12]"
  },
  "vendors": {
    "!type": "[string]",
    "!span": "749[23:4]-756[23:11]"
  },
  "x": {
    "!type": "number",
    "!span": "797[24:8]-798[24:9]"
  },
  "ContextValueProvider": {
    "prototype": {
      "getValues": {
        "!type": "fn() -> ContextValueProvider.prototype.getValues.!ret",
        "!span": "913[30:31]-922[30:40]",
        "!doc": "returns $Global values\n\n@protected\n@return {Object} a copy of the internal store."
      },
      "getStorableValues": {
        "!type": "fn() -> !this.values",
        "!span": "1285[46:31]-1302[46:48]",
        "!doc": "Returns a storable set of values.\n\n@private\n@return {Object} a reference to the internal store."
      },
      "serializeForServer": {
        "!type": "fn() -> ContextValueProvider.prototype.serializeForServer.!ret",
        "!span": "1377[50:31]-1395[50:49]"
      },
      "merge": {
        "!type": "fn(values: ?)",
        "!span": "2029[74:31]-2034[74:36]",
        "!doc": "Merges $Global values.\n\nThe incoming values must be from the server. We have special handling here to ensure that the\nserver does not overwrite values that are on the client.\n\n@private\n@param {Object} values the new set of values to merge"
      },
      "get": {
        "!type": "fn(key: string) -> ?",
        "!span": "3903[122:31]-3906[122:34]",
        "!doc": "Find value. If no value found, throw\n\n@public\n@param {string} key - the key to retrieve\n@return {Object} - the assigned of (if not assigned) default value"
      },
      "set": {
        "!type": "fn(key: string, value: ?) -> !1",
        "!span": "4473[137:31]-4476[137:34]",
        "!doc": "set value by name. If no value item found, throw.  If not writable, throw\n\n@public\n@param {string} key - the name of the key (must exist and be writable)\n@param {Object} value - the value to set\n@return {Object} the value that was set."
      },
      "extract": {
        "!type": "fn(gv: ?) -> !0",
        "!span": "5517[163:31]-5524[163:38]",
        "!doc": "Extract the current value from the global value.\n\n@private\n@param {Object} the global value (keys = [ \"value\", \"defaultValue\", \"writable\" ]\n@return {Object} the value"
      }
    },
    "!type": "fn(values: ?)",
    "!span": "715[20:9]-735[20:29]",
    "!doc": "@description Context's Global ValueProvider.\n@constructor"
  },
  "GlobalValueProviders": {
    "prototype": {
      "STORAGE_KEY": {
        "!type": "string",
        "!span": "2659[68:31]-2670[68:42]",
        "!doc": "Persistent storage key for GVPs."
      },
      "MUTEX_KEY": {
        "!type": "string",
        "!span": "2814[74:31]-2823[74:40]",
        "!doc": "Key to use of the MutexLocker to guarantee atomic execution across tabs."
      },
      "LOADED_FROM_PERSISTENT_STORAGE": {
        "!type": "bool",
        "!span": "3070[83:31]-3100[83:61]",
        "!doc": "True if GVPs were loaded from persistent storage."
      },
      "merge": {
        "!type": "fn(gvps: ?, doNotPersist: bool)",
        "!span": "3278[92:31]-3283[92:36]",
        "!doc": "Merges new GVPs with existing and saves to storage\n\n@param {Object} gvps\n@param {Boolean} doNotPersist\n@protected"
      },
      "getStorage": {
        "!type": "fn() -> ?",
        "!span": "7032[190:31]-7042[190:41]",
        "!doc": "Wrapper to get storage.\n\n@return {Object} storage - undefined if no storage exists\n@private"
      },
      "loadFromStorage": {
        "!type": "fn(callback: fn())",
        "!span": "7302[203:31]-7317[203:46]",
        "!doc": "load GVPs from storage if available\n@private"
      },
      "load": {
        "!type": "fn(gvp: ?)",
        "!span": "8582[243:31]-8586[243:35]",
        "!doc": "Loads GVP config when from context\n\n@param {Object} gvp Global Value Providers\n@private"
      },
      "addValueProvider": {
        "!type": "fn(type: string, valueProvider: AuraInstance.context.contextGlobals)",
        "!span": "8913[258:31]-8929[258:47]",
        "!doc": "Adds a new global value provider.\n@param type The key to identify the valueProvider.\n@param valueProvider The valueProvider to add.\n@private"
      },
      "getValueProvider": {
        "!type": "fn(type: string) -> !this.valueProviders.<i>",
        "!span": "9607[275:31]-9623[275:47]",
        "!doc": "Returns value provider or empty ObjectValueProvider\n\n@param {String} type the key to identify the valueProvider\n@return {Object} ValueProvider\n@private"
      },
      "get": {
        "!type": "fn(expression: string|[string], callback: +Function) -> string",
        "!span": "9920[287:31]-9923[287:34]",
        "!doc": "Calls getValue for Value Object. Unwraps and calls callback if provided.\n\n@param {String} expression\n@param {Component} component\n@return {String} The value of expression\n@export"
      }
    },
    "!type": "fn(gvp: ?, initCallback: fn(gvps: ?|AuraInstance.context.globalValueProviders)|+Function)",
    "!span": "1359[34:9]-1379[34:29]",
    "!doc": "@description Global Value Provider. Holds global values: $Label, $Browser, $Locale, etc\n\nThe interface required of a global value provider is:\n<ul>\n  <li>merge: merge a set of values from the server (if values come from the server)\n  <li>get: get a single value from the GVP\n  <li>getStorableValues[optional] get a storable version of the GVP values\n  <li>getValues: get a set of values that can be exposed.\n  <li>set[optional]: set a value on the provider\n</ul>\n\n@param {Object} gvp an optional serialized GVP to load.\n@param {Function} initCallback an optional callback invoked after the GVP has finished its\n asynchronous initialization.\n@constructor\n@export"
  },
  "LabelQueue": {
    "prototype": {
      "getComponents": {
        "!type": "fn() -> !this.components",
        "!span": "939[30:21]-952[30:34]",
        "!doc": "Components getter\n@return {Component[]}"
      },
      "addComponent": {
        "!type": "fn(component: +Component)",
        "!span": "1116[38:21]-1128[38:33]",
        "!doc": "Add component to component array\n@param {Component} component - component to add"
      },
      "getReturnValues": {
        "!type": "fn() -> !this.returnValues",
        "!span": "1285[46:21]-1300[46:36]",
        "!doc": "SimpleValues getter\n@return {String[]} array of Strings"
      },
      "addReturnValue": {
        "!type": "fn(value: string)",
        "!span": "1440[54:21]-1454[54:35]",
        "!doc": "Add SimpleValue to return values\n@param {String} value"
      },
      "getCallbacks": {
        "!type": "fn() -> !this.callbacks",
        "!span": "1587[62:21]-1599[62:33]",
        "!doc": "Getter callbacks\n@return {Function[]}"
      },
      "addCallback": {
        "!type": "fn(callback: +Function)",
        "!span": "1721[70:21]-1732[70:32]",
        "!doc": "Add callback\n@param {Function} callback"
      },
      "setRequested": {
        "!type": "fn()",
        "!span": "1846[77:21]-1858[77:33]",
        "!doc": "Set requested flag"
      },
      "isRequested": {
        "!type": "fn() -> !this.requested",
        "!span": "1983[85:21]-1994[85:32]",
        "!doc": "Checks whether requested\n@return {Boolean}"
      },
      "reset": {
        "!type": "fn()",
        "!span": "2110[92:21]-2115[92:26]",
        "!doc": "Resets / Initializes queue variables"
      }
    },
    "!type": "fn()",
    "!span": "828[22:9]-838[22:19]",
    "!doc": "@description Label Queue. Holds the components and callbacks for a particular $Label.\nQueues request for the same $Label to make server calls efficient\n\n@constructor",
    "requested": {
      "!type": "bool",
      "!span": "1883[78:9]-1892[78:18]"
    },
    "components": {
      "!type": "[+Component]",
      "!span": "2140[93:9]-2150[93:19]"
    },
    "callbacks": {
      "!type": "[+Function]",
      "!span": "2166[94:9]-2175[94:18]"
    },
    "returnValues": {
      "!type": "[string]",
      "!span": "2191[95:9]-2203[95:21]"
    }
  },
  "LabelValueProvider": {
    "prototype": {
      "requestServerLabel": {
        "!type": "fn(section: string, name: string, callback?: +Function) -> string",
        "!span": "1196[35:29]-1214[35:47]",
        "!doc": "Performs LabelController.getLabel action to get specified section and name.\nSets up label queue so that server action for the same label is only requested once\n\n@param {String} section - label section\n@param {String} name - label section\n@param {Function} [callback] - callback\n@return {String}\n@private"
      },
      "getQueue": {
        "!type": "fn(section: string, name: string) -> !this.queue.<i>",
        "!span": "2927[94:29]-2935[94:37]",
        "!doc": "Gets queue for specified label\n\n@param {String} section - label section\n@param {String} name - label name\n@return {LabelQueue} queue for given label"
      },
      "removeQueue": {
        "!type": "fn(section: string, name: string)",
        "!span": "3275[107:29]-3286[107:40]",
        "!doc": "Removes label queue\n@param {String} section - label section\n@param {String} name - label name"
      },
      "getQueueKey": {
        "!type": "fn(section: string, name: string) -> string",
        "!span": "3538[117:29]-3549[117:40]",
        "!doc": "Gets label key in queue\n@param {String} section - label section\n@param {String} name - label name"
      },
      "getValues": {
        "!type": "fn() -> !this.values",
        "!span": "3677[124:29]-3686[124:38]",
        "!doc": "returns $Label values"
      },
      "merge": {
        "!type": "fn(values: ?)",
        "!span": "3791[131:29]-3796[131:34]",
        "!doc": "Merges $Label values"
      },
      "get": {
        "!type": "fn(expression: string, callback?: +Function) -> string",
        "!span": "4156[143:29]-4159[143:32]",
        "!doc": "Loops through existing values to find value. If no value found, send request to server\n\n@param {String} expression - expression\n@param {Component} [component] - component\n@param {Function} [callback] - callback\n@return {String}"
      }
    },
    "!type": "fn(values: ?)",
    "!span": "747[20:9]-765[20:27]",
    "!doc": "@description Label Provider. Performs server action to retrieve label values\n@constructor",
    "queue": {
      "<i>": {
        "!type": "+LabelQueue",
        "!span": "3058[97:19]-3061[97:22]"
      },
      "!span": "817[22:9]-822[22:14]"
    }
  },
  "ObjectValueProvider": {
    "prototype": {
      "getValues": {
        "!type": "fn() -> !this.values",
        "!span": "869[27:30]-878[27:39]",
        "!doc": "returns $GVP values"
      },
      "merge": {
        "!type": "fn(values: ?)",
        "!span": "1025[36:30]-1030[36:35]",
        "!doc": "Merges all values into the existing ones.\n\n@param values"
      },
      "get": {
        "!type": "fn(expression: string|[string], callback: +Function)",
        "!span": "1418[47:30]-1421[47:33]",
        "!doc": "Gets value and creates new simple value that references specified component.\n\n@param {String} expression used to compute the new values.\n@param {Function} callback called after creating the new values\n@return {Object} The value referenced by the expression."
      }
    },
    "!type": "fn(values: ?)",
    "!span": "743[20:9]-762[20:28]",
    "!doc": "@description Simple Value Provider. Holds generic map of Key/Value Pairs\n@constructor"
  },
  "RequiredVersionDef": {
    "prototype": {
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "1203[31:29]-1216[31:42]",
        "!doc": "Gets the descriptor. Returns a DefDescriptor object that contains the metadata for the attribute.\n@returns {DefDescriptor} The qualified name for a DefDescriptor object has the format <code>prefix://namespace:name</code>."
      },
      "getNamespace": {
        "!type": "fn() -> string",
        "!span": "1344[39:29]-1356[39:41]",
        "!doc": "Gets the namespace.\n@returns {String}"
      },
      "getVersion": {
        "!type": "fn() -> string",
        "!span": "1495[47:29]-1505[47:39]",
        "!doc": "Gets the version.\n@returns {String}"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "765[21:9]-783[21:27]",
    "!doc": "Creates a new RequiredVersionDef instance, including the descriptor.\n@constructor\n@param {Object} config"
  },
  "RequiredVersionDefSet": {
    "prototype": {
      "getDef": {
        "!type": "fn(name: string) -> !this.values.<i>",
        "!span": "1521[38:32]-1527[38:38]",
        "!doc": "Returns the RequiredVersionDef object.\n@param {String} name The name of the RequiredVersionDef instance, which matches the qualified name of the requiredVersionDef descriptor.\n@returns {RequiredVersionDef} An RequiredVersionDef object is stored in a parent definition, such as a ComponentDef object."
      }
    },
    "!type": "fn(configs: ?)",
    "!span": "834[22:9]-855[22:30]",
    "!doc": "Creates a new RequiredVersionDefSet instance.\n@param {Object} configs For each configs object provided, a new RequiredVersionDef instance is added\n@constructor\n@protected",
    "values": {
      "<i>": {
        "!type": "+RequiredVersionDef",
        "!span": "1127[28:24]-1129[28:26]"
      },
      "!span": "899[24:13]-905[24:19]"
    }
  },
  "CryptoAdapter": {
    "NAME": {
      "!type": "string",
      "!span": "3096[78:14]-3100[78:18]",
      "!doc": "Name of adapter."
    },
    "LOG_LEVEL": {
      "INFO": {
        "id": {
          "!type": "number",
          "!span": "3175[82:15]-3177[82:17]"
        },
        "fn": {
          "!type": "string",
          "!span": "3182[82:22]-3184[82:24]"
        },
        "!span": "3164[82:4]-3168[82:8]"
      },
      "WARNING": {
        "id": {
          "!type": "number",
          "!span": "3210[83:15]-3212[83:17]"
        },
        "fn": {
          "!type": "string",
          "!span": "3217[83:22]-3219[83:24]"
        },
        "!span": "3199[83:4]-3206[83:11]"
      },
      "!span": "3146[81:14]-3155[81:23]",
      "!doc": "Log levels"
    },
    "ALGO": {
      "!type": "string",
      "!span": "3281[88:14]-3285[88:18]",
      "!doc": "Encryption algorithm."
    },
    "IV_LENGTH": {
      "!type": "number",
      "!span": "3359[91:14]-3368[91:23]",
      "!doc": "Initialization vector length (bytes)."
    },
    "SENTINEL": {
      "!type": "string",
      "!span": "3459[94:14]-3467[94:22]",
      "!doc": "A sentinel value to verify the key against pre-existing data."
    },
    "setKey": {
      "!type": "fn(rawKey: ?)",
      "!span": "4229[114:14]-4237[114:22]",
      "!doc": "Sets the per-application encryption key.\n@param {ArrayBuffer} rawKey the raw bytes of the encryption key"
    },
    "register": {
      "!type": "fn()",
      "!span": "5808[157:14]-5818[157:24]",
      "!doc": "Registers crypto adapter."
    },
    "prototype": {
      "getName": {
        "!type": "fn() -> string",
        "!span": "7519[200:24]-7526[200:31]",
        "!doc": "Returns the name of the adapter.\n@returns {String} name of adapter"
      },
      "fallbackToMemoryAdapter": {
        "!type": "fn(e: string)",
        "!span": "7602[205:24]-7625[205:47]"
      },
      "initialize": {
        "!type": "fn()",
        "!span": "8228[219:24]-8238[219:34]",
        "!doc": "Initializes the adapter by waiting for the app-wide crypto key to be set,\nthen validates the key works for items already in persistent storage. If a\nvalid key is not provided the adapter moves to fallback mode, storing items\nin memory.\n@private"
      },
      "isCrypto": {
        "!type": "fn() -> bool",
        "!span": "10357[275:24]-10365[275:32]",
        "!doc": "Gets whether the crypto adapter is running in standard mode (secure and persistent) or fallback\nmode (secure and not persistent).\n\n@returns {Boolean} True if the adapter is secure and persistent; false if the adapter is secure\nand not persistent."
      },
      "executeQueue": {
        "!type": "fn(readyState: bool)",
        "!span": "10623[285:24]-10635[285:36]",
        "!doc": "Runs the stored queue of requests.\n@param {Boolean} readyState true if the adapter is ready; false if the adapter is in permanent error state\n@private"
      },
      "getInitializationError": {
        "!type": "fn() -> string",
        "!span": "11725[314:24]-11747[314:46]",
        "!doc": "Gets the error message when adapter fails to initialize.\n@private"
      },
      "enqueue": {
        "!type": "fn(execute: fn(resolve: ?, reject: ?)) -> ?",
        "!span": "12100[326:24]-12107[326:31]",
        "!doc": "Enqueues a function to execute.\n@param {function} execute the function to execute\n@returns {Promise} a promise that resolves when the function is executed\n@private"
      },
      "getSize": {
        "!type": "fn() -> ?",
        "!span": "12966[353:24]-12973[353:31]",
        "!doc": "Returns adapter size.\n@returns {Promise} a promise that resolves with the size in bytes"
      },
      "getItem": {
        "!type": "fn(key: string) -> ?",
        "!span": "13230[363:24]-13237[363:31]",
        "!doc": "Retrieves an item from storage.\n@param {String} key key for item to retrieve\n@returns {Promise} a promise that resolves with the item or undefined if not found"
      },
      "getItemInternal": {
        "!type": "fn(key: string, resolve: +Function, reject: +Function)",
        "!span": "13628[378:24]-13643[378:39]",
        "!doc": "Retrieves an item from storage.\n@param {String} key key for item to retrieve\n@param {Function} resolve promise resolve function\n@param {Function} reject promise resolve function\n@private"
      },
      "decrypt": {
        "!type": "fn(value: ?) -> ?",
        "!span": "14620[415:24]-14627[415:31]",
        "!doc": "Decrypts a stored cached entry.\n@param {Object} value the cache entry to decrypt\n@returns {Promise} a promise that resolves with the decrypted item.\nThe object consists of {value: *, isExpired: Boolean}.\n@private"
      },
      "getAll": {
        "!type": "fn() -> ?",
        "!span": "15359[441:24]-15365[441:30]",
        "!doc": "Gets all items in storage.\n@returns {Promise} a promise that resolves with the an array of all items"
      },
      "objectToArrayBuffer": {
        "!type": "fn(o: ?)",
        "!span": "17058[493:24]-17077[493:43]",
        "!doc": "Converts an object to an ArrayBuffer.\n@param {Object} o the object to convert\n@private"
      },
      "arrayBufferToObject": {
        "!type": "fn(ab: ?)",
        "!span": "17519[511:24]-17538[511:43]",
        "!doc": "Converts an ArrayBuffer to object.\n@param {ArrayBuffer} ab the ArrayBuffer to convert\n@private"
      },
      "setSentinalItem": {
        "!type": "fn() -> ?",
        "!span": "17983[526:24]-17998[526:39]",
        "!doc": "Stores entry used to determine whether encryption key provided can decrypt the entry.\n@returns {Promise} a promise that resolves when the item is stored."
      },
      "setItem": {
        "!type": "fn(key: string, item: ?, size: number) -> ?",
        "!span": "18548[542:24]-18555[542:31]",
        "!doc": "Stores an item in storage.\n@param {String} key key for item\n@param {Object} item item to store\n@param {Number} size size of key + item in bytes\n@returns {Promise} a promise that resolves when the item is stored"
      },
      "setItemInternal": {
        "!type": "fn(key: string, item: ?, size: number, resolve: +Function, reject: +Function)",
        "!span": "19031[558:24]-19046[558:39]",
        "!doc": "Stores an item in storage.\n@param {String} key key for item\n@param {Object} item item to store\n@param {Number} size size of key + item in bytes\n@param {Function} resolve promise resolve function\n@param {Function} reject promise resolve function"
      },
      "removeItem": {
        "!type": "fn(key: string) -> ?",
        "!span": "20595[603:24]-20605[603:34]",
        "!doc": "Removes an item from storage.\n@param {String} key key for item to remove\n@returns {Promise} a promise that resolves when the item is removed"
      },
      "removeItemInternal": {
        "!type": "fn(key: string, resolve: +Function, reject: +Function)",
        "!span": "20983[617:24]-21001[617:42]",
        "!doc": "Removes an item from storage.\n@param {String} key key for item to remove\n@param {Function} resolve promise resolve function\n@param {Function} reject promise resolve function"
      },
      "clear": {
        "!type": "fn() -> ?",
        "!span": "21221[626:24]-21226[626:29]",
        "!doc": "Clears storage.\n@returns {Promise} a promise that resolves when the store is cleared"
      },
      "clearOnInit": {
        "!type": "fn()",
        "!span": "21390[634:24]-21401[634:35]",
        "!doc": "Clears storage on initialization, before any other operation is performed."
      },
      "sweep": {
        "!type": "fn() -> ?",
        "!span": "21616[643:24]-21621[643:29]",
        "!doc": "Sweeps over the store to evict expired items.\n@returns {Promise} a promise that resolves when the sweep is complete."
      },
      "deleteStorage": {
        "!type": "fn() -> ?",
        "!span": "21802[652:24]-21815[652:37]",
        "!doc": "Deletes this storage.\n@returns {Promise} a promise that resolves when storage is deleted"
      },
      "suspendSweeping": {
        "!type": "fn()",
        "!span": "21931[660:24]-21946[660:39]",
        "!doc": "Suspends eviction."
      },
      "resumeSweeping": {
        "!type": "fn()",
        "!span": "22105[669:24]-22119[669:38]",
        "!doc": "Resumes eviction."
      },
      "isSecure": {
        "!type": "fn() -> bool",
        "!span": "22309[679:24]-22317[679:32]",
        "!doc": "@returns {Boolean} whether the adapter is secure."
      },
      "isPersistent": {
        "!type": "fn() -> bool",
        "!span": "22444[687:24]-22456[687:36]",
        "!doc": "@returns {Boolean} whether the adapter is persistent."
      },
      "log": {
        "!type": "fn(level: CryptoAdapter.LOG_LEVEL.WARNING|CryptoAdapter.LOG_LEVEL, msg: string, obj?: ?)",
        "!span": "22728[700:24]-22731[700:27]",
        "!doc": "Logs a message.\n@param {CryptoAdapter.LOG_LEVEL} level log line level\n@param {String} msg the log message\n@param {Object} [obj] optional log payload\n@private"
      }
    },
    "!type": "fn(config: CryptoAdapter.!0)",
    "!span": "1963[42:9]-1976[42:22]",
    "!doc": "@description The crypto adapter for Aura Storage Service.\n\nThis adapter provides AES-CBC encryption, using the browser Web Cryptography API\n(https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-GlobalCrypto)\nwith a server-provided key, persisting into the IndexedDB adapter.\n\nUnlike other storage adapters this adapter does not automatically register itself. Use\n&lt;auraStorage:crypto/&gt; in the &lt;auraPreInitBlock/&gt; section of the app's template\nto register this adapter. Doing so guarantees that CryptoAdapter.setKey() will be invoked\nwith a server-provided cryptographic key.\n\nPlease note:\n1. If the runtime environment doesn't support the Web Cryptography API the adapter is not\n   registered.\n2. After registration and before a cryptographic key is provided, all crypto adapters\n   enter an initialization stage. Get, put, and remove operations are queued until\n   the key is set. If a key is never provided then the operations appear paused. It's\n   thus paramount to always provide a key. &lt;auraStorage:crypto/&gt; ensures this\n   happens.\n3. If an invalid cryptographic key is provided, the adapter automatically falls\n   back to the memory adapter to provide secure but non-persistent storage.\n\n@constructor"
  },
  "IndexedDBAdapter": {
    "NAME": {
      "!type": "string",
      "!span": "3089[81:17]-3093[81:21]",
      "!doc": "Name of the adapter"
    },
    "LOG_LEVEL": {
      "INFO": {
        "id": {
          "!type": "number",
          "!span": "3174[85:15]-3176[85:17]"
        },
        "fn": {
          "!type": "string",
          "!span": "3181[85:22]-3183[85:24]"
        },
        "!span": "3163[85:4]-3167[85:8]"
      },
      "WARNING": {
        "id": {
          "!type": "number",
          "!span": "3209[86:15]-3211[86:17]"
        },
        "fn": {
          "!type": "string",
          "!span": "3216[86:22]-3218[86:24]"
        },
        "!span": "3198[86:4]-3205[86:11]"
      },
      "!span": "3145[84:17]-3154[84:26]",
      "!doc": "Log levels"
    },
    "prototype": {
      "getName": {
        "!type": "fn() -> string",
        "!span": "3345[94:27]-3352[94:34]",
        "!doc": "Returns the name of the adapter.\n@returns {String} name of adapter"
      },
      "initialize": {
        "!type": "fn(version: ?)",
        "!span": "3518[102:27]-3528[102:37]",
        "!doc": "Initializes the adapter by setting up the DB and ObjectStore.\n@private"
      },
      "getSize": {
        "!type": "fn() -> ?",
        "!span": "5413[146:27]-5420[146:34]",
        "!doc": "Returns adapter size.\n@returns {Promise} a promise that resolves with the size in bytes"
      },
      "getItem": {
        "!type": "fn(key: string) -> ?",
        "!span": "5887[162:27]-5894[162:34]",
        "!doc": "Retrieves an item from storage.\n@param {String} key key for item to retrieve\n@returns {Promise} a promise that resolves with the item or undefined if not found"
      },
      "getAll": {
        "!type": "fn() -> ?",
        "!span": "6226[174:27]-6232[174:33]",
        "!doc": "Gets all items in storage.\n@returns {Promise} a promise that resolves with the an array of all items"
      },
      "suspendSweeping": {
        "!type": "fn()",
        "!span": "6474[185:27]-6489[185:42]",
        "!doc": "Suspends eviction."
      },
      "resumeSweeping": {
        "!type": "fn()",
        "!span": "6600[192:27]-6614[192:41]",
        "!doc": "Resumes eviction."
      },
      "setItem": {
        "!type": "fn(key: string, item: ?, size: number) -> ?",
        "!span": "6931[203:27]-6938[203:34]",
        "!doc": "Stores an item in storage.\n@param {String} key key for item\n@param {Object} item item to store\n@param {Number} size size of key + item in bytes\n@returns {Promise} a promise that resolves when the item is stored"
      },
      "removeItem": {
        "!type": "fn(key: string) -> ?",
        "!span": "7338[216:27]-7348[216:37]",
        "!doc": "Removes an item from storage.\n@param {String} key key for item to remove\n@returns {Promise} a promise that resolves when the item is removed"
      },
      "clearOnInit": {
        "!type": "fn()",
        "!span": "7658[227:27]-7669[227:38]",
        "!doc": "Clears storage on initialization, before any other operation is performed."
      },
      "clear": {
        "!type": "fn() -> ?",
        "!span": "7849[235:27]-7854[235:32]",
        "!doc": "Clears storage.\n@returns {Promise} a promise that resolves when the store is cleared"
      },
      "sweep": {
        "!type": "fn() -> ?",
        "!span": "8185[247:27]-8190[247:32]",
        "!doc": "Sweeps over the store to evict expired items.\n@returns {Promise} a promise that resolves when the sweep is complete."
      },
      "setupDB": {
        "!type": "fn(event: +Event)",
        "!span": "8663[263:27]-8670[263:34]",
        "!doc": "Initializes the structure with a new DB.\n@param {Event} event IndexedDB event\n@private"
      },
      "createTables": {
        "!type": "fn(event: +Event)",
        "!span": "9629[293:27]-9641[293:39]",
        "!doc": "Creates tables in the DB.\n@param {Event} event IndexedDB event\n@private"
      },
      "executeQueue": {
        "!type": "fn(ready: bool)",
        "!span": "10553[322:27]-10565[322:39]",
        "!doc": "Runs the stored queue of requests.\n@param {Boolean} readyState true if the adapter is ready; false if the adapter is in permanent error state\n@private"
      },
      "getInitializationError": {
        "!type": "fn() -> string",
        "!span": "11726[360:27]-11748[360:49]",
        "!doc": "Gets the error message when adapter fails to initialize.\n@private"
      },
      "enqueue": {
        "!type": "fn(execute: fn(resolve: ?, reject: ?)|fn(resolve: ?, reject: ?)) -> ?",
        "!span": "12060[369:27]-12067[369:34]",
        "!doc": "Enqueues a function to execute.\n@param {function} execute the function to execute\n@return {Promise} a promise that resolves when the provided function executes"
      },
      "getItemInternal": {
        "!type": "fn(key: string, resolve: +Function, reject: +Function)",
        "!span": "12989[397:27]-13004[397:42]",
        "!doc": "Retrieves an item from storage.\n@param {String} key key for item to retrieve\n@param {Function} resolve promise resolve function\n@param {Function} reject promise resolve function\n@private"
      },
      "walkInternal": {
        "!type": "fn(resolve: +Function, reject: +Function, sendResult: bool)",
        "!span": "14268[425:27]-14280[425:39]",
        "!doc": "Walks everything in the DB (read only).\n@param {Function} resolve promise resolve function\n@param {Function} reject promise reject function\n@param {Boolean} sendResult true to resolve the promise with the full set of results; false to resolve with the size."
      },
      "setItemInternal": {
        "!type": "fn(key: string, item: ?, size: number, resolve: +Function, reject: +Function)",
        "!span": "16076[479:27]-16091[479:42]",
        "!doc": "Stores an item in storage.\n@param {String} key key for item\n@param {Object} item item to store\n@param {Number} size size of key + item in bytes\n@param {Function} resolve promise resolve function\n@param {Function} reject promise resolve function"
      },
      "removeItemInternal": {
        "!type": "fn(key: string, resolve: +Function, reject: +Function)",
        "!span": "17913[529:27]-17931[529:45]",
        "!doc": "Removes an item from storage.\n@param {String} key key for item to remove\n@param {Function} resolve promise resolve function\n@param {Function} reject promise resolve function"
      },
      "clearInternal": {
        "!type": "fn(resolve: +Function, reject: +Function)",
        "!span": "18726[550:27]-18739[550:40]",
        "!doc": "Clears storage.\n@param {Function} resolve promise resolve function\n@param {Function} reject promise reject function"
      },
      "expireCache": {
        "!type": "fn(requestedSize: number, resolve: +Function, reject: +Function)",
        "!span": "19898[581:27]-19909[581:38]",
        "!doc": "Evicts cache entries and updates the cached size of the store.\n\nCache entries are evicted until requested size is freed. Algorithm evicts\nitems based on age; an LRU algorithm is not used which differentiates this\nadapter from others.\n\nThe rest of the store is traversed to calculate the real size of the\npersisted data.\n\n@param {Number} requestedSize the size to free in bytes\n@param {Function} resolve promise resolve function\n@param {Function} reject promise reject function"
      },
      "updateSize": {
        "!type": "fn(sizeChange: number, error: number)",
        "!span": "24005[681:27]-24015[681:37]",
        "!doc": "Updates the guessed size of the store.\n@param {Number} sizeChange the amount to change the size of the store.\n@param {Number} error a really random guess of the size of the error."
      },
      "refreshSize": {
        "!type": "fn(size: number, count: number)",
        "!span": "24357[693:27]-24368[693:38]",
        "!doc": "Refreshes the cached size of the store from real data.\n@param {Number} size the actual calculated size.\n@param {Number} count the number of items in the store.\n@private"
      },
      "setSize": {
        "!type": "fn(size: number, count: number)",
        "!span": "25314[720:27]-25321[720:34]",
        "!doc": "Sets the cached size of the store. Callers must provide sizes based\non real data, not estimates.\n@param {number} size the actual calculated size.\n@param {number} count the number of items in the store.\n@private"
      },
      "log": {
        "!type": "fn(level: IndexedDBAdapter.LOG_LEVEL.WARNING|IndexedDBAdapter.LOG_LEVEL, msg: string, obj?: ?)",
        "!span": "25731[737:27]-25734[737:30]",
        "!doc": "Logs a message.\n@param {IndexedDBAdapter.LOG_LEVEL} level log line level\n@param {String} msg the log message\n@param {Object} [obj] optional log payload\n@private"
      },
      "deleteStorage": {
        "!type": "fn() -> ?",
        "!span": "26192[749:27]-26205[749:40]",
        "!doc": "Deletes the ENTIRE DB which may contain ObjectStores belonging to other app/cmp.\nTODO W-2691320 - change db vs store name to avoid this issue.\n\n@return {Promise} a promise that deletes the entire database"
      },
      "deleteStorageInternal": {
        "!type": "fn(resolve: ?, reject: ?)",
        "!span": "26485[761:27]-26506[761:48]",
        "!doc": "Internal routine to delete the DB.\n@private"
      }
    },
    "register": {
      "!type": "fn()",
      "!span": "27452[786:17]-27460[786:25]",
      "!doc": "Registers IndexedDB adapter."
    },
    "!type": "fn(config: CryptoAdapter.!0)",
    "!span": "1613[39:4]-1629[39:20]",
    "!doc": "@description The IndexedDB adapter for Aura Storage Service.\n\nImplementation notes:\n\nEach store name gets its own DB. Each app gets its own ObjectStore (aka table). If the same\nstore name is used across apps (eg actions ) then a single DB contains multiple ObjectStores.\nTODO - it'd be better scoped to have one DB per app with all its tables within.\n\nSizing is approximate and updates to sizes are very approximate. We recalculate when our error bars get\ntoo big or after a certain number of updates. This is locked to happen no more than once every 15 minutes\nif our size is not over the limit.\nTODO - revamp size calculations to be more understandable while still supporting multiple browser tabs\n\nEntire table scans are performed for:\n(1) getAll, since we have to.\n(2) size or error bar over the limit.\n(3) getSize, with an old size guess.\n(4) sweep, since we're already scanning the table.\n\n\n@constructor"
  },
  "MemoryAdapter": {
    "NAME": {
      "!type": "string",
      "!span": "961[29:14]-965[29:18]"
    },
    "LOG_LEVEL": {
      "INFO": {
        "id": {
          "!type": "number",
          "!span": "1040[33:15]-1042[33:17]"
        },
        "fn": {
          "!type": "string",
          "!span": "1047[33:22]-1049[33:24]"
        },
        "!span": "1029[33:4]-1033[33:8]"
      },
      "WARNING": {
        "id": {
          "!type": "number",
          "!span": "1075[34:15]-1077[34:17]"
        },
        "fn": {
          "!type": "string",
          "!span": "1082[34:22]-1084[34:24]"
        },
        "!span": "1064[34:4]-1071[34:11]"
      },
      "!span": "1011[32:14]-1020[32:23]",
      "!doc": "Log levels"
    },
    "prototype": {
      "reset": {
        "!type": "fn()",
        "!span": "1160[40:24]-1165[40:29]",
        "!doc": "Resets memory objects."
      },
      "getName": {
        "!type": "fn() -> string",
        "!span": "1371[50:24]-1378[50:31]",
        "!doc": "Returns the name of the adapter.\n@returns {String} name of adapter"
      },
      "getSize": {
        "!type": "fn() -> ?",
        "!span": "1555[58:24]-1562[58:31]",
        "!doc": "Returns adapter size.\n@returns {Promise} a promise that resolves with the size in bytes"
      },
      "getItem": {
        "!type": "fn(key: string)",
        "!span": "1831[67:24]-1838[67:31]",
        "!doc": "Retrieves an item from storage.\n@param {String} key key for item to retrieve\n@returns {Promise} a promise that resolves with the item or undefined if not found"
      },
      "getAll": {
        "!type": "fn() -> ?",
        "!span": "2288[85:24]-2294[85:30]",
        "!doc": "Gets all items in storage.\n@returns {Promise} a promise that resolves with the an array of all items"
      },
      "updateMRU": {
        "!type": "fn(key: string)",
        "!span": "3109[113:24]-3118[113:33]",
        "!doc": "Updates a key in the most recently used list.\n@param {String} key the key to update"
      },
      "setItem": {
        "!type": "fn(key: string, item: ?, size: number) -> ?",
        "!span": "3529[128:24]-3536[128:31]",
        "!doc": "Stores an item in storage.\n@param {String} key key for item\n@param {Object} item item to store\n@param {Number} size size of key + item in bytes\n@returns {Promise} a promise that resolves when the item is stored"
      },
      "removeItem": {
        "!type": "fn(key: string)",
        "!span": "4645[164:24]-4655[164:34]",
        "!doc": "Removes an item from storage.\n@param {String} key key for item to remove\n@returns {Promise} a promise that resolves when the item is removed"
      },
      "removeItemInternal": {
        "!type": "fn(key: string) -> +MemoryAdapter.Entry",
        "!span": "4918[176:24]-4936[176:42]",
        "!doc": "Removes an item from storage.\n@param {String} key key for item to remove"
      },
      "clear": {
        "!type": "fn() -> ?",
        "!span": "5394[198:24]-5399[198:29]",
        "!doc": "Clears storage.\n@returns {Promise} a promise that resolves when the store is cleared"
      },
      "expireCache": {
        "!type": "fn(spaceNeeded: number) -> ?",
        "!span": "5868[213:24]-5879[213:35]",
        "!doc": "Evicts items. Expired items are evicted first. If additional space is required then\nitems are evicted based on LRU.\n@param {Number} spaceNeeded The amount of space to free. Specify 0 to remove only expired items.\n@returns {Promise} a promise that resolves when the requested space is freed."
      },
      "getMRU": {
        "!type": "fn() -> ?",
        "!span": "7159[253:24]-7165[253:30]",
        "!doc": "Gets the most-recently-used list.\n@returns {Promise} a promise that results with the an array of keys representing the MRU."
      },
      "log": {
        "!type": "fn(level: MemoryAdapter.LOG_LEVEL, msg: string, obj?: ?)",
        "!span": "7433[264:24]-7436[264:27]",
        "!doc": "Logs a message.\n@param {MemoryAdapter.LOG_LEVEL} level log line level\n@param {String} msg the log message.\n@param {Object} [obj] optional log payload.\n@private"
      },
      "sweep": {
        "!type": "fn() -> ?",
        "!span": "7738[275:24]-7743[275:29]",
        "!doc": "Removes expired items\n@returns {Promise} when sweep completes"
      },
      "deleteStorage": {
        "!type": "fn() -> ?",
        "!span": "7980[284:24]-7993[284:37]",
        "!doc": "Deletes this storage.\n@returns {Promise} a promise that resolves when storage is deleted"
      }
    },
    "Entry": {
      "prototype": {
        "getItem": {
          "!type": "fn() -> !this.item",
          "!span": "8636[307:30]-8643[307:37]",
          "!doc": "@returns {Object} the stored item"
        },
        "getSize": {
          "!type": "fn() -> !this.size",
          "!span": "8781[314:30]-8788[314:37]",
          "!doc": "@returns {Number} the size of the cache entry in bytes"
        }
      },
      "!type": "fn(item: ?, size: number)",
      "!span": "8294[297:14]-8299[297:19]",
      "!doc": "@description A cache entry in the backing store of the MemoryAdapter.\nItems which are not JSON serializable (eg cyclic graphs) will throw.\nThe caller must handle this.\n\n@constructor\n@private",
      "size": {
        "!type": "number",
        "!span": "8544[301:9]-8548[301:13]"
      }
    },
    "!type": "fn(config: CryptoAdapter.!0)",
    "!span": "736[22:4]-749[22:17]",
    "!doc": "@description The Javascript memory adapter for Aura Storage Service.\n@constructor"
  },
  "AuraStorage": {
    "prototype": {
      "getName": {
        "!type": "fn() -> string",
        "!span": "4565[98:22]-4572[98:29]",
        "!doc": "Returns the name of the storage type. For example, \"indexeddb\" or \"memory\".\n@returns {String} The storage type.\n@export"
      },
      "getSize": {
        "!type": "fn() -> ?",
        "!span": "4801[107:22]-4808[107:29]",
        "!doc": "Asynchronously gets the current storage size in KB.\n@returns {Promise} A Promise that will get the current storage size in KB.\n@export"
      },
      "getMaxSize": {
        "!type": "fn() -> number",
        "!span": "5057[117:22]-5067[117:32]",
        "!doc": "Returns the maximum storage size in KB.\n@returns {number} The maximum storage size in KB.\n@export"
      },
      "getDefaultAutoRefreshInterval": {
        "!type": "fn() -> !this.defaultAutoRefreshInterval",
        "!span": "5264[125:22]-5293[125:51]",
        "!doc": "Returns the default auto-refresh interval in seconds.\n@returns {number} The default auto-refresh interval."
      },
      "clear": {
        "!type": "fn() -> ?",
        "!span": "5501[134:22]-5506[134:27]",
        "!doc": "Returns a promise that clears the storage.\n@returns {Promise} A Promise that will clear storage.\n@export"
      },
      "get": {
        "!type": "fn(key: string) -> ?",
        "!span": "6174[154:22]-6177[154:25]",
        "!doc": "Asynchronously gets an item from storage corresponding to the specified key.\n@param {String} key The item key. This is the key used when the item was added to storage using <code>put()</code>.\n@returns {Promise} A Promise that resolves to an object in storage or undefined if the key is not found.\n     The object consists of {value: *, isExpired: Boolean}.\n\n@export"
      },
      "inFlightOperations": {
        "!type": "fn() -> !this.getOperationsInFlight",
        "!span": "6978[183:22]-6996[183:40]",
        "!doc": "In flight operations counter\n@returns {Integer} Number of operations currently waiting on being resolved\n\n@export"
      },
      "getAll": {
        "!type": "fn() -> ?",
        "!span": "7301[193:22]-7307[193:28]",
        "!doc": "Asynchronously gets all items from storage.\n@returns {Promise} A Promise that resolves to an array of objects in storage. Each\n     object consists of {key: String, value: *, isExpired: Boolean}.\n@export"
      },
      "put": {
        "!type": "fn(key: string, value: Action.prototype.getStored.!ret|string) -> ?",
        "!span": "8545[227:22]-8548[227:25]",
        "!doc": "Asynchronously stores the value in storage using the specified key.\nCalculates the approximate size of the data and provides it to adapter.\n\n@param {String} key The key of the item to store.\n@param {*} value The value of the item to store.\n@returns {Promise} A Promise that will put the value in storage.\n@export"
      },
      "remove": {
        "!type": "fn(key: string, doNotFireModified: bool) -> ?",
        "!span": "10140[273:22]-10146[273:28]",
        "!doc": "Asynchronously removes the item from storage corresponding to the specified key.\n@param {String} key The key of the item to remove.\n@param {Boolean} doNotFireModified A bool indicating whether or not to fire the modified event on item removal.\n@returns {Promise} A Promise that will remove the item from storage.\n@private"
      },
      "sweep": {
        "!type": "fn()",
        "!span": "10657[292:22]-10662[292:27]",
        "!doc": "Asynchronously removes all expired items.\n@private"
      },
      "suspendSweeping": {
        "!type": "fn()",
        "!span": "13507[382:22]-13522[382:37]",
        "!doc": "Suspends sweeping.\n\nExpired storage entries are proactively removed by sweeping. Sweeping is often suspended\nwhen the connection goes offline so expired items remain accessible.\n@export"
      },
      "resumeSweeping": {
        "!type": "fn()",
        "!span": "13797[396:22]-13811[396:36]",
        "!doc": "Resumes sweeping to remove expired storage entries.\n@export"
      },
      "log": {
        "!type": "fn()",
        "!span": "14049[411:22]-14052[411:25]",
        "!doc": "@private"
      },
      "logError": {
        "!type": "fn(payload: ?)",
        "!span": "14521[425:22]-14529[425:30]",
        "!doc": "Logs an error to the server.\n@param {Object} payload The error payload object.\n@param {String} payload.operation The operation which errored (eg get, put)\n@param {Error=} payload.error Optional error object\n@private"
      },
      "isPersistent": {
        "!type": "fn() -> !this.persistent",
        "!span": "14958[439:22]-14970[439:34]",
        "!doc": "Whether the storage implementation is persistent.\n@returns {boolean} true if persistent\n@export"
      },
      "isSecure": {
        "!type": "fn() -> !this.secure",
        "!span": "15232[451:22]-15240[451:30]",
        "!doc": "Whether the storage implementation is secure.\n@returns {boolean} true if secure\n@export"
      },
      "setVersion": {
        "!type": "fn(version: string)",
        "!span": "15477[463:22]-15487[463:32]",
        "!doc": "Sets the storage version.\n@param {String} version storage version.\n@export"
      },
      "getVersion": {
        "!type": "fn() -> !this.version",
        "!span": "15716[474:22]-15726[474:32]",
        "!doc": "Returns the storage version.\n@returns {String} storage version.\n@export"
      },
      "deleteStorage": {
        "!type": "fn()",
        "!span": "15854[482:22]-15867[482:35]",
        "!doc": "Asynchronously deletes this storage.\n@private"
      },
      "updateKeyPrefix": {
        "!type": "fn()",
        "!span": "16540[506:22]-16555[506:37]",
        "!doc": "Update the prefix for all storage keys.\n@private"
      }
    },
    "KEY_DELIMITER": {
      "!type": "string",
      "!span": "16785[516:12]-16798[516:25]",
      "!doc": "Storage key delimiter, separating isolation and version key from\nthe user-provided key.\n@private"
    },
    "SWEEP_INTERVAL": {
      "MIN": {
        "!type": "number",
        "!span": "16892[522:8]-16897[522:13]"
      },
      "MAX": {
        "!type": "number",
        "!span": "16923[523:8]-16928[523:13]"
      },
      "!span": "16862[521:12]-16878[521:28]",
      "!doc": "Sweep intervals (milliseconds)."
    },
    "!type": "fn(config: AuraStorage.!0)",
    "!span": "830[22:4]-841[22:15]",
    "!doc": "@description The storage service implementation.\n@constructor\n@param {Object} config The configuration describing the characteristics of the storage to be created.\n@export",
    "name": {
      "!type": "string",
      "!span": "884[23:9]-888[23:13]"
    },
    "maxSize": {
      "!type": "number",
      "!span": "954[25:9]-961[25:16]"
    },
    "defaultExpiration": {
      "!type": "number",
      "!span": "992[26:9]-1009[26:26]"
    },
    "defaultAutoRefreshInterval": {
      "!type": "number",
      "!span": "1057[27:9]-1083[27:35]"
    },
    "debugLoggingEnabled": {
      "!type": "bool",
      "!span": "1140[28:9]-1159[28:28]"
    },
    "getOperationsInFlight": {
      "!type": "number",
      "!span": "1202[29:9]-1223[29:30]"
    },
    "isolationKey": {
      "!type": "string",
      "!span": "1239[31:9]-1251[31:21]"
    },
    "sweepInterval": {
      "!type": "number",
      "!span": "1392[36:9]-1405[36:22]",
      "!doc": "frequency guard for sweeping"
    },
    "lastSweepTime": {
      "!type": "number",
      "!span": "1542[38:9]-1555[38:22]"
    },
    "_sweepingSuspended": {
      "!type": "bool",
      "!span": "1590[40:9]-1608[40:27]"
    },
    "persistent": {
      "!type": "bool",
      "!span": "3445[67:9]-3455[67:19]"
    },
    "secure": {
      "!type": "bool",
      "!span": "3555[68:9]-3561[68:15]"
    },
    "_sweepingInProgress": {
      "!type": "bool",
      "!span": "11272[313:9]-11291[313:28]",
      "!doc": "prevent concurrent sweeps"
    },
    "version": {
      "!type": "string",
      "!span": "15541[465:9]-15548[465:16]",
      "!doc": "ensure string"
    },
    "keyPrefix": {
      "!type": "string",
      "!span": "16580[507:9]-16589[507:18]"
    }
  },
  "AuraStorageService": {
    "prototype": {
      "getStorage": {
        "!type": "fn(name: string) -> !this.storages.<i>",
        "!span": "1351[36:29]-1361[36:39]",
        "!doc": "Returns an existing storage using the specified name. For example, <code>$A.storageService.getStorage(\"MyStorage\").getSize()</code> returns the cache size.\n<p>See Also: <a href=\"#reference?topic=api:AuraStorage\">AuraStorage</a></p>\n@param {String} name The name of the requested storage.\n@memberOf AuraStorageService\n@returns {AuraStorage} Returns an AuraStorage object corresponding to an existing storage.\n@export"
      },
      "getStorages": {
        "!type": "fn() -> ?",
        "!span": "1687[48:29]-1698[48:40]",
        "!doc": "Returns all existing storages.\n<p>See Also: <a href=\"#reference?topic=api:AuraStorage\">AuraStorage</a></p>\n@memberOf AuraStorageService\n@returns {Object} Returns a map of storage names to AuraStorage objects.\n@export"
      },
      "initStorage": {
        "!type": "fn(name: string, persistent?: bool, secure?: bool, maxSize?: number, defaultExpiration?: number, defaultAutoRefreshInterval?: number, debugLoggingEnabled?: bool, clearStorageOnInit?: bool, version?: string) -> +AuraStorage",
        "!span": "3033[68:29]-3044[68:40]",
        "!doc": "Initializes and returns new storage.\n@param {String} name The unique name of the storage to be initialized.\n@param {Boolean} [persistent] Set to true if the requested storage is persistent.\n@param {Boolean} [secure] Set to true if the requested storage is secure.\n@param {number} [maxSize] Specifies the maximum storage size (bytes).\n@param {number} [defaultExpiration] Specifies the default time (seconds) after which the cache expires. When an item is requested that has gone past the default cache expiration time, it will not be used.\n@param {number} [defaultAutoRefreshInterval] Specifies the default interval (seconds) after which cached data is to be refreshed.\n@param {Boolean} [debugLoggingEnabled] Set to true to enable debug logging in the JavaScript console for the Aura Storage Service.\n@param {Boolean} [clearStorageOnInit] Set to true to clear storage when storage is initialized.\n@param {String} [version] The version of storage. for any item in the storage. This is useful if you want to avoid retrieving stale cached items for a newer version of your application.\n@memberOf AuraStorageService\n@returns {AuraStorage} Returns an AuraStorage object for the new storage.\n@export"
      },
      "registerAdapter": {
        "!type": "fn(config: ?)",
        "!span": "4967[113:29]-4982[113:44]",
        "!doc": "Registers a new Aura Storage Service adapter.\n\n@param {Object} config Adapter configuration object.\n@memberOf AuraStorageService\n@export"
      },
      "isRegisteredAdapter": {
        "!type": "fn(name: string) -> bool",
        "!span": "5401[127:29]-5420[127:48]",
        "!doc": "Whether an adapter is registered\n\n@param {String} name adapter name\n@memberOf AuraStorageService\n@returns {boolean} whether adapter is registered\n@export"
      },
      "getAdapterConfig": {
        "!type": "fn(adapter: string) -> !this.adapters.<i>",
        "!span": "5659[138:29]-5675[138:45]",
        "!doc": "Returns an adapter's configuration.\n\n@param {String} adapter name of the adapter\n@memberOf AuraStorageService\n@export"
      },
      "createAdapter": {
        "!type": "fn(adapter: string, name: string, maxSize: number, debugLoggingEnabled: bool, expiration: number)",
        "!span": "6402[156:29]-6415[156:42]",
        "!doc": "Creates a storage adapter. Used only by tests.\n<p>Example:</p>\n<code>$A.storageService.createAdapter(\"memory\", \"test\", 4096, true);</code>\n@param {String} adapter The new adapter to create.\n@param {String} name The name of the adapter.\n@param {number} maxSize The maximum size (bytes) to allocate to the storage adapter.\n@param {Boolean} debugLoggingEnabled Set to true to enable logging, or false otherwise.\n@param {number} expiration Specifies the expiration time (seconds) for entries.\n@memberOf AuraStorageService\n//#if {\"excludeModes\" : [\"PRODUCTION\", \"PRODUCTIONDEBUG\"]}\n@export\n//#end"
      },
      "fireModified": {
        "!type": "fn()",
        "!span": "6918[172:29]-6930[172:41]"
      },
      "selectAdapter": {
        "!type": "fn(persistent: bool|string, secure: bool|+Component)",
        "!span": "7498[188:29]-7511[188:42]",
        "!doc": "Selects an adapter based on the given configuration. Used mostly in non-production modes.\n@param {Boolean} persistent Set to true if the adapter should be persistent, or false otherwise.\n@param {Boolean} secure Set to true if the adapter should be secure, or false otherwise.\n@memberOf AuraStorageService\n//#if {\"excludeModes\" : [\"PRODUCTION\", \"PRODUCTIONDEBUG\"]}\n@export\n//#end"
      },
      "deleteStorage": {
        "!type": "fn(name: string)",
        "!span": "8763[228:29]-8776[228:42]",
        "!doc": "Deletes a storage.\n@param {String} name name of storage to delete.\n@export"
      },
      "setVersion": {
        "!type": "fn(version: string)",
        "!span": "9208[245:29]-9218[245:39]",
        "!doc": "Sets the default version for all storages.\n@param {String} version default version for storages.\n@export"
      },
      "getVersion": {
        "!type": "fn() -> !this.version",
        "!span": "9455[255:29]-9465[255:39]",
        "!doc": "Gets the default version for all storages.\n@return {String} the default version for storages.\n@export"
      },
      "setIsolation": {
        "!type": "fn(isolationKey: string)",
        "!span": "9932[272:29]-9944[272:41]",
        "!doc": "Sets a key from which isolation in the storage system is enforced.\n\nThis mechanism is typically used to isolate multiple users' data by setting\nthe isolation key to the user id.\n\nIt should only be called once during the application life cycle, since it\nwill be deleted in production mode.\n\n\n@param {String} isolationKey the key defining isolation.\n@export"
      },
      "CryptoAdapter": "CryptoAdapter"
    },
    "!type": "fn()",
    "!span": "756[21:9]-774[21:27]",
    "!doc": "@description The Aura Storage Service, accessible using $A.storageService.\n@constructor\n@export",
    "storages": {
      "!span": "787[22:9]-795[22:17]",
      "<i>": "+AuraStorage"
    },
    "adapters": {
      "!span": "811[23:9]-819[23:17]"
    },
    "version": {
      "!type": "string",
      "!span": "835[24:9]-842[24:16]",
      "!doc": "ensure string"
    },
    "isolationKey": {
      "!type": "string",
      "!span": "858[25:9]-870[25:21]",
      "!doc": "ensure string"
    },
    "_isDisconnected": {
      "!type": "bool",
      "!span": "9649[176:4146]-9664[176:4161]"
    },
    "lastSendTime": {
      "!type": "number",
      "!span": "68475[176:62972]-68487[176:62984]"
    },
    "state": {
      "!type": "string",
      "!span": "29416[176:23913]-29421[176:23918]"
    },
    "needsCleaning": {
      "!type": "bool",
      "!span": "19844[176:14341]-19857[176:14354]"
    },
    "fired": {
      "!type": "bool",
      "!span": "8367[176:2864]-8372[176:2869]"
    }
  },
  "StyleDef": {
    "prototype": {
      "apply": {
        "!type": "fn()",
        "!span": "1131[31:19]-1136[31:24]",
        "!doc": "Applies style to element. If this StyleDef's style has not been added to the DOM, add it to the DOM."
      },
      "remove": {
        "!type": "fn()",
        "!span": "1367[41:19]-1373[41:25]"
      },
      "getClassName": {
        "!type": "fn() -> !this.className",
        "!span": "1508[50:19]-1520[50:31]",
        "!doc": "Gets class name from the style definition.\n@param {Object} className"
      },
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "1745[61:19]-1758[61:32]",
        "!doc": "Returns a DefDescriptor object.\n\n@returns {DefDescriptor} A DefDescriptor object contains a prefix, namespace,\n         and name.\n@export"
      },
      "isPreloaded": {
        "!type": "fn() -> !this.preloaded",
        "!span": "1935[68:19]-1946[68:30]",
        "!doc": "Returns true if this def was preloaded into app.css, false if added via an individual <style> tag."
      }
    },
    "!type": "fn(config: ?)",
    "!span": "783[21:9]-791[21:17]",
    "!doc": "@description Creates a new StyleDef instance, including the class name and descriptor.\n@constructor\n@param {Object} config",
    "descriptor": {
      "!type": "+DefDescriptor",
      "!span": "884[24:9]-894[24:19]"
    },
    "preloaded": {
      "!type": "bool",
      "!span": "947[25:9]-956[25:18]"
    }
  },
  "DefDescriptor": {
    "prototype": {
      "getQualifiedName": {
        "!type": "fn() -> !this.qualifiedName",
        "!span": "2024[55:24]-2040[55:40]",
        "!doc": "Gets the qualified name.\n@returns {String}\n@export"
      },
      "getNamespace": {
        "!type": "fn() -> !this.namespace",
        "!span": "2187[64:24]-2199[64:36]",
        "!doc": "Gets the namespace.\n@returns {String} namespace\n@export"
      },
      "getName": {
        "!type": "fn() -> !this.name",
        "!span": "2354[73:24]-2361[73:31]",
        "!doc": "Gets the name part of the qualified name.\n@returns {String}\n@export"
      },
      "getPrefix": {
        "!type": "fn() -> !this.prefix",
        "!span": "2507[82:24]-2516[82:33]",
        "!doc": "Gets the prefix of the DefDescriptor.\n@returns {String}\n@export"
      },
      "toString": {
        "!type": "fn() -> string",
        "!span": "2671[91:24]-2679[91:32]",
        "!doc": "Returns the qualified name in string format.\n@returns {String}\n@export"
      }
    },
    "DESCRIPTOR": {
      "!type": "string",
      "!span": "1438[35:14]-1448[35:24]",
      "!doc": "Static Members"
    },
    "normalize": {
      "!type": "fn(descriptor: string|?) -> !0.<i>",
      "!span": "1478[37:14]-1487[37:23]"
    },
    "!type": "fn(descriptor: ?)",
    "!span": "852[21:9]-865[21:22]",
    "!doc": "@description Creates a new DefDescriptor (definition descriptor) instance, including the prefix and namespace.\n@constructor\n@param {Object} descriptor Throws an error if descriptor is null or undefined.\n@export",
    "namespace": {
      "!type": "string",
      "!span": "1134[28:9]-1143[28:18]"
    },
    "qualifiedName": {
      "!type": "string",
      "!span": "1333[31:9]-1346[31:22]"
    }
  },
  "TypeDef": {
    "prototype": {
      "getDescriptor": {
        "!type": "fn() -> !this.descriptor",
        "!span": "826[25:18]-839[25:31]"
      },
      "isArray": {
        "!type": "fn() -> !this.array",
        "!span": "905[29:18]-912[29:25]"
      }
    },
    "!type": "fn(config: ?)",
    "!span": "670[20:9]-677[20:16]",
    "!doc": "@constructor"
  },
  "TypeDefRegistry": {
    "prototype": {
      "getDef": {
        "!type": "fn(config: ?) -> +TypeDef",
        "!span": "742[24:26]-748[24:32]"
      }
    },
    "!type": "fn()",
    "!span": "670[20:9]-685[20:24]",
    "!doc": "@constructor"
  },
  "goog": {
    "exportProperty": {
      "!type": "fn(object: goog.exportProperty.!0, publicName: string, symbol: ?)",
      "!span": "1043[26:5]-1057[26:19]",
      "!doc": "Exports a property unobfuscated into the object's namespace.\nex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);\nex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);\n@param {Object} object Object whose static property is being exported.\n@param {string} publicName Unobfuscated name to export.\n@param {*} symbol Object the name should point to."
    },
    "exportSymbol": {
      "!type": "fn(publicPath: string, opt_object: ?, opt_objectToExportTo?: goog.exportSymbol.!2)",
      "!span": "1995[51:5]-2007[51:17]",
      "!doc": "Exposes an unobfuscated global namespace path for the given object.\nNote that fields of the exported object *will* be obfuscated, unless they are\nexported in turn via this function or goog.exportProperty.\n\nAlso handy for making public items that are defined in anonymous closures.\n\nex. goog.exportSymbol('public.path.Foo', Foo);\n\nex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);\n    public.path.Foo.staticFunction();\n\nex. goog.exportSymbol('public.path.Foo.prototype.myMethod',\n                      Foo.prototype.myMethod);\n    new public.path.Foo().myMethod();\n\n@param {string} publicPath Unobfuscated name to export.\n@param {*} object Object the name should point to.\n@param {Object=} opt_objectToExportTo The object to add the path to; default\n    is goog.global."
    },
    "!span": "617[16:4]-621[16:8]",
    "!doc": "Copyright (C) 2013 salesforce.com, inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
  },
  "PerfLogLevel": {
    "DEBUG": {
      "name": {
        "!type": "string",
        "!span": "888[29:8]-892[29:12]"
      },
      "value": {
        "!type": "number",
        "!span": "912[30:8]-917[30:13]"
      },
      "!span": "870[28:4]-875[28:9]",
      "!doc": "@expose"
    },
    "INTERNAL": {
      "name": {
        "!type": "string",
        "!span": "973[34:8]-977[34:12]"
      },
      "value": {
        "!type": "number",
        "!span": "1000[35:8]-1005[35:13]"
      },
      "!span": "952[33:4]-960[33:12]",
      "!doc": "@expose"
    },
    "PRODUCTION": {
      "name": {
        "!type": "string",
        "!span": "1063[39:8]-1067[39:12]"
      },
      "value": {
        "!type": "number",
        "!span": "1092[40:8]-1097[40:13]"
      },
      "!span": "1040[38:4]-1050[38:14]",
      "!doc": "@expose"
    },
    "DISABLED": {
      "name": {
        "!type": "string",
        "!span": "1153[44:8]-1157[44:12]"
      },
      "value": {
        "!type": "number",
        "!span": "1180[45:8]-1185[45:13]"
      },
      "!span": "1132[43:4]-1140[43:12]",
      "!doc": "@expose"
    },
    "!span": "830[26:4]-842[26:16]",
    "!doc": "The levels for logging performance m\n\n@enum {{name: !string, value: !number}}\n@expose\n@export"
  },
  "PerfConstants": {
    "PAGE_START_MARK": {
      "!type": "string",
      "!span": "1324[58:4]-1339[58:19]",
      "!doc": "@expose"
    },
    "PERF_PAYLOAD_PARAM": {
      "!type": "string",
      "!span": "1378[60:4]-1396[60:22]",
      "!doc": "@expose"
    },
    "MARK_NAME": {
      "!type": "string",
      "!span": "1434[62:4]-1443[62:13]",
      "!doc": "@expose"
    },
    "MEASURE_NAME": {
      "!type": "string",
      "!span": "1477[64:4]-1489[64:16]",
      "!doc": "@expose"
    },
    "MARK_START_TIME": {
      "!type": "string",
      "!span": "1526[66:4]-1541[66:19]",
      "!doc": "@expose"
    },
    "MARK_LAST_TIME": {
      "!type": "string",
      "!span": "1573[68:4]-1587[68:18]",
      "!doc": "@expose"
    },
    "PAGE_NAME": {
      "!type": "string",
      "!span": "1619[70:4]-1628[70:13]",
      "!doc": "@expose"
    },
    "ELAPSED_TIME": {
      "!type": "string",
      "!span": "1660[72:4]-1672[72:16]",
      "!doc": "@expose"
    },
    "REFERENCE_TIME": {
      "!type": "string",
      "!span": "1704[74:4]-1718[74:18]",
      "!doc": "@expose"
    },
    "Perf_LOAD_DONE": {
      "!type": "string",
      "!span": "1750[76:4]-1764[76:18]",
      "!doc": "@expose"
    },
    "STATS": {
      "NAME": {
        "!type": "string",
        "!span": "1867[85:4]-1871[85:8]",
        "!doc": "@expose"
      },
      "SERVER_ELAPSED": {
        "!type": "string",
        "!span": "1905[87:4]-1919[87:18]",
        "!doc": "@expose"
      },
      "DB_TOTAL_TIME": {
        "!type": "string",
        "!span": "1971[89:4]-1984[89:17]",
        "!doc": "@expose"
      },
      "DB_CALLS": {
        "!type": "string",
        "!span": "2040[91:4]-2048[91:12]",
        "!doc": "@expose"
      },
      "DB_FETCHES": {
        "!type": "string",
        "!span": "2100[93:4]-2110[93:14]",
        "!doc": "@expose"
      },
      "!span": "1834[83:14]-1839[83:19]",
      "!doc": "@enum {!string}\n@expose"
    },
    "!span": "1283[56:4]-1296[56:17]",
    "!doc": "Various Perf constants.\n\n@enum {!string}\n@expose\n@export"
  },
  "PerfShim": {
    "mark": {
      "!type": "fn(id: ?, logLevel?: string|?) -> !this",
      "!span": "2567[116:4]-2571[116:8]",
      "!doc": "@param {!string} id The id used to identify the mark.\n@param {string|window.typePerfLogLevel=} logLevel The level at which this mark should\nbe logged at.\n@return {!PerfShim}\n@expose"
    },
    "endMark": {
      "!type": "fn(id: ?, logLevel?: string|?) -> !this",
      "!span": "2889[126:4]-2896[126:11]",
      "!doc": "@param {!string} id This is the id associated with the mark that uses\nthe same id.\n@param {string|window.typePerfLogLevel=} logLevel The level at which this mark should\nbe logged at.\n@return {!PerfShim}\n@expose"
    },
    "updateMarkName": {
      "!type": "fn(oldName: ?, newName: ?) -> !this",
      "!span": "3241[136:4]-3255[136:18]",
      "!doc": "This method is used to the update the name of a mark\n\n@param {!string} oldName The id used to identify the old mark name.\n@param {!string} newName The id used to identify the new mark name.\n@return {!PerfShim} for chaining methods\n@expose"
    },
    "measureToJson": {
      "!type": "fn(measure: ?) -> string",
      "!span": "3538[145:4]-3551[145:17]",
      "!doc": "Serializes a measure object to JSON.\n\n@param {!window.typejsonMeasure} measure The measure to serialize.\n@return {!string} JSON-serialized version of the supplied measure.\n@expose"
    },
    "toJson": {
      "!type": "fn(includeMarks?: bool) -> string",
      "!span": "3771[154:4]-3777[154:10]",
      "!doc": "Serializes timers to JSON.\n\n@param {boolean=} includeMarks\n@return {!string} JSON-serialized version of supplied marks.\n@expose"
    },
    "setTimer": {
      "!type": "fn(timer_name: ?, timer_delta?: number, logLevel?: string|?) -> !this",
      "!span": "4161[163:4]-4169[163:12]",
      "!doc": "@param {!string} timer_name The name of the timer to set.\n@param {number=} timer_delta The time delta to set.\n@param {string|window.typePerfLogLevel=} logLevel The level at which this mark should be logged at. Defaults to PerfLogLevel.INTERNAL if left blank\n@return {!PerfShim}\n@expose"
    },
    "toPostVar": {
      "!type": "fn() -> string",
      "!span": "4429[171:4]-4438[171:13]",
      "!doc": "Get a JSON-serialized version of all existing timers and stats in POST friendly format.\n\n@return {!string} POST-friendly timers and stats.\n@expose"
    },
    "getMeasures": {
      "!type": "fn() -> [?]",
      "!span": "4642[179:4]-4653[179:15]",
      "!doc": "Returns all of the measures that have been captured\n\n@return {!Array.<window.typejsonMeasure>} all existing measures.\n@expose"
    },
    "getBeaconData": {
      "!type": "fn()",
      "!span": "4828[187:4]-4841[187:17]",
      "!doc": "Returns the beaconData to piggyback on the next XHR call\n\n@return {?string} beacon data.\n@expose"
    },
    "setBeaconData": {
      "!type": "fn(beaconData: ?)",
      "!span": "5012[195:4]-5025[195:17]",
      "!doc": "Sets the beaconData to piggyback on the next XHR call\n\n@param {!string} beaconData\n@expose"
    },
    "clearBeaconData": {
      "!type": "fn()",
      "!span": "5122[202:4]-5137[202:19]",
      "!doc": "Clears beacon data\n\n@expose"
    },
    "removeStats": {
      "!type": "fn()",
      "!span": "5233[209:4]-5244[209:15]",
      "!doc": "Removes the existing timers\n\n@expose"
    },
    "stat": {
      "!type": "fn(label: ?, elapsedMillis: ?) -> !this",
      "!span": "5454[219:4]-5458[219:8]",
      "!doc": "Add a performance measurement from the server.\n\n@param {!string} label\n@param {!number} elapsedMillis\n@return {!PerfShim}\n@expose"
    },
    "getStat": {
      "!type": "fn(label: ?) -> number",
      "!span": "5671[228:4]-5678[228:11]",
      "!doc": "Get the stored server side performance measures.\n\n@param {!string} label\n@return {!string|number}\n@expose"
    },
    "onLoad": {
      "!type": "fn()",
      "!span": "5856[235:4]-5862[235:10]",
      "!doc": "Called when the page is ready to interact with. To support the existing Kylie.onLoad method.\n\n@expose"
    },
    "startTransaction": {
      "!type": "fn(tName: ?) -> !this",
      "!span": "6104[244:4]-6120[244:20]",
      "!doc": "This method is used to mark the start of a transaction\n\n@param {!string} tName The id used to identify the transaction.\n@return {!PerfShim} for chaining methods\n@expose"
    },
    "endTransaction": {
      "!type": "fn(tName: ?) -> !this",
      "!span": "6379[253:4]-6393[253:18]",
      "!doc": "This method is used to mark the end of a transaction\n\n@param {!string} tName The id used to identify the transaction.\n@return {!PerfShim} for chaining methods\n@expose"
    },
    "updateTransaction": {
      "!type": "fn(oldName: ?, newName: ?) -> !this",
      "!span": "6761[264:4]-6778[264:21]",
      "!doc": "This method is used to the update the name of the\ntransaction\n\n@param {!string} oldName The id used to identify the old transaction name.\n@param {!string} newName The id used to identify the new transaction name.\n@return {!PerfShim} for chaining methods\n@expose"
    },
    "isOnLoadFired": {
      "!type": "fn() -> bool",
      "!span": "6982[273:4]-6995[273:17]",
      "!doc": "This method is used to figure if onLoad/page_ready has been fired or\nnot\n\n@return {!boolean}\n@expose"
    },
    "util": {
      "setCookie": {
        "!type": "fn(name: ?, value: ?, expires?: +Date, path?: string)",
        "!span": "7352[290:8]-7361[290:17]",
        "!doc": "Sets the roundtrip time cookie\n\n@param {!string=} name\n@param {!string|number=} value\n@param {Date=} expires\n@param {string=} path\n@expose"
      },
      "!span": "7096[280:4]-7100[280:8]",
      "!doc": "@namespace\n@const\n@expose"
    },
    "enabled": {
      "!type": "bool",
      "!span": "7558[299:4]-7565[299:11]",
      "!doc": "Whether the full Kylie framework is loaded, as opposed to just the stubs.\n\n@type {boolean}\n@const"
    },
    "!span": "2187[101:0]-2195[101:8]",
    "!doc": "@public\n@namespace\n@const",
    "currentLogLevel": "PerfLogLevel.DISABLED"
  },
  "SizeEstimator": {
    "CHARACTER_SIZE": {
      "!type": "number",
      "!span": "1029[28:14]-1043[28:28]",
      "!doc": "Note on sizing.  The following values are taken from the ECMAScript specification, where available.\nOther values are guessed.\n\nSource: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf"
    },
    "NUMBER_SIZE": {
      "!type": "number",
      "!span": "1063[29:14]-1074[29:25]"
    },
    "BOOLEAN_SIZE": {
      "!type": "number",
      "!span": "1097[30:14]-1109[30:26]"
    },
    "POINTER_SIZE": {
      "!type": "number",
      "!span": "1173[31:14]-1185[31:26]"
    },
    "prototype": {
      "estimateSize": {
        "!type": "fn(value: string|Action.prototype.getStored.!ret) -> number",
        "!span": "1437[40:24]-1449[40:36]",
        "!doc": "Estimates the size of a value.\n@param {*} value the item to estimate\n@return {Number} the estimated size of the item in bytes."
      },
      "sizeOfString": {
        "!type": "fn(value: string|Action.prototype.getStored.!ret) -> number",
        "!span": "2080[63:24]-2092[63:36]"
      },
      "hasOwnProperty": "!proto.hasOwnProperty"
    },
    "!type": "fn()",
    "!span": "742[20:4]-755[20:17]",
    "!doc": "@description Provides operations to estimate size of JSON objects in memory.\n@constructor"
  },
  "handlerCache": {
    "<i>": {
      "!type": "[fn()|+Function]",
      "!span": "38891[1184:29]-38900[1184:38]"
    },
    "!span": "38424[1170:24]-38438[1170:38]",
    "!doc": "Eliminate registration of duplicate handlers on older browsers"
  },
  "ExpressionFunctions": {
    "prototype": {
      "eq": {
        "!type": "fn(a: ?, b: ?) -> bool|?",
        "!span": "1110[35:30]-1112[35:32]",
        "!doc": "Performs a strict comparison while avoiding \"null\" and \"undefined\" to be equal.\n\n@param {Object} a The first argument.\n@param {Object} b The second argument.\n@return {Object} True if both arguments are equal, or if \"null\" or \"undefined\".\n@export"
      },
      "ne": {
        "!type": "fn(a: ?, b: ?) -> bool|?",
        "!span": "1563[52:30]-1565[52:32]",
        "!doc": "Performs a strict negative comparison while avoiding \"null\" and \"undefined\" to be equal.\n\n@param {Object} a The first argument.\n@param {Object} b The second argument.\n@return {Object} True if both arguments are equal, or if \"null\" or \"undefined\".\n@export"
      },
      "add": {
        "!type": "fn(a: ?, b: ?) -> !0",
        "!span": "2087[70:30]-2090[70:33]",
        "!doc": "Performs string concatenations and numeric additions while avoiding concatenating\n\"null\" or \"undefined\" when one or both arguments are undefined or null.\n\n@param {Object} a The first argument.\n@param {Object} b The second argument.\n@return {Object} The sum (numbers) or the concatenation (string) of the arguments.\n@export"
      },
      "empty": {
        "!type": "fn(obj: ?) -> bool",
        "!span": "2525[93:30]-2530[93:35]",
        "!doc": "Passthrough to $A.util.isEmpty\n@export"
      },
      "format": {
        "!type": "fn() -> string",
        "!span": "2855[103:30]-2861[103:36]",
        "!doc": "Preprocess the arguments of format() so they make sense in\na UI context, where the expressions are used. Prevent the\noutput of null and undefined but still allow for any missing\nplaceholders to be seen in developement mode.\n@export"
      },
      "token": {
        "!type": "fn(token: ?) -> string",
        "!span": "3627[134:30]-3632[134:35]",
        "!doc": "Passthrough to $A.getToken(token);\n@export"
      },
      "join": {
        "!type": "fn(separator: ?) -> string",
        "!span": "3859[147:30]-3863[147:34]",
        "!doc": "Passthrough to Array.prototype.join(separator);\n@export"
      }
    },
    "!type": "fn()",
    "!span": "783[25:9]-802[25:28]",
    "!doc": "@class ExpressionFunctions.\n\nclient implementations of the expression functions\n\n@constructor\n@protected\n@export"
  },
  "FunctionCallValue": {
    "prototype": {
      "expressionFunctions": {
        "!type": "+ExpressionFunctions",
        "!span": "1283[41:28]-1302[41:47]",
        "!doc": "Create a local subclass."
      },
      "isDirty": {
        "!type": "fn() -> bool",
        "!span": "1415[47:28]-1422[47:35]",
        "!doc": "Sets the isDirty flag to false.\n@export"
      },
      "evaluate": {
        "!type": "fn(valueProvider: ?)",
        "!span": "1849[62:28]-1857[62:36]",
        "!doc": "Returns the value of function call with the given value provider.\nThrows an error if vp is not provided.\n@param {Object} valueProvider The value provider to resolve."
      },
      "addChangeHandler": {
        "!type": "fn(cmp: ?, key: ?, fcv: +FunctionCallValue)",
        "!span": "2230[75:28]-2246[75:44]",
        "!doc": "@export"
      },
      "getChangeHandler": {
        "!type": "fn(cmp: ?, key: ?, fcv: +FunctionCallValue) -> fn(event: ?)",
        "!span": "2757[94:28]-2773[94:44]"
      },
      "removeChangeHandler": {
        "!type": "fn(cmp: ?, key: ?)",
        "!span": "3212[108:28]-3231[108:47]",
        "!doc": "@export"
      },
      "destroy": {
        "!type": "fn()",
        "!span": "3565[124:28]-3572[124:35]",
        "!doc": "Destroys the value wrapper.\n@export"
      },
      "toString": {
        "!type": "fn() -> string",
        "!span": "3968[141:28]-3976[141:36]",
        "!doc": "Returns the JS function.\nHelpful for logging/debugging.\n@returns {String} FunctionCallValue\n@export"
      }
    },
    "!type": "fn(config: ?, valueProvider: ?)",
    "!span": "745[22:9]-762[22:26]",
    "!doc": "@description A Value wrapper for a function call.\n@constructor\n@protected\n@export",
    "args": {
      "!type": "[AuraInstance.context.contextGlobals|+PropertyReferenceValue]",
      "!span": "989[28:9]-993[28:13]",
      "!doc": "#end\nJBUCH: HALO: TODO: FIXME\n   for(var i=0;i<this.args.length;i++){\n       this.args[i].destroy();\n   }"
    },
    "id": {
      "!type": "number",
      "!span": "2706[66:14]-2708[66:16]"
    }
  },
  "PassthroughValue": {
    "prototype": {
      "addValueHandler": {
        "!type": "fn(config: ?)",
        "!span": "1404[36:27]-1419[36:42]",
        "!doc": "Since PassthroughValue can have its own set of values that can be listen for changes,\nit needs it's own value change handler logic. Essentially you should be able to treat\nit like a component for change events. It does not mark dirty though, since a passthrough\ndoes have anything to rerender, marking dirty is the responsibility of the referencing components.\n@export"
      },
      "deIndex": {
        "!type": "fn()",
        "!span": "3236[88:27]-3243[88:34]",
        "!doc": "Delegates de-indexing logic to the wrapped value provider.\nLikely delegating to a wrapped component.\n@export"
      },
      "fireChangeEvent": {
        "!type": "fn(key: string, oldValue: ?, value: ?, index: string)",
        "!span": "3708[107:27]-3723[107:42]",
        "!doc": "Fires handlers registered for the specified key when the value changes\n@export"
      },
      "get": {
        "!type": "fn(key: string)",
        "!span": "4813[140:27]-4816[140:30]",
        "!doc": "Returns the primary providers associated with the given key or the Component.\n@param {String} key The data key to look up on the primary providers.\n@export"
      },
      "getComponent": {
        "!type": "fn() -> !this.component",
        "!span": "5372[162:27]-5384[162:39]",
        "!doc": "Returns the Component.\n@export"
      },
      "getPrimaryProviderKeys": {
        "!type": "fn() -> [string]",
        "!span": "5588[171:27]-5610[171:49]",
        "!doc": "Gets all the keys for the additional providers specified in the passthrough value.\n@export\n@return Array of keys"
      },
      "getDef": {
        "!type": "fn()",
        "!span": "5923[180:27]-5929[180:33]",
        "!doc": "Get the definition of the valueProvider component.\nIf the immediate value provider for this passthrough value is another passthrough value\nit will resolve up the chain till it finds a valid component."
      },
      "getExpression": {
        "!type": "fn(expression: string) -> !0",
        "!span": "6546[195:27]-6559[195:40]",
        "!doc": "Passthrough's have extra providers that can reference other items of data.\nIf it's raw data, no problem. If it's another reference, you may want to\nexpand that reference. {row.value} could expand into {v.item.0.value} if row\nis at index 0.\n@param {String} expression The key to reference on the component, which will get expanded into the reference you were looking for."
      },
      "getReference": {
        "!type": "fn(key: string) -> !this.references.<i>",
        "!span": "7269[217:27]-7281[217:39]",
        "!doc": "Returns a reference to a key on the the primary provider or the Component.\n@param {String} key The data key for which to return a reference.\n@export"
      },
      "index": {
        "!type": "fn()",
        "!span": "7827[235:27]-7832[235:32]",
        "!doc": "Delegates indexing logic to the wrapped value provider.\nLikely delegating to a wrapped component.\n@export"
      },
      "removeValueHandler": {
        "!type": "fn(config: ?)",
        "!span": "8311[255:27]-8329[255:45]",
        "!doc": "Removes a handler for the specified type of event. Currently only supports\n'change'.\n@export"
      },
      "set": {
        "!type": "fn(key: string, value: ?, ignoreChanges: ?) -> !1",
        "!span": "10127[301:27]-10130[301:30]",
        "!doc": "Sets the value of the primary providers associated value.\n@param {String} key The data key to look up on the primary providers.\n@param {Object} v The value to be set.\n@export"
      },
      "isValid": {
        "!type": "fn() -> bool",
        "!span": "11806[356:27]-11813[356:34]",
        "!doc": "Returns true if the referenced component has not been destroyed."
      }
    },
    "!type": "fn(primaryProviders: ?, component: ?)",
    "!span": "810[22:9]-826[22:25]",
    "!doc": "@description A value provider that resolves against a few primary providers first, then falls back on a component.\n@constructor\n@protected\n@export",
    "references": {
      "!span": "945[25:9]-955[25:19]"
    },
    "handlers": {
      "<i>": {
        "<i>": {
          "!type": "[?]",
          "!span": "2722[72:17]-2732[72:27]"
        },
        "!span": "2516[64:33]-2521[64:38]"
      },
      "!span": "969[26:9]-977[26:17]"
    }
  },
  "PropertyReferenceValue": {
    "prototype": {
      "evaluate": {
        "!type": "fn(valueProvider: ?) -> !this.lastResult",
        "!span": "1348[39:33]-1356[39:41]",
        "!doc": "Returns the dereferenced value indicated by the path supplied."
      },
      "set": {
        "!type": "fn(value: ?)",
        "!span": "1802[54:33]-1805[54:36]",
        "!doc": "Sets the value indicated by the path"
      },
      "addChangeHandler": {
        "!type": "fn(cmp: +Component, key: string, method: fn(event: ?), rebind: bool)",
        "!span": "2139[67:33]-2155[67:49]",
        "!doc": "@export"
      },
      "removeChangeHandler": {
        "!type": "fn(cmp: ?, key: ?)",
        "!span": "3608[105:33]-3627[105:52]",
        "!doc": "@export"
      },
      "getExpression": {
        "!type": "fn() -> !this.expression",
        "!span": "4336[126:33]-4349[126:46]",
        "!doc": "Returns the value in the format \"v.expression\"."
      },
      "getReference": {
        "!type": "fn(path: ?) -> !this",
        "!span": "4430[130:33]-4442[130:45]"
      },
      "equals": {
        "!type": "fn(target: ?) -> bool",
        "!span": "4861[144:33]-4867[144:39]"
      },
      "isDirty": {
        "!type": "fn() -> bool",
        "!span": "5121[152:33]-5128[152:40]",
        "!doc": "Sets the isDirty flag to false.\n@export"
      },
      "destroy": {
        "!type": "fn()",
        "!span": "5823[171:33]-5830[171:40]",
        "!doc": "Destroys the path.\n@export"
      },
      "toString": {
        "!type": "fn() -> string",
        "!span": "6094[182:33]-6102[182:41]",
        "!doc": "Returns \"PropertyReferenceValue\" as String.\n@export"
      },
      "toJSON": {
        "!type": "fn() -> AuraInstance.context.contextGlobals",
        "!span": "6318[189:33]-6324[189:39]",
        "!doc": "When serializing say an Action, we don't want to serialize the reference elements, but the value under the covers."
      }
    },
    "!type": "fn(path: ?, valueProvider: ?)",
    "!span": "750[22:9]-772[22:31]",
    "!doc": "@description A Value wrapper for a property reference.\n@constructor\n@protected\n@export",
    "isGlobal": {
      "!type": "bool",
      "!span": "941[26:9]-949[26:17]"
    },
    "lastResult": {
      "length": {
        "!type": "number",
        "!span": "66402[176:60899]-66408[176:60905]"
      },
      "marker": {
        "!type": "number",
        "!span": "66474[176:60971]-66480[176:60977]"
      },
      "!span": "1145[29:9]-1155[29:19]",
      "!doc": "the action that errors out",
      "request": "+XMLHttpRequest"
    },
    "id": {
      "!type": "number",
      "!span": "2706[66:14]-2708[66:16]"
    }
  },
  "valueFactory": {
    "create": {
      "!type": "fn(valueConfig: ?, def: ?, component: ?) -> AuraInstance.context.contextGlobals|+PropertyReferenceValue",
      "!span": "726[20:4]-732[20:10]"
    },
    "nextId": {
      "!type": "number",
      "!span": "2512[57:5]-2518[57:11]"
    },
    "index": {
      "!type": "fn(value: +FunctionCallValue|+PropertyReferenceValue)",
      "!span": "2530[59:4]-2535[59:9]"
    },
    "getIndex": {
      "!type": "fn(type: string) -> !this.valueIndex",
      "!span": "2755[71:4]-2763[71:12]"
    },
    "valueIndex": {
      "!span": "2880[75:17]-2890[75:27]",
      "<i>": "valueFactory.valueIndex"
    },
    "clearIndex": {
      "!type": "fn()",
      "!span": "3161[90:4]-3171[90:14]"
    },
    "deIndex": {
      "!type": "fn(value: ?)",
      "!span": "3230[94:4]-3237[94:11]"
    },
    "!span": "705[19:4]-717[19:16]",
    "!doc": "creates the right value object based on whats passed in"
  },
  "Node": {
    "aura_deleted": {
      "!type": "bool",
      "!span": "28510[880:24]-28524[880:38]"
    },
    "aura_marker": {
      "!type": "bool",
      "!span": "31179[863:9]-31190[863:20]"
    },
    "className": {
      "!type": "string",
      "!span": "21228[659:24]-21239[659:35]"
    },
    "<i>": "cancelAnimationFrame"
  },
  "Element": {
    "className": {
      "!type": "string",
      "!span": "25630[767:31]-25639[767:40]"
    },
    "src": {
      "!type": "string",
      "!span": "5512[168:27]-5515[168:30]"
    },
    "type": {
      "!type": "string",
      "!span": "2958[68:18]-2962[68:22]"
    },
    "href": {
      "!type": "string",
      "!span": "2262[71:22]-2266[71:26]"
    },
    "textContent": {
      "!type": "string",
      "!span": "1692[54:21]-1703[54:32]",
      "!doc": "webkit & ff"
    },
    "innerText": {
      "!type": "string",
      "!span": "1810[57:21]-1819[57:30]",
      "!doc": "webkit"
    },
    "innerHTML": {
      "!type": "string",
      "!span": "1880[60:21]-1889[60:30]",
      "!doc": "ff"
    },
    "aura_deleted": {
      "!type": "bool",
      "!span": "28510[880:24]-28524[880:38]"
    },
    "onload": {
      "!type": "fn()",
      "!span": "79957[2364:14]-79963[2364:20]"
    },
    "<i>": "cancelAnimationFrame"
  },
  "Document": {
    "_appcacheChecking": {
      "!type": "bool",
      "!span": "25739[773:17]-25756[773:34]"
    },
    "cookie": {
      "!type": "string",
      "!span": "99457[2943:17]-99463[2943:23]"
    },
    "title": {
      "!type": "string",
      "!span": "7107[178:13]-7112[178:18]"
    },
    "className": {
      "!type": "string",
      "!span": "21228[659:24]-21239[659:35]"
    },
    "<i>": "cancelAnimationFrame"
  },
  "Error": {
    "handled": {
      "!type": "bool",
      "!span": "31775[866:14]-31784[866:23]"
    },
    "severity": {
      "!type": "string",
      "!span": "31868[870:14]-31876[870:22]"
    },
    "reported": {
      "!type": "bool",
      "!span": "5635[184:6]-5645[184:16]"
    }
  },
  "XMLHttpRequest": {
    "withCredentials": {
      "!type": "bool",
      "!span": "66691[1988:24]-66708[1988:41]"
    },
    "onreadystatechange": {
      "!type": "fn()",
      "!span": "67438[2012:20]-67458[2012:40]"
    },
    "<i>": {
      "!type": "fn(e: ?)",
      "!span": "9712[96:6671]-9724[96:6683]"
    }
  },
  "aura": "+AuraInstance",
  "DocumentFragment": {
    "<i>": "cancelAnimationFrame"
  }
}
